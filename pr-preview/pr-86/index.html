<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ⓒエディタ（動作確認版）</title>
<link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16.png">
<link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32.png">
<link rel="apple-touch-icon" sizes="192x192" href="icons/icon-192.png">
<link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho&family=Noto+Sans+JP&family=Zen+Old+Mincho&family=M+PLUS+Rounded+1c&family=Yuji+Syuku&display=swap" rel="stylesheet">

<style>
    :root {
        --active-tab-bg: #fff59d;
        --active-tab-border: #f59e0b;
        --active-tab-text: var(--text-color);
        --bg-color: #f3f4f6; --panel-bg: #ffffff; --border-color: #e5e7eb;
        --preview-bg-color: #fdfcf0; --text-color: #1f2937; --text-muted: #6b7280;
        --header-bg: #f3f4f6; --pane-header-bg: #f9fafb;
        --col-zen-bg: #dbeafe; --col-zen-tx: #2563eb;
        --col-han-bg: #d1fae5; --col-han-tx: #059669;
        --col-mute-bg: transparent; --col-mute-tx: #d1d5db;
        --col-sym-bg: #ede9fe; --col-sym-tx: #7c3aed;
        --layout-padding: 6px;
        --layout-gap: 0px;
        --dock-top: 46px;
        --divider-size: 2px;
        --divider-hit-area: 10px;
    }
    body.theme-dark {
        --bg-color: #1f2937; --panel-bg: #374151; --border-color: #4b5563;
        --preview-bg-color: #2d3748; --text-color: #f3f4f6; --text-muted: #9ca3af;
        --header-bg: #111827; --pane-header-bg: #4b5563;
        --col-zen-bg: #1e3a5f; --col-zen-tx: #93c5fd;
        --col-han-bg: #14532d; --col-han-tx: #86efac;
        --col-mute-bg: transparent; --col-mute-tx: #6b7280;
        --col-sym-bg: #4c1d95; --col-sym-tx: #c4b5fd;
    }
    body.theme-sepia {
        --bg-color: #f5f0e1; --panel-bg: #faf6eb; --border-color: #d4c4a8;
        --preview-bg-color: #fdf8e8; --text-color: #5c4b37; --text-muted: #8b7355;
        --header-bg: #ebe3d0; --pane-header-bg: #f0e8d8;
    }
    body.theme-blue {
        --bg-color: #e0f2fe; --panel-bg: #f0f9ff; --border-color: #7dd3fc;
        --preview-bg-color: #f0f9ff; --text-color: #0c4a6e; --text-muted: #0369a1;
        --header-bg: #bae6fd; --pane-header-bg: #e0f2fe;
    }
    body.theme-green {
        --bg-color: #dcfce7; --panel-bg: #f0fdf4; --border-color: #86efac;
        --preview-bg-color: #f0fdf4; --text-color: #14532d; --text-muted: #166534;
        --header-bg: #bbf7d0; --pane-header-bg: #dcfce7;
    }
    * { box-sizing: border-box; }
    body {
        margin: 0; padding: 0; font-family: "Helvetica Neue", Arial, sans-serif;
        background: var(--bg-color); color: var(--text-color);
        height: 100vh; overflow: hidden; display: flex; flex-direction: column;
    }
    body.scroll-mode { height: auto; overflow-y: auto; display: block; }
    body.allow-scroll { height: auto; overflow-y: auto; }
    body.focus-mode header, body.focus-mode .controls-wrapper, body.focus-mode .pane-header,
    body.focus-mode .pane-subheader, body.focus-mode #outline-panel { display: none !important; }
    body.focus-mode #pane-preview { display: none !important; }
    body.focus-mode .main-container { padding: 0; }
    body.focus-mode .pane { border-radius: 0; border: none; }
    body.focus-mode #pane-input { flex: 1; width: 100%; padding-bottom: 40px; }
    body.focus-mode #pane-input .pane-footer {
        display: flex !important;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        transform: none;
        background: rgba(0,0,0,0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 0;
        font-size: 0.75rem;
        z-index: 9998;
        gap: 12px;
        justify-content: center;
    }
    body.focus-mode #pane-input .pane-footer span { color: white; }
    body.focus-mode #pane-preview .pane-footer { display: none !important; }
    .focus-exit-hint {
        position: fixed; bottom: 50px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.7); color: white; padding: 8px 16px;
        border-radius: 20px; font-size: 0.8rem; z-index: 9999; display: none;
        opacity: 1; transition: opacity 0.5s ease-out;
    }
    .focus-exit-hint.fade-out { opacity: 0; }
    body.focus-mode .focus-exit-hint { display: block; }
    .focus-exit-btn {
        position: fixed;
        top: 10px;
        right: 12px;
        z-index: 9999;
        display: none;
        align-items: center;
        justify-content: center;
        width: 32px;
        height: 32px;
        border-radius: 50%;
        border: 1px solid rgba(255,255,255,0.4);
        background: rgba(0,0,0,0.7);
        color: #fff;
        font-size: 1rem;
        cursor: pointer;
    }
    .focus-exit-btn:hover { background: rgba(0,0,0,0.85); }
    body.focus-mode .focus-exit-btn { display: inline-flex; }

    header {
        background: var(--header-bg);
        padding: 8px 10px;
        display: flex;
        flex-direction: column;
        align-items: stretch;
        flex-shrink: 0;
        border-bottom: 1px solid var(--border-color);
        z-index: 100;
        gap: 6px;
    }
    body.scroll-mode header { position: sticky; top: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1 { margin: 0; font-size: 1.0rem; color: var(--text-color); margin-right: 15px; }
    .header-left, .header-right { display: flex; align-items: center; flex-wrap: wrap; gap: 4px; }
    .ribbon-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
    }
    .ribbon-left {
        display: flex;
        align-items: center;
        gap: 10px;
        min-width: 0;
        flex: 1;
    }
    .app-icon {
        width: 28px;
        height: 28px;
        border-radius: 6px;
        border: 1px solid var(--border-color);
        background: var(--panel-bg);
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0;
        cursor: pointer;
        flex-shrink: 0;
    }
    .app-icon img { width: 18px; height: 18px; display: block; border-radius: 4px; }
    .app-title {
        font-weight: 600;
        font-size: 0.95rem;
        color: var(--text-color);
        max-width: 280px;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .ribbon-menu {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 6px;
        color: var(--text-muted);
        font-size: 0.8rem;
    }
    .ribbon-menu-btn {
        padding: 2px 8px;
        border-radius: 4px;
        border: 1px solid transparent;
        background: transparent;
        color: inherit;
        cursor: pointer;
        font-size: 0.8rem;
        transition: background-color 120ms ease, border-color 120ms ease, color 120ms ease;
    }
    .ribbon-menu-btn:hover {
        background: rgba(0,0,0,0.04);
        border-color: var(--border-color);
        color: var(--text-color);
    }
    .ribbon-menu-btn.active {
        background: var(--panel-bg);
        border-color: var(--border-color);
        color: var(--text-color);
    }
    .ribbon-menu-item {
        padding: 2px 6px;
        border-radius: 4px;
        color: var(--text-muted);
    }
    .ribbon-section {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 6px;
    }
    .ribbon-section[data-section]:not(.ribbon-home):not(.is-active) { display: none; }
    .ribbon-section.is-active { display: flex; }
    .ribbon-section + .ribbon-section {
        border-top: 1px solid var(--border-color);
        padding-top: 6px;
    }
    .ribbon-group {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 4px;
    }
    .ribbon-separator {
        color: var(--text-muted);
        margin: 0 4px;
    }
    .ribbon-home {
        justify-content: space-between;
        width: 100%;
    }
    .ribbon-home-left {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 4px;
    }
    .ribbon-toggle { white-space: nowrap; }
    .ribbon-home-toggle {
        padding: 2px 8px !important;
        height: 24px !important;
        min-width: 24px;
        font-size: 0.75rem !important;
        margin-left: auto;
    }
    body.ribbon-collapsed .ribbon-section:not(.ribbon-home) { display: none; }
    body.ribbon-collapsed .ribbon-home { border-top: none; padding-top: 0; }
    body.ribbon-ultra-collapsed .ribbon-row { display: none; }
    body.ribbon-ultra-collapsed .ribbon-section:not(.ribbon-home) { display: none; }
    body.ribbon-ultra-collapsed .ribbon-home { border-top: none; padding-top: 0; }

    /* --- Ribbon inline slot (Insert の右横で入れ替える領域) --- */
    .ribbon-inline-slot {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
        margin-left: 4px;
        min-width: 0;
    }
    .ribbon-inline-slot .ribbon-group {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        flex-wrap: wrap;
    }

    /* 折りたたみ（パネル）: Insert右側の領域を隠す */
    body.ribbon-collapsed #ribbon-inline-slot { display: none; }

    /* 超折りたたみ（リボン）: 上段メニューは消すが、ホーム左（Undo〜挿入）は残す */
    body.ribbon-ultra-collapsed #ribbon-inline-slot { display: none; }

    /* ファイル系ボタンは「挿入の右横」に出すと高さが増えやすいので、スロット内では装飾を軽量化 */
    #ribbon-inline-slot .header-file-group{
        background: transparent;
        padding: 0;
        border-radius: 0;
        margin-left: 0;
        height: 28px;
        align-items: center;
    }
    #ribbon-inline-slot .header-file-dropdown{
        height: 28px;
    }
    #ribbon-inline-slot .header-file-dropdown > .btn{
        height: 28px;
    }
    #ribbon-inline-slot{
        min-height: 28px;
    }

    /* Undo/Redo はアイコンボタンとしてサイズを揃える */
    .btn-undo {
        width: 32px;
        padding: 0 !important;
        justify-content: center;
        font-size: 1rem;
    }


    .btn {
        background: var(--panel-bg); border: 1px solid var(--border-color); padding: 4px 10px;
        cursor: pointer; border-radius: 4px; font-size: 0.8rem; color: var(--text-color);
        transition: all 0.2s; display: inline-flex; align-items: center; gap: 4px;
        height: 28px; line-height: 1; white-space: nowrap;
    }
    .btn:hover {
        background: var(--pane-header-bg);
        border-color: #6b7280;
        box-shadow: 0 1px 2px rgba(0,0,0,0.08);
    }
    .btn:active { transform: translateY(0.5px); }
    .btn:focus-visible { outline: 2px solid rgba(0,0,0,0.18); outline-offset: 1px; }
    .btn.active { background: #e5e7eb; font-weight: bold; border-color: #6b7280; }
    body.theme-dark .btn.active { background: #4b5563; }
    .btn-update { background: #e0f2fe; color: #0369a1; border-color: #7dd3fc; font-weight: bold; }
    .btn-update:hover { background: #bae6fd; }
    .btn-sync { background: #fef9c3; color: #854d0e; border-color: #fde047; font-weight: bold; }
    .btn-sync:hover { background: #fef08a; }
    .btn-save { background: #2563eb; color: white; border: 1px solid #1d4ed8; }
    .btn-save:hover { background: #1d4ed8; color: white; }
    .btn-text-file { background: #dbeafe; color: #1d4ed8; border-color: #93c5fd; }
    .btn-text-file:hover { background: #bfdbfe; }
    .btn-project-file { background: #fef3c7; color: #92400e; border-color: #fcd34d; }
    .btn-project-file:hover { background: #fde68a; }
    .header-file-group {
        display: inline-flex;
        gap: 2px;
        background: var(--pane-header-bg);
        border-radius: 6px;
        padding: 2px;
        margin-left: 4px;
    }
    .header-file-dropdown {
        position: relative;
        display: inline-block;
    }
    .header-file-dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        left: 0;
        min-width: 140px;
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 1000;
        padding: 4px 0;
    }
    .header-file-dropdown.open .header-file-dropdown-content {
        display: block;
    }
    .header-file-dropdown-content .dropdown-item {
        padding: 8px 12px;
        cursor: pointer;
        font-size: 0.85rem;
        display: flex;
        align-items: center;
        gap: 6px;
    }
    .header-file-dropdown-content .dropdown-item:hover {
        background: var(--pane-header-bg);
    }
    .btn-reset-input {
        background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca;
        font-weight: bold; padding: 4px 8px;
    }
    .btn-reset-input:hover { background: #fecaca; color: #991b1b; }
    .btn-undo { background: #f3e8ff; color: #7c3aed; border-color: #d8b4fe; }
    .btn-undo:hover { background: #ede9fe; }
    .btn-apply { background: #dcfce7; color: #166534; border-color: #86efac; font-size: 0.7rem; padding: 2px 6px; height: 22px; }
    .btn-apply:hover { background: #bbf7d0; }
    .btn-apply-all { background: #fef3c7; color: #92400e; border-color: #fcd34d; font-weight: bold; }
    .btn-apply-all:hover { background: #fde68a; }
    .btn-focus { background: #fce7f3; color: #be185d; border-color: #f9a8d4; }
    .btn-focus:hover { background: #fbcfe8; }
    .btn-focus.active { background: #be185d; color: white; }
    .btn-analysis { background: #dbeafe; color: #1d4ed8; border-color: #93c5fd; font-weight: bold; }
    .btn-analysis:hover { background: #bfdbfe; }
    .btn-export { background: #fef3c7; color: #92400e; border-color: #fcd34d; font-size: 0.7rem; padding: 2px 6px; }
    .btn-import { background: #e0e7ff; color: #3730a3; border-color: #a5b4fc; font-size: 0.7rem; padding: 2px 6px; }
    #file-input, #settings-file-input, #project-file-input { display: none; }

    .dropdown { position: relative; display: inline-block; }
    .dropdown-btn { background: #fef3c7; color: #92400e; border-color: #fcd34d; }
    .dropdown-content {
        display: none; position: absolute; top: 100%; left: 0;
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 300; min-width: 160px;
    }
    .dropdown-content.show { display: block; }
    .dropdown-content button {
        display: block; width: 100%; padding: 8px 12px; border: none;
        background: transparent; text-align: left; cursor: pointer;
        font-size: 0.85rem; color: var(--text-color);
    }
    .dropdown-content button:hover { background: #e0f2fe; }
    .dropdown-content a {
        display: block; width: 100%; padding: 8px 12px; border: none;
        background: transparent; text-align: left; cursor: pointer;
        font-size: 0.85rem; color: var(--text-color); text-decoration: none;
    }
    .dropdown-content a:hover { background: #e0f2fe; }
    .sync-dropdown:hover .sync-dropdown-content { display: block; }

    .controls-wrapper { padding: var(--layout-padding) var(--layout-padding) 0 var(--layout-padding); display: flex; flex-direction: column; gap: 6px; flex-shrink: 0; }
    .control-panel {
        background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px;
        padding: 8px 12px; font-size: 0.85rem; display: none;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05); position: relative;
    }
    .control-panel.open { display: flex; animation: slideDown 0.2s ease-out; }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
    .panel-action-buttons {
        position: absolute; top: 4px; right: 8px; display: flex; align-items: center;
        gap: 6px; z-index: 2;
    }
    .panel-close-btn,
    .panel-pin-btn {
        background: transparent; border: none; color: var(--text-muted); cursor: pointer;
        font-size: 1rem; padding: 4px 6px; line-height: 1; min-width: 22px;
    }
    .panel-close-btn:hover { color: #dc2626; }
    .panel-pin-btn { font-size: 0.9rem; opacity: 0.7; }
    .panel-pin-btn:hover { opacity: 1; }
    .panel-pin-btn.pinned { color: #dc2626; opacity: 1; }

    .panel-drag-handle { cursor: move; }
    .panel-drag-handle.dragging { opacity: 0.6; }


    .panel-dnd-dropzone.drag-over { outline: 2px dashed var(--border-color); outline-offset: -4px; }
    #search-match-info { font-weight: bold; color: #15803d; min-width: 60px; text-align: center; }
    .btn-search-exec { background: #dcfce7; color: #166534; border-color: #86efac; font-weight: bold; }
    .btn-search-reset {
        background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca;
        font-weight: bold;
    }
    .btn-search-reset:hover { background: #fecaca; color: #991b1b; }
    .search-meta { color: var(--text-muted); font-size: 0.85em; }

    #help-bar { background: #fffbeb; border: 1px solid #fcd34d; color: #92400e; line-height: 1.8; flex-direction: column; padding-right: 48px; order: 1; }
    #help-bar.open { display: flex; }
    body.theme-dark #help-bar { background: #451a03; border-color: #854d0e; color: #fcd34d; }
    .help-section { margin-bottom: 12px; }
    .help-section:last-child { margin-bottom: 0; }
    .help-title { font-weight: bold; font-size: 0.9rem; margin-bottom: 4px; border-bottom: 1px dashed #fcd34d; padding-bottom: 2px; }

    #settings-bar { margin-bottom: 0; flex-wrap: wrap; gap: 12px; font-size: 0.8rem; padding: 8px 10px; padding-right: 14px; order: 3; }
    #settings-bar .panel-action-buttons { right: 2px; }
    .setting-group { display: flex; flex-direction: column; gap: 4px; border-right: 1px solid var(--border-color); padding-right: 12px; }
    .setting-group:last-child { border-right: none; }
    .setting-title { font-weight: bold; color: var(--text-muted); margin-bottom: 2px; font-size: 0.75rem; display: flex; align-items: center; gap: 6px; }
    .setting-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .setting-row.vertical { flex-direction: column; align-items: flex-start; gap: 6px; }
    input[type="number"] { width: 50px; }
    .settings-actions {
        position: absolute; right: 2px; bottom: 2px;
        display: flex; flex-direction: column;
        align-items: flex-end; gap: 4px;
        text-align: right; background: var(--panel-bg);
        padding: 4px; border-radius: 4px;
    }
    .settings-actions-row {
        display: flex; gap: 8px; flex-direction: column;
        align-items: flex-end; justify-content: flex-end;
    }
    .settings-actions-row .btn-apply-all { margin-top: auto; }
    .settings-action-btn { min-width: 140px; justify-content: center; }

    .main-container { display: flex; flex: 1; gap: var(--layout-gap); overflow-x: auto; overflow-y: hidden; overscroll-behavior-x: contain; -webkit-overflow-scrolling: touch; padding: var(--layout-padding); position: relative; max-width: 100vw; width: 100%; box-sizing: border-box; }
    .pane-stack { display: flex; flex: 1; min-width: 0; min-height: 0; gap: 0; }
    /* .pane-stack.reverse-row uses order property for swapping */
    body.scroll-mode .main-container { overflow: visible; height: auto; max-height: none; width: 100%; max-width: 100vw; }
    body.scroll-mode .pane-stack { flex-direction: column; width: 100%; }
    body.scroll-mode .pane-stack.reverse-col { flex-direction: column-reverse; }

    .pane {
        flex: 1 1 auto; display: flex; flex-direction: column;
        background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px;
        min-width: 0; min-height: 0; overflow: hidden; position: relative;
    }
    #pane-input { order: 1; }
    #pane-preview { order: 3; }
    .pane-resizer { order: 2; }
    .pane-stack.reverse-row #pane-input { order: 3; }
    .pane-stack.reverse-row #pane-preview { order: 1; }
    .pane.hidden { display: none !important; }
    body.scroll-mode .pane-stack .pane { flex: none; margin-bottom: 15px; min-height: 240px; width: 100%; max-width: 100%; }
    body.scroll-mode .pane-stack .pane:last-child { margin-bottom: 0; }

    /* Pane Resizer */
    .pane-resizer {
        width: var(--divider-hit-area); cursor: col-resize;
        position: relative; flex-shrink: 0; z-index: 10;
        margin: 0 calc(-1 * (var(--divider-hit-area) / 2));
        display: flex; align-items: center; justify-content: center;
        background: transparent;
    }
    .pane-resizer::before {
        content: "";
        width: var(--divider-size);
        height: 100%;
        background: var(--border-color);
        border-radius: 999px;
    }
    .pane-resizer:hover::before,
    .pane-resizer.resizing::before { background: #3b82f6; }
    body.scroll-mode .pane-stack .pane-resizer {
        width: 100%;
        height: var(--divider-hit-area);
        cursor: row-resize;
        margin: calc(-1 * (var(--divider-hit-area) / 2)) 0;
    }
    body.scroll-mode .pane-stack .pane-resizer::before {
        width: 100%;
        height: var(--divider-size);
    }

    .dock-resizer {
        width: var(--divider-hit-area); cursor: col-resize;
        position: relative; flex-shrink: 0; z-index: 10;
        margin: 0 calc(-1 * (var(--divider-hit-area) / 2));
        display: none; align-items: center; justify-content: center;
        background: transparent;
    }
    .dock-resizer::before {
        content: "";
        width: var(--divider-size);
        height: 100%;
        background: var(--border-color);
        border-radius: 999px;
    }
    .dock-resizer:hover::before,
    .dock-resizer.resizing::before { background: #3b82f6; }

    /* ドック境界の誤操作を減らす（プレビュー｜メモ の境界を優先） */
    #resizer-memo { z-index: 20; }
    #resizer-memo-outline { z-index: 8; width: calc(var(--divider-hit-area) - 6px); }


    .pane-header {
        background: var(--pane-header-bg); padding: 0 10px; color: var(--text-muted); height: 28px;
        display: flex; justify-content: flex-start; align-items: center;
        border-bottom: 1px solid var(--border-color); flex-shrink: 0;
    }
    .pane-title { display: flex; align-items: center; gap: 8px; min-width: 0; flex: 1;}
    .pane-header h2 { margin: 0; font-size: 0.8rem; font-weight: bold; flex: 1; min-width: 0; overflow: hidden;}
    .novel-title-name {
        font-weight: bold; color: var(--text-color);
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 4px; padding: 1px 6px;
        cursor: text;
        width: fit-content;
		max-width: 100%;
		min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        display: inline-block;
        vertical-align: middle;
    }
    .pane-total-stats {
        font-size: 0.7rem; color: var(--text-muted);
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 999px; padding: 1px 6px; white-space: nowrap; flex: 0 0 auto; margin-left: auto;
    }

    /* プレビュー上部（タイトル/タブバー）を羊皮紙っぽい色へ */
    #pane-preview .pane-header,
    #pane-preview .tabs-scroll-wrap {
        background: var(--preview-bg-color);
    }



    /* Tabs Scroll Buttons (Input/Preview/Memo) */
    .tabs-scroll-wrap {
        display: flex; align-items: stretch;
        background: var(--pane-header-bg);
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
        min-height: 32px;
        min-width: 0;
    }
    /* Memo toolbar already has its own background/border */
    .tabs-scroll-wrap.memo-tabs-wrap {
        background: transparent;
        border-bottom: none;
        min-height: auto;
        padding: 0;
    }
    /* メモタブが枠外へはみ出さないように */
    .memo-toolbar { overflow: hidden; }
    .tabs-scroll-wrap.memo-tabs-wrap { width: 100%; }
    .tabs-scroll-wrap.memo-tabs-wrap .memo-tabs { overflow-x: auto; overflow-y: hidden; }

    .tab-scroll-btn {
        width: 26px;
        flex: 0 0 26px;
        border: none;
        background: transparent;
        cursor: pointer;
        color: var(--text-muted);
        display: none;
        align-items: center;
        justify-content: center;
        user-select: none;
    }
    .tab-scroll-btn:hover { background: var(--panel-bg); color: var(--text-color); }
    .tab-scroll-btn:active { transform: translateY(1px); }
    .tab-scroll-btn.show { display: flex; }
    .tabs-scroll-wrap .input-tabs-container,
    .tabs-scroll-wrap .preview-tabs-container,
    .tabs-scroll-wrap .memo-tabs {
        flex: 1 1 auto;
        min-width: 0;
    }

    /* Input Tabs */
    .input-tabs-container {
        display: flex; align-items: center;
        overflow-x: auto;
        flex: 1 1 auto;
        min-height: 32px;
        min-width: 0;
        background: transparent;
    }
    .input-tabs-container::-webkit-scrollbar { height: 3px; }
    .input-tabs-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
    .input-tab {
        padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border: none;
        background: transparent; color: var(--text-muted); white-space: nowrap;
        border-right: 1px solid var(--border-color); display: flex; align-items: center; gap: 6px;
        transition: all 0.2s;
    }
    .input-tab:hover { background: var(--panel-bg); }
    .input-tab.active { background: var(--active-tab-bg); color: var(--active-tab-text); font-weight: bold; border-bottom: 2px solid var(--active-tab-border); }
    .input-tab .tab-close {
        font-size: 0.7rem; color: var(--text-muted); cursor: pointer;
        padding: 0 2px; border-radius: 2px; line-height: 1;
    }
    .input-tab .tab-close:hover { background: #fee2e2; color: #dc2626; }
    .input-tab-add {
        padding: 4px 10px; font-size: 1rem; cursor: pointer; border: none;
        background: transparent; color: var(--text-muted); line-height: 1;
    }
    .input-tab-add:hover { color: #2563eb; background: #e0f2fe; }
    .tab-name-input {
        font-size: 0.75rem; padding: 2px 4px; border: 1px solid #2563eb;
        border-radius: 2px; width: 80px; background: var(--panel-bg);
    }
    .novel-title-input {
        font-size: 0.8rem; padding: 2px 4px; border: 1px solid #2563eb;
        border-radius: 2px; width: 160px; background: var(--panel-bg);
    }
    .pane-close-btn {
        background: transparent; border: none; color: var(--text-muted); cursor: pointer;
        font-size: 1rem; padding: 0 4px; line-height: 1;
    }
    .pane-close-btn:hover { color: #dc2626; }
    .pane-actions { display: inline-flex; align-items: center; gap: 4px; }
    .pane-layout-btn {
        background: #e0f2fe; border: 1px solid #bae6fd; color: #0c4a6e;
        cursor: pointer; font-size: 0.65rem; padding: 2px 6px; border-radius: 4px;
    }
    .pane-layout-btn:hover { background: #bae6fd; }
    .pane-subheader {
        background: #f0f9ff; color: #0369a1; font-size: 0.75rem; padding: 2px 10px;
        border-bottom: 1px solid #e0f2fe; text-align: right; font-family: monospace; flex-shrink: 0;
    }
    body.theme-dark .pane-subheader { background: #1e3a5f; color: #93c5fd; border-color: #1e40af; }
    .pane-body { flex: 1; overflow: hidden; position: relative; min-height: 0; }
    #pane-preview .pane-body { background-color: var(--preview-bg-color); }
    .pane-footer {
        padding: 0 8px; font-size: 0.7rem; color: var(--text-muted);
        text-align: right; border-top: 1px solid var(--border-color); background: var(--panel-bg);
        display: flex; justify-content: flex-end; align-items: center; gap: 10px; min-height: 24px;
        flex-wrap: wrap; flex-shrink: 0; row-gap: 4px;
    }
    .net-count { font-weight: bold; color: var(--text-color); background: var(--pane-header-bg); padding: 0 4px; border-radius: 3px; }
    .timestamp { font-family: monospace; color: #059669; }
    .goal-display { font-weight: bold; }
    .goal-0-24 { color: #1f2937; } .goal-25-49 { color: #16a34a; } .goal-50-74 { color: #2563eb; }
    .goal-75-99 { color: #ec4899; } .goal-100 { color: #06b6d4; }
    body.theme-dark .goal-0-24 { color: #f3f4f6; }
    .today-goal { font-weight: bold; color: #f97316; }
    .today-goal.achieved { color: #10b981; }
    .writing-time { color: #8b5cf6; font-weight: bold; }

    .selection-overlay {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        background: rgba(37, 99, 235, 0.9); color: white; padding: 6px 16px;
        border-radius: 20px; font-size: 0.85rem; font-weight: bold; z-index: 50;
        pointer-events: none; display: none; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        width: max-content; text-align: center;
    }
    .selection-overlay.show { display: block; }

    /* Quick Insert Popup */
    .quick-insert-popup {
        position: fixed; display: none; z-index: 1000;
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 4px; gap: 2px;
    }
    .quick-insert-popup.show { display: flex; }
    .quick-insert-popup button {
        padding: 6px 12px; border: none; background: transparent;
        cursor: pointer; font-size: 0.8rem; border-radius: 4px;
        color: var(--text-color); white-space: nowrap;
    }
    .quick-insert-popup button:hover { background: #e0f2fe; }
    .quick-insert-popup .qip-ruby { color: #dc2626; }
    .quick-insert-popup .qip-bouten { color: #7c3aed; }

    textarea {
        width: 100%; height: 100%; border: none; outline: none; resize: none;
        padding: 20px; background: transparent; font-family: inherit; line-height: inherit; font-size: inherit;
        white-space: pre-wrap; word-wrap: break-word; z-index: 2; position: relative; color: var(--text-color);
        overflow: auto; box-sizing: border-box;
    }
    textarea::selection { background-color: #bae6fd; color: #000; }
    .vertical-mode textarea { overflow-x: auto; overflow-y: hidden; }
    #input-mirror-container {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        visibility: hidden; pointer-events: none;
        white-space: pre-wrap; word-wrap: break-word; overflow: hidden; padding: 20px; box-sizing: border-box;
    }
    .vertical-mode textarea, .vertical-mode #input-mirror-container { writing-mode: vertical-rl; text-orientation: upright; }

    #preview-scroll { width: 100%; height: 100%; padding: 20px; scroll-behavior: smooth; overflow-x: auto; overflow-y: auto; box-sizing: border-box; min-width: 0; position: relative; }
    #preview-scroll.vertical-mode { overflow-x: auto !important; overflow-y: hidden !important; height: 100%; width: 100%; max-width: 100%; }
    #preview-scroll.vertical-mode #preview-content { writing-mode: vertical-rl; text-orientation: upright; min-height: 100%; width: max-content; max-width: none; }
    #preview-content { word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; color: var(--text-color); max-width: 100%; min-width: 0; box-sizing: border-box; }
    body.scroll-mode #preview-scroll { height: 100%; overflow-y: auto; }
    body.scroll-mode #preview-scroll.vertical-mode { overflow-x: auto !important; }
    #pane-preview .pane-body { overflow: auto; }

    /* Preview Tabs */
    .preview-tabs-container {
        display: flex; align-items: center;
        overflow-x: auto;
        flex: 1 1 auto;
        min-height: 32px;
        min-width: 0;
        background: transparent;
    }
    .preview-tabs-container::-webkit-scrollbar { height: 3px; }
    .preview-tabs-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
    .preview-tab {
        padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border: none;
        background: transparent; color: var(--text-muted); white-space: nowrap;
        border-right: 1px solid var(--border-color); transition: all 0.2s;
    }
    .preview-tab:hover { background: var(--panel-bg); }
    .preview-tab.active { background: var(--panel-bg); color: var(--text-color); font-weight: bold; border-bottom: 2px solid #16a34a; }
    #pane-preview .pane-title h2 { color: var(--text-color); font-weight: 700; }
    #pane-preview .preview-tab { color: var(--text-color); }
    #pane-preview .preview-tab:not(.active) { opacity: 0.75; }

    ruby { ruby-align: space-between; ruby-position: over; }
    rt { color: #555; user-select: none; font-size: 0.5em; }
    body.theme-dark rt { color: #aaa; }
    .bouten-ruby rt { font-size: 0.8em; font-weight: bold; color: #333; transform: translateY(10%); }
    body.theme-dark .bouten-ruby rt { color: #eee; }
    .space-zen, .space-han { display: inline-block; font-family: monospace; color: var(--col-mute-tx); background-color: var(--col-mute-bg); }
    .space-han { min-width: 0.3em; text-align: center; }
    .highlight-active .space-zen { background-color: var(--col-zen-bg); color: var(--col-zen-tx); }
    .highlight-active .space-han { background-color: var(--col-han-bg); color: var(--col-han-tx); }
    .symbol-hl { background-color: var(--col-sym-bg); color: var(--col-sym-tx); font-weight: bold; }
    .bracket-blue { color: #2563eb; font-weight: bold; }
    .bracket-green { color: #059669; font-weight: bold; }
    .underline-text { text-decoration: underline; text-decoration-color: #dc2626; text-underline-offset: 2px; }
    .highlight-text { background: linear-gradient(transparent 60%, #fef08a 60%); }
    body.theme-dark .highlight-text { background: linear-gradient(transparent 60%, #854d0e 60%); }

    /* Memo Panel */
    #memo-panel {
        position: fixed; top: var(--dock-top); left: 0; bottom: 0; width: 300px;
        background: #fefce8; border-right: 1px solid #fcd34d;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(-100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    body.theme-dark #memo-panel { background: #422006; border-color: #854d0e; }
    #memo-panel.open { transform: translateX(0); }
    /* memo: 右側（未ドック時） */
    .main-container.memo-right:not(.memo-docked) #memo-panel{ left:auto; right:0; border-right:none; border-left: 1px solid #fcd34d; box-shadow: -2px 0 5px rgba(0,0,0,0.1); transform: translateX(100%); }
    .main-container.memo-right:not(.memo-docked) #memo-panel.open{ transform: translateX(0); }

    .main-container.memo-docked #memo-panel {
        position: relative; top: auto; left: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 300px;
        border-right: 1px solid #fcd34d; border-left: none;
        order: -10; /* デフォルトで左側 */
    }
    .main-container.memo-docked #memo-panel.open { display: flex; }
    .main-container.memo-docked.memo-right #memo-panel { order: 10; border-right: none; border-left: 1px solid #fcd34d; }
    /* ---- Docked panels: honor per-panel side (structure/character/world) ---- */
    .main-container.structure-docked.structure-right #structure-panel {
        order: 6;
        border-right: none; border-left: 1px solid #a5b4fc;
    }
    .main-container.world-docked.world-right #world-panel {
        order: 7;
        border-right: none; border-left: 1px solid #6ee7b7;
    }
    .main-container.character-docked.character-right #character-panel {
        order: 5;
        border-right: none; border-left: 1px solid #f9a8d4;
    }

    .main-container.memo-docked #memo-panel.open ~ #resizer-memo { display: flex; }
    .main-container.memo-docked.memo-right #resizer-memo { order: 9; }
    .main-container.memo-docked:not(.memo-right) #resizer-memo { order: -9; }
    .memo-header {
        padding: 8px 10px; background: #fef3c7; border-bottom: 1px solid #fcd34d;
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
    }
    body.theme-dark .memo-header { background: #713f12; border-color: #854d0e; }
    .memo-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .memo-controls label { display: inline-flex; align-items: center; gap: 4px; }
    .memo-toolbar {
        display: flex; justify-content: space-between; align-items: center;
        padding: 4px 8px; background: #fef3c7; border-bottom: 1px solid #fcd34d;
        gap: 4px;
        overflow: hidden;
    }
    body.theme-dark .memo-toolbar { background: #713f12; border-color: #854d0e; }
    body.theme-dark .memo-tab { background: #a16207; border-color: #d97706; color: #fef3c7; }
    body.theme-dark .memo-tab.active { background: #1f2937; border-bottom-color: #1f2937; }
    body.theme-dark .memo-tab-add { border-color: #f59e0b; color: #fbbf24; }
    .memo-tabs {
        display: flex; gap: 4px; flex: 1; overflow-x: auto;
        align-items: flex-end; padding: 2px 2px 0; min-height: 24px; min-width: 0;
    }
    .memo-tabs::-webkit-scrollbar { height: 3px; }
    .memo-tabs::-webkit-scrollbar-thumb { background: #fcd34d; border-radius: 3px; }
    .memo-tab {
        padding: 2px 8px; font-size: 0.75rem; background: #fff3b3; border: 1px solid #f59e0b;
        border-radius: 4px 4px 0 0; cursor: pointer; white-space: nowrap;
        display: inline-flex; align-items: center; gap: 4px;
    }
    .memo-tab.active { background: #ffffff; border-bottom-color: #ffffff; }
    .memo-tab-add { background: transparent; border: 1px dashed #f59e0b; color: #92400e; }
    .memo-tab .tab-close {
        margin-left: 2px; padding: 0 4px; border-radius: 4px; font-size: 0.65rem;
    }
    .memo-tab .tab-close:hover { background: #fee2e2; color: #dc2626; }
    .memo-tab.dragging, .input-tab.dragging { opacity: 0.5; }
    .memo-file-btns { display: flex; gap: 2px; }
    #memo-area {
        flex: 1; width: 100%; padding: 12px; border: none; resize: none;
        font-size: 0.9rem; line-height: 1.6; background: transparent;
        font-family: inherit; color: var(--text-color); box-sizing: border-box;
    }
    #memo-area:focus { outline: none; }
    .memo-footer {
        padding: 4px 10px; background: #fef3c7; border-top: 1px solid #fcd34d;
        text-align: right;
    }
    body.theme-dark .memo-footer { background: #713f12; border-color: #854d0e; }
    body.focus-mode #memo-panel { display: none !important; }
    body.focus-mode #search-panel { display: none !important; }

    #search-panel {
        position: fixed; top: var(--dock-top); right: 0; bottom: 0; width: 320px;
        background: var(--panel-bg); border-left: 1px solid var(--border-color);
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    #search-panel.open { transform: translateX(0); display: flex !important; }
    .main-container.search-docked #search-panel {
        position: relative; top: auto; right: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 320px;
        border-left: 1px solid var(--border-color); border-right: none;
        order: 8;
    }
    .main-container.search-docked #search-panel.open { display: flex; }
    .main-container.search-docked.search-left #search-panel { order: -8; border-left: none; border-right: 1px solid var(--border-color); }
    .main-container.search-docked #search-panel.open ~ #resizer-search { display: flex; }
    .main-container.search-docked.search-left #resizer-search { order: -7; }
    .main-container.search-docked:not(.search-left) #resizer-search { order: 7; }

    #outline-panel {
        position: fixed; top: var(--dock-top); right: 0; bottom: 0; width: 300px;
        background: var(--panel-bg); border-left: 1px solid var(--border-color);
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    #outline-panel.open { transform: translateX(0); }
    /* outline: 左側（未ドック時） */
    .main-container.outline-left:not(.outline-docked) #outline-panel{ right:auto; left:0; border-left:none; border-right: 1px solid var(--border-color); box-shadow: 2px 0 5px rgba(0,0,0,0.1); transform: translateX(-100%); }
    .main-container.outline-left:not(.outline-docked) #outline-panel.open{ transform: translateX(0); }

    .main-container.outline-docked #outline-panel {
        position: relative; top: auto; right: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 300px;
        border-left: 1px solid var(--border-color); border-right: none;
        order: 10; /* デフォルトで右側 */
    }
    .main-container.outline-docked #outline-panel.open { display: flex; }
    .main-container.outline-docked.outline-left #outline-panel { order: -10; border-left: none; border-right: 1px solid var(--border-color); }
    .main-container.outline-docked #outline-panel.open + #resizer-outline { display: flex; }
    .main-container.outline-docked.outline-left #resizer-outline { order: -9; }
    .main-container.outline-docked:not(.outline-left) #resizer-outline { order: 9; }

    .outline-header {
        padding: 8px 10px; background: var(--pane-header-bg); border-bottom: 1px solid var(--border-color);
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
        font-size: 0.85rem; flex-wrap: wrap; gap: 4px;
    }
    .outline-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .outline-controls label { display: inline-flex; align-items: center; gap: 4px; }
    .panel-swap-btn {
        display: inline-flex; align-items: center; justify-content: center;
        padding: 2px 6px; font-size: 0.7rem; min-width: 60px;
        opacity: 1; pointer-events: auto; visibility: visible;
    }
    .panel-swap-btn.is-active { opacity: 1; pointer-events: auto; visibility: visible; }
    .expand-level-badge{
        display:inline-flex; align-items:center; justify-content:center;
        width:18px; height:18px; border-radius:6px;
        border:1px solid var(--border-color);
        font-size:0.75rem; line-height:1;
        background: rgba(255,255,255,0.7);
        user-select:none;
    }
    body.theme-dark .expand-level-badge{ background: rgba(0,0,0,0.25); }
    
    .dock-pin-checkbox { display: none; }
    .main-container.dock-split-right #resizer-memo-outline,
    .main-container.dock-split-left #resizer-memo-outline { display: flex; }
    .main-container.dock-split-right #memo-panel { order: 10; }
    .main-container.dock-split-right #resizer-memo-outline { order: 11; }
    .main-container.dock-split-right #outline-panel { order: 12; }
    .main-container.dock-split-left #memo-panel { order: -12; }
    .main-container.dock-split-left #resizer-memo-outline { order: -11; }
    .main-container.dock-split-left #outline-panel { order: -10; }
    .outline-tabs { display: flex; border-bottom: 1px solid var(--border-color); }
    .outline-tab {
        flex: 1; padding: 8px; text-align: center; cursor: pointer;
        background: var(--pane-header-bg); border: none; font-size: 0.8rem;
        color: var(--text-muted); transition: all 0.2s;
    }
    .outline-tab:hover { background: var(--panel-bg); }
    .outline-tab.active { background: var(--panel-bg); color: var(--text-color); font-weight: bold; border-bottom: 2px solid #2563eb; }
    .outline-content { flex: 1; overflow: auto; padding: 10px; }
    .outline-tab-content { display: none; }
    .outline-tab-content.active { display: block; }
    .outline-item {
        padding: 6px 8px; border-bottom: 1px solid var(--border-color); cursor: pointer;
        color: var(--text-color); font-size: 0.85rem; display: flex; align-items: center;
        white-space: nowrap; min-width: 0; width: 100%;
    }
    .outline-item:hover { background: #e0f2fe; color: #0284c7; }
    body.theme-dark .outline-item:hover { background: #1e3a5f; }
    .outline-level-1 { font-weight: bold; background: var(--pane-header-bg); border-left: 4px solid #6b7280; }
    .outline-level-2 { padding-left: 20px; border-left: 3px solid #9ca3af; }
    .outline-level-3 { padding-left: 35px; border-left: 2px solid #d1d5db; font-size: 0.8rem; }
    .outline-toggle { cursor: pointer; margin-right: 6px; font-size: 0.7rem; width: 14px; text-align: center; color: var(--text-muted); flex-shrink: 0; }
    .outline-toggle:hover { color: #2563eb; }
    .outline-text { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .outline-tab-label { font-size: 0.7rem; color: var(--text-muted); margin-right: 6px; }
    .outline-char-count { margin-left: auto; font-size: 0.7rem; color: var(--text-muted); background: var(--pane-header-bg); padding: 1px 6px; border-radius: 10px; flex-shrink: 0; }
    .outline-empty { color: var(--text-muted); font-style: italic; }
    .outline-hidden { display: none !important; }
    .outline-summary { padding: 8px 10px; background: #f0f9ff; border-top: 1px solid var(--border-color); font-size: 0.75rem; color: #0369a1; }
    body.theme-dark .outline-summary { background: #1e3a5f; color: #93c5fd; }

    .bookmark-item { padding: 8px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.85rem; min-width: 0; width: 100%; }
    .bookmark-item:hover { background: #fef3c7; }
    .bookmark-text { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .panel-state-icon { font-size: 0.75rem; opacity: 0.7; margin-left: 4px; }
    
    /* Panel toggle state (open/front) */
    .btn.panel-toggle.is-open { filter: brightness(1.08); }
    .btn.panel-toggle.is-front { outline: 2px solid rgba(99,102,241,0.55); outline-offset: 1px; }
    .btn.panel-toggle.is-pinned { filter: brightness(1.12); }
.bookmark-delete { color: #dc2626; cursor: pointer; font-size: 0.8rem; }
    .bookmark-delete:hover { color: #b91c1c; }
    .bookmark-add-btn { width: 100%; padding: 8px; background: #fef3c7; border: 1px dashed #fcd34d; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-bottom: 10px; }
    .bookmark-add-btn:hover { background: #fde68a; }
    #bookmark-list { overflow-x: auto; }

    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 1000;
        display: none; justify-content: center; align-items: center;
    }
    .modal-overlay.show { display: flex; }
    .modal-content {
        background: var(--panel-bg); border-radius: 8px; padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 600px; width: 90%;
        max-height: 80vh; overflow-y: auto; color: var(--text-color);
    }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .modal-header h3 { margin: 0; font-size: 1.2rem; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted); }
    .modal-close:hover { color: #dc2626; }
    .analysis-section { margin-bottom: 20px; padding: 15px; background: var(--pane-header-bg); border-radius: 6px; }
    .analysis-section h4 { margin: 0 0 10px 0; font-size: 0.95rem; color: #2563eb; }
    .analysis-row { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px dotted var(--border-color); }
    .analysis-row:last-child { border-bottom: none; }
    .analysis-bar { height: 20px; background: #e5e7eb; border-radius: 10px; overflow: hidden; margin: 5px 0; }
    .analysis-bar-fill { height: 100%; border-radius: 10px; transition: width 0.3s; }
    .freq-list { display: flex; flex-wrap: wrap; gap: 8px; }
    .freq-item { background: #dbeafe; color: #1d4ed8; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; }
    .warning-text { color: #dc2626; font-size: 0.85rem; margin-top: 8px; }

    /* Heatmap styles */
    .heatmap-container { margin: 10px 0; }
    .heatmap-title { font-size: 0.85rem; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
    .heatmap-legend { font-size: 0.7rem; color: #666; }
    .heatmap-grid { display: flex; flex-wrap: wrap; gap: 2px; }
    .heatmap-cell { width: 20px; height: 20px; border-radius: 3px; cursor: pointer; position: relative; transition: transform 0.1s; }
    .heatmap-cell:hover { transform: scale(1.3); z-index: 10; }
    .heatmap-cell[data-tooltip]:hover::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #333; color: #fff; padding: 3px 6px; border-radius: 3px; font-size: 0.7rem; white-space: nowrap; z-index: 100; }
    .heatmap-tabs { display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap; }
    .heatmap-tab { padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; font-size: 0.8rem; background: var(--bg-color); }
    .heatmap-tab.active { background: #3b82f6; color: #fff; border-color: #3b82f6; }

    .jump-dialog {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 1001; display: none;
    }
    .jump-dialog.show { display: block; }
    .jump-dialog h4 { margin: 0 0 15px 0; }
    .jump-dialog input { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1rem; margin-bottom: 10px; }
    .jump-dialog-buttons { display: flex; gap: 10px; justify-content: flex-end; }

    /* Celebration Fireworks */
    .celebration-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 9998; overflow: hidden;
    }
    .celebration-message {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white; padding: 20px 40px; border-radius: 16px;
        font-size: 1.5rem; font-weight: bold; text-align: center;
        box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5);
        z-index: 9999; animation: celebrationPop 0.5s ease-out;
        display: none;
    }
    .celebration-message.show { display: block; }
    .celebration-message .emoji { font-size: 2rem; display: block; margin-bottom: 10px; }
    .celebration-message .sub { font-size: 0.9rem; font-weight: normal; margin-top: 8px; opacity: 0.9; }
    @keyframes celebrationPop {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .firework {
        position: absolute; width: 6px; height: 6px; border-radius: 50%;
        animation: fireworkBurst 1.5s ease-out forwards;
    }
    @keyframes fireworkBurst {
        0% { transform: translate(0, 0) scale(1); opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
    .firework-trail {
        position: absolute; width: 4px; height: 4px; border-radius: 50%;
        animation: fireworkTrail 0.8s ease-out forwards;
    }
    @keyframes fireworkTrail {
        0% { transform: translateY(0); opacity: 1; }
        100% { transform: translateY(var(--rise)); opacity: 0; }
    }

    .save-dialog-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 1000;
        display: flex; justify-content: center; align-items: center;
    }
    .import-dialog-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 10001;
        display: none; justify-content: center; align-items: center;
    }
    .import-dialog {
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 12px;
        padding: 20px;
        min-width: 300px;
        max-width: 400px;
        box-shadow: 0 8px 32px rgba(0,0,0,0.25);
    }
    .import-dialog h3 { margin: 0 0 15px 0; color: var(--text-color); font-size: 1rem; }
    .import-dialog-desc { font-size: 0.85rem; color: var(--text-muted); margin-bottom: 15px; }
    .import-options { display: flex; flex-direction: column; gap: 10px; margin-bottom: 15px; }
    .import-option {
        display: flex; align-items: center; gap: 10px;
        padding: 12px; border: 1px solid var(--border-color);
        border-radius: 8px; cursor: pointer; transition: all 0.15s;
    }
    .import-option:hover { background: var(--pane-header-bg); }
    .import-option.selected { border-color: #3b82f6; background: #eff6ff; }
    body.theme-dark .import-option.selected { background: #1e3a5f; }
    .import-option input { display: none; }
    .import-option-content { flex: 1; display: flex; flex-direction: column; gap: 2px; }
    .import-option-content strong { font-size: 0.9rem; }
    .import-dialog-buttons { display: flex; gap: 10px; justify-content: flex-end; }
    .save-dialog {
        background: var(--panel-bg); border-radius: 8px; padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3); min-width: 300px;
    }
    .save-dialog h3 { margin: 0 0 15px 0; color: var(--text-color); }
    .save-dialog-buttons { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .save-dialog-buttons button { padding: 10px 20px; font-size: 1rem; display: inline-flex; align-items: center; justify-content: center; }

    .autosave-toast {
        position: fixed; top: 16px; right: 16px; z-index: 1200;
        background: #fef9c3; color: #92400e; border: 1px solid #fcd34d;
        padding: 8px 14px; border-radius: 12px; font-weight: bold;
        box-shadow: 0 6px 16px rgba(0,0,0,0.15); display: none;
    }
    .autosave-toast.show { display: block; }
    .autosave-error-overlay {
        position: fixed; inset: 0; background: rgba(0,0,0,0.35);
        display: none; align-items: center; justify-content: center; z-index: 1300;
    }
    .autosave-error-overlay.show { display: flex; }
    .autosave-error {
        background: var(--panel-bg); border: 2px solid #fca5a5;
        padding: 20px 26px; border-radius: 14px; text-align: center;
        font-weight: bold; color: #b91c1c; box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }
    .autosave-error button {
        margin-top: 12px; background: #fee2e2; border: 1px solid #fecaca;
        color: #991b1b; padding: 6px 14px; border-radius: 8px; cursor: pointer;
    }

    

    .btn-view { background: #ecfeff; color: #0e7490; border-color: #a5f3fc; font-weight: bold; }
    .btn-view:hover { background: #cffafe; }

    /* Reader (All Tabs) Fullscreen */
    #reader-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: var(--bg-color);
        z-index: 5000;
        display: none;
        flex-direction: column;
    }
    #reader-overlay.show { display: flex; }
    #reader-header {
        display: flex; align-items: center; justify-content: space-between;
        padding: 10px 12px;
        background: var(--pane-header-bg);
        border-bottom: 1px solid var(--border-color);
        gap: 10px;
    }
    #reader-title { font-weight: bold; font-size: 0.95rem; display:flex; align-items:center; gap:8px; }
    #reader-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    #reader-scroll {
        flex: 1;
        overflow: auto;
        padding: 14px 16px;
        background: var(--preview-bg);
    }
    #reader-scroll.vertical-mode #reader-content {
        writing-mode: vertical-rl;
        text-orientation: upright;
        min-height: 100%;
        width: max-content;
        max-width: none;
    }
    #reader-content {
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
        color: var(--text-color);
        max-width: 100%;
        min-width: 0;
        box-sizing: border-box;
        line-height: 1.85;
        font-size: 16px;
    }
    .reader-section { margin-bottom: 18px; }
    .reader-marker {
        display: inline-block;
        padding: 6px 10px;
        margin: 0 0 10px 0;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: #f0f9ff;
        font-weight: bold;
        color: #0369a1;
    }
    body.theme-dark .reader-marker { background: #0b2a3a; color: #7dd3fc; }
    .reader-hint { font-size: 0.8rem; color: var(--text-muted); }

@media print {
        header, .controls-wrapper, .pane-subheader, .pane-footer, #outline-panel, #pane-input, .selection-overlay { display: none !important; }
        body, body.scroll-mode { height: auto; overflow: visible; background: white; }
        .main-container { padding: 0; display: block; }
        .pane-stack { display: block; }
        .pane { border: none; box-shadow: none; height: auto !important; }
        #pane-preview { display: block !important; }
        #pane-preview .pane-header { display: none; }
        #pane-preview .pane-body { overflow: visible; }
        #preview-scroll { padding: 0; height: auto; overflow: visible; }
        #preview-content { font-size: 10.5pt; line-height: 1.8; }
        .vertical-mode #preview-content { writing-mode: horizontal-tb; }
    }

    .input-tab .tab-meta { font-size: 0.70rem; opacity: .85; margin-left: 6px; white-space: nowrap; }
    .input-tab .tab-meta.positive { opacity: 1; font-weight: 700; }

    .search-hits { margin-top: 8px; max-height: 220px; overflow: auto; border: 1px solid var(--border-color); border-radius: 10px; background: var(--panel-bg); padding: 6px; }
    .search-hit { padding: 6px 8px; border-radius: 8px; cursor: pointer; font-size: 0.85rem; }
    .search-hit:hover { background: rgba(59,130,246,.10); }
    .search-hit code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 0.82rem; }

    /* Context menus are now dynamically created via JavaScript */

    #ruby-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10000; background: rgba(0,0,0,.35); }
    #ruby-modal .ruby-box { width: min(520px, 92vw); background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color);
        border-radius: 14px; box-shadow: 0 12px 26px rgba(0,0,0,.22); padding: 14px; }
    #ruby-modal .ruby-header { display:flex; align-items:center; justify-content: space-between; gap: 8px; margin-bottom: 10px; }
    #ruby-modal .ruby-header h3 { margin: 0; font-size: 1rem; }
    #ruby-modal .ruby-close { width: 32px; height: 32px; border-radius: 10px; border: 1px solid var(--border-color); background: transparent; cursor: pointer; }
    #ruby-modal .ruby-close:hover { background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.35); }
    #ruby-modal .ruby-target { font-size: .9rem; color: var(--text-muted); margin-bottom: 8px; }
    #ruby-modal input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border-color); background: var(--pane-header-bg); color: var(--text-color); }
    #ruby-modal .ruby-actions { display:flex; justify-content:flex-end; gap: 8px; margin-top: 10px; }

    #focus-overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10001; background: rgba(0,0,0,.45); }
    #focus-overlay .focus-box { width: min(980px, 96vw); background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color);
        border-radius: 16px; box-shadow: 0 14px 28px rgba(0,0,0,.25); padding: 14px; }
    #focus-overlay .focus-header { display:flex; align-items:center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
    #focus-overlay .focus-header h3 { margin:0; font-size: 1rem; }
    #focus-overlay .focus-body { max-height: 76vh; overflow: auto; border: 1px solid var(--border-color); border-radius: 12px; background: var(--preview-bg-color); padding: 10px; }


/* ===== v0.98 nav unified tabs (outline/search/memo) ===== */
#outline-tab-memo #memo-panel{ position:static; width:100%; height:100%; max-height:none; transform:none; box-shadow:none; border:none; }
#outline-tab-memo #memo-panel .memo-header{ display:none !important; }
#outline-tab-memo #memo-panel .panel-close-btn{ display:none !important; }
#outline-tab-memo #memo-panel .panel-pin-btn,
#outline-tab-memo #memo-panel .dock-pin-checkbox,
#outline-tab-memo #memo-panel .panel-swap-btn{ display:none !important; }

    /* Nav jump history buttons */
    .nav-jump-controls{display:flex;gap:4px;align-items:center;}
    .nav-jump-btn{height:26px;min-width:26px;padding:0 6px;border:1px solid var(--border-color);background:var(--panel-bg);color:var(--text-color);border-radius:8px;cursor:pointer;font-size:12px;line-height:1;}
    .nav-jump-btn:disabled{opacity:.4;cursor:not-allowed;}

    /* Jump flash */
    @keyframes ccJumpFlash{0%{box-shadow:0 0 0 0 rgba(250,204,21,0);}20%{box-shadow:0 0 0 6px rgba(250,204,21,.65);}100%{box-shadow:0 0 0 0 rgba(250,204,21,0);}}
    .cc-jump-flash{animation:ccJumpFlash .8s ease;}

    /* Sync mode menu */
    #sync-menu{position:fixed;z-index:9999;display:none;min-width:180px;background:var(--panel-bg);border:1px solid var(--border-color);border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.18);overflow:hidden;}
    #sync-menu button{width:100%;text-align:left;padding:10px 12px;border:none;background:transparent;color:var(--text-color);cursor:pointer;font-size:14px;}
    #sync-menu button:hover{background:rgba(59,130,246,.08);}
    #sync-menu .sync-menu-note{padding:8px 12px;font-size:12px;color:var(--text-muted);border-top:1px solid var(--border-color);}

    /* Proof ignore modal */

    /* ===== 構成パネル (Structure Panel) ===== */
    #structure-panel {
        position: fixed; top: var(--dock-top); left: 0; bottom: 0; width: 300px;
        background: var(--pane-structure-bg, #f0f4ff); border-right: 1px solid #a5b4fc;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(-100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    .main-container.structure-right #structure-panel {
        left: auto; right: 0;
        border-right: none; border-left: 1px solid #a5b4fc;
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        transform: translateX(100%);
    }
    .main-container.structure-right #structure-panel.open { transform: translateX(0); }
    /* structure: 右側（未ドック時） */
    .main-container.structure-right:not(.structure-docked) #structure-panel{ left:auto; right:0; border-right:none; border-left: 1px solid #a5b4fc; box-shadow: -2px 0 5px rgba(0,0,0,0.1); transform: translateX(100%); }
    .main-container.structure-right:not(.structure-docked) #structure-panel.open{ transform: translateX(0); }

    body.theme-dark #structure-panel { background: var(--pane-structure-bg, #1e1b4b); border-color: #4338ca; }
    #structure-panel.open { transform: translateX(0); }
    .main-container.structure-docked #structure-panel {
        position: relative; top: auto; left: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 300px;
        border-right: 1px solid #a5b4fc; border-left: none;
        order: -6; /* 左側に配置（メモ-10の右、入力ペイン1の左） */
    }
    .main-container.structure-docked #structure-panel.open { display: flex; }
    .main-container.structure-docked.structure-right #structure-panel { order: 7; border-right: none; border-left: 1px solid #a5b4fc; }
    .main-container.structure-docked #structure-panel.open ~ #resizer-structure { display: flex; }
    .main-container.structure-docked.structure-right #resizer-structure { order: 5; }
    .main-container.structure-docked:not(.structure-right) #resizer-structure { order: -5; }

    body.focus-mode #structure-panel { display: none !important; }

    .structure-header {
        padding: 8px 10px; background: var(--pane-structure-head, #e0e7ff); border-bottom: 1px solid #a5b4fc;
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
        font-size: 0.85rem; flex-wrap: wrap; gap: 4px;
    }
    body.theme-dark .structure-header { background: var(--pane-structure-head, #312e81); border-color: #4338ca; }
    .structure-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }


    /* ===== 用語パネル ===== */
    body.focus-mode #terms-panel { display: none !important; }

    #terms-panel {
        position: fixed; top: var(--dock-top); left: 0; bottom: 0;
        width: 300px; max-width: 45vw;
        background: var(--pane-terms-bg, #fffbeb);
        border-right: 1px solid var(--border-color);
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(-100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    .main-container.terms-right #terms-panel {
        left: auto; right: 0;
        border-right: none; border-left: 1px solid var(--border-color);
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        transform: translateX(100%);
    }
    .main-container.terms-right #terms-panel.open { transform: translateX(0); }
    #terms-panel.open { transform: translateX(0); }

    /* terms: docked */
    .main-container.terms-docked #terms-panel {
        position: relative; top: auto; left: auto; right: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 300px;
        border-right: 1px solid var(--border-color); border-left: none;
        order: -5;
    }
    .main-container.terms-docked #terms-panel.open { display: flex; }
    .main-container.terms-docked.terms-right #terms-panel { order: 8; border-right: none; border-left: 1px solid var(--border-color); }

    .main-container.terms-docked #terms-panel.open + #resizer-terms { display: flex; }
    .main-container.terms-docked.terms-right #resizer-terms { order: 7; }
    .main-container.terms-docked:not(.terms-right) #resizer-terms { order: -4; }

.terms-header{
        padding: 8px 10px;
        background: var(--pane-terms-head, #fff7ed);
        border-bottom: 1px solid #fdba74;
        font-weight: bold;
        display:flex;
        justify-content: space-between;
        align-items:center;
        font-size: 0.85rem;
        flex-wrap: wrap;
        gap: 4px;
    }
    body.theme-dark .terms-header { background: var(--pane-terms-head, #164e63); border-color: #155e75; }
    .terms-controls{ display:flex; align-items:center; gap:6px; flex-wrap: wrap; }

    .terms-toolbar{
        padding: 6px 10px;
        display:flex;
        gap: 8px;
        align-items:center;
        border-bottom: 1px solid var(--border-color);
        background: var(--pane-header-bg);
        flex-wrap: wrap;
    }
    .terms-content{ padding: 10px; overflow:auto; flex:1; }
    .terms-list{ display:flex; flex-direction: column; gap: 10px; }

    /* [v23] Terms pane align with other panes */
    #terms-panel { background: var(--pane-terms-bg, #fffbeb) !important; }
    #terms-panel .terms-header, #terms-panel .terms-toolbar { background: var(--pane-terms-head, var(--pane-header-bg)) !important; }
    .terms-toolbar { border-bottom: 1px solid var(--border-color); }
    .terms-card { border-radius: 8px; }

    .terms-card{
        border: 1px solid var(--border-color);
        border-radius: 10px;
        background: var(--panel-bg);
        padding: 10px;
        box-shadow: var(--shadow-soft, 0 1px 2px rgba(0,0,0,0.06));
    }
    .terms-card-title{ font-weight: 800; font-size: 0.9rem; margin-bottom: 4px; display:flex; justify-content: space-between; gap: 8px; }
    .terms-card-meta{ font-size: 0.75rem; color: var(--text-muted); margin-bottom: 6px; }
    .terms-card-desc{ white-space: pre-wrap; font-size: 0.82rem; line-height: 1.35; }
    /* Terms expand levels (make changes obvious) */
    .terms-card.lv0 .terms-card-meta, .terms-card.lv0 .terms-card-desc, .terms-card.lv0 .terms-linked-section{ display:none !important; }
    .terms-card.lv1 .terms-card-desc, .terms-card.lv1 .terms-linked-section{ display:none !important; }
    .terms-card.lv2 .terms-linked-section{ display:none !important; }
    .terms-card-actions{ margin-top: 8px; display:flex; justify-content:flex-end; gap: 6px; flex-wrap: wrap; }
    .terms-linked-section{ margin-top: 8px; display:flex; flex-wrap: wrap; gap: 6px; }
    .terms-linked-item{
        display:inline-flex; align-items:center; gap:4px;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border-color);
        background: var(--pane-header-bg);
        font-size: 0.72rem;
        max-width: 100%;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        cursor: pointer;
    }
    .terms-linked-item:hover{ filter: brightness(0.98); }

    /* edit modal */
    .terms-edit-modal{
        position: fixed; inset: 0;
        background: rgba(0,0,0,0.55);
        z-index: 10050;
        display:none; justify-content:center; align-items:center;
    }
    .terms-edit-box{
        width: min(720px, 92vw);
        max-height: 85vh;
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 14px;
        overflow:auto;
        box-shadow: 0 10px 30px rgba(0,0,0,0.25);
    }
    .terms-edit-header{
        padding: 12px 14px;
        display:flex; justify-content: space-between; align-items:center;
        border-bottom: 1px solid var(--border-color);
        background: var(--pane-header-bg);
    }
    .terms-edit-header h3{ margin:0; font-size: 1rem; }
    .terms-edit-close{ border: none; background: transparent; cursor:pointer; font-size: 1.1rem; color: var(--text-color); }
    .terms-edit-field{ padding: 12px 14px; }
    .terms-edit-field label{ display:block; font-size: 0.75rem; font-weight:bold; margin-bottom: 6px; color: var(--text-muted); }
    .terms-edit-field input, .terms-edit-field textarea{
        width: 100%;
        border: 1px solid var(--border-color);
        border-radius: 10px;
        background: var(--panel-bg);
        color: var(--text-color);
        padding: 10px;
        font-size: 0.85rem;
    }
    .terms-edit-field textarea{ resize: vertical; }
    .terms-edit-hint{ font-size: 0.7rem; color: var(--text-muted); }
    .terms-edit-actions{ padding: 12px 14px; display:flex; justify-content:flex-end; gap: 8px; border-top: 1px solid var(--border-color); background: var(--pane-header-bg); }

    .structure-toolbar {
        display: flex; gap: 4px; flex-wrap: wrap; padding: 8px 10px;
        border-bottom: 1px solid var(--border-color);
        background: var(--pane-structure-head, #e0e7ff);
    }
    body.theme-dark .structure-toolbar { background: var(--pane-structure-head, #312e81); }
    .structure-toolbar .btn { padding: 2px 6px; font-size: 0.7rem; }

    .structure-content {
        flex: 1; overflow: auto; padding: 10px;
    }

    .structure-list {
        overflow: visible;
    }

    /* 構成カード */
    .structure-card {
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; margin-bottom: 6px; cursor: grab;
        transition: box-shadow 0.2s, transform 0.15s;
        position: relative;
    }
    .structure-card.has-custom-color {
        background: var(--structure-card-bg, var(--panel-bg));
    }
    .structure-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .structure-card.dragging { opacity: 0.5; transform: scale(0.98); }
    .structure-card.drag-over { border-color: #3b82f6; box-shadow: 0 0 0 2px rgba(59,130,246,0.3); }

    /* 階層レベル別スタイル */
    .structure-card.level-chapter {
        border-left: 4px solid #6366f1;
        background: linear-gradient(to right, rgba(99,102,241,0.05), transparent);
    }
    .structure-card.has-custom-color.level-chapter {
        border-left-color: var(--structure-card-accent, #6366f1);
        background: var(--structure-card-bg, var(--panel-bg));
    }
    .structure-card.level-episode {
        margin-left: 16px;
        border-left: 3px solid #8b5cf6;
        background: linear-gradient(to right, rgba(139,92,246,0.03), transparent);
    }
    .structure-card.has-custom-color.level-episode {
        border-left-color: var(--structure-card-accent, #8b5cf6);
        background: var(--structure-card-bg, var(--panel-bg));
    }
    .structure-card.level-scene {
        margin-left: 32px;
        border-left: 2px solid #a78bfa;
        font-size: 0.9em;
    }
    .structure-card.has-custom-color.level-scene {
        border-left-color: var(--structure-card-accent, #a78bfa);
    }

    .structure-card-header {
        display: flex; align-items: center; gap: 6px;
        padding: 8px 10px; cursor: pointer;
        border-bottom: 1px solid transparent;
    }
    .structure-card-header button { cursor: pointer; }
    .structure-select {
        width: 14px; height: 14px; accent-color: #6366f1;
        cursor: pointer; flex-shrink: 0;
    }
    .structure-move-group { display: flex; gap: 2px; align-items: center; }
    .structure-move-btn {
        border: 1px solid var(--border-color);
        background: var(--panel-bg);
        border-radius: 4px;
        font-size: 0.65rem;
        padding: 1px 4px;
        color: var(--text-muted);
    }
    .structure-move-btn:hover { background: var(--pane-header-bg); color: var(--text-color); }
    .structure-card.expanded .structure-card-header {
        border-bottom-color: var(--border-color);
    }

    .structure-toggle {
        font-size: 0.7rem; color: var(--text-muted); width: 14px;
        cursor: pointer; flex-shrink: 0;
    }
    .structure-toggle:hover { color: #3b82f6; }


    /* 構成: 展開レベル表示（他パネルと同じ位置/サイズ感に揃える） */
    .structure-expand-toggle {
        font-size: 0.7rem;
        color: var(--text-muted);
        width: 14px;
        cursor: pointer;
        flex-shrink: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
    }
    .structure-expand-toggle:hover { color: #3b82f6; }

    /* パネルの「新規作成レベル/役割」プルダウンは非表示（新しいカードボタンのみ残す） */
    .structure-toolbar select,
    .character-toolbar select,
    .world-toolbar select {
        display: none !important;
    }


    .structure-title {
        flex: 1; font-weight: 600; color: var(--text-color);
        white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        font-size: 0.85rem;
    }
    .structure-card.level-chapter .structure-title { font-size: 0.9rem; }

    .structure-status {
        font-size: 0.65rem; padding: 2px 6px; border-radius: 10px;
        white-space: nowrap; flex-shrink: 0;
    }
    .structure-status.status-none { background: #f3f4f6; color: #6b7280; }
    .structure-status.status-draft { background: #fef3c7; color: #92400e; }
    .structure-status.status-revise { background: #dbeafe; color: #1d4ed8; }
    .structure-status.status-done { background: #dcfce7; color: #166534; }
    body.theme-dark .structure-status.status-none { background: #374151; color: #9ca3af; }
    body.theme-dark .structure-status.status-draft { background: #78350f; color: #fcd34d; }
    body.theme-dark .structure-status.status-revise { background: #1e3a8a; color: #93c5fd; }
    body.theme-dark .structure-status.status-done { background: #14532d; color: #86efac; }

    .structure-card-body {
        display: none; padding: 8px 10px; font-size: 0.8rem;
            overflow-x: hidden;
    }
.structure-card.expanded .structure-card-body { display: block; }

    .structure-field { margin-bottom: 6px; }
    .structure-field:last-child { margin-bottom: 0; }
    .structure-field-label {
        font-size: 0.7rem; color: var(--text-muted); margin-bottom: 2px;
    }
    .structure-field-value {
        color: var(--text-color); line-height: 1.4;
    }

    .structure-summary {
        color: var(--text-muted); font-size: 0.8rem;
        display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
        overflow: hidden;
    }
    .structure-card.fully-expanded .structure-summary {
        display: block; -webkit-line-clamp: unset; overflow: visible;
    }

    .structure-summary-preview {
        padding: 4px 10px 6px 28px;
        font-size: 0.75rem;
        color: var(--text-muted);
        background: rgba(0,0,0,0.02);
        border-top: 1px dashed var(--border-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    body.theme-dark .structure-summary-preview {
        background: rgba(255,255,255,0.02);
    }

    .structure-tags {
        display: flex; flex-wrap: wrap; gap: 4px;
    }
    .structure-tag {
        background: #e0f2fe; color: #0369a1; padding: 1px 6px;
        border-radius: 10px; font-size: 0.7rem;
    }
    body.theme-dark .structure-tag { background: #0c4a6e; color: #7dd3fc; }

    .structure-viewpoint {
        display: inline-block; background: #fce7f3; color: #be185d;
        padding: 1px 6px; border-radius: 10px; font-size: 0.7rem;
    }
    body.theme-dark .structure-viewpoint { background: #831843; color: #f9a8d4; }

    .structure-card-actions {
        display: flex; gap: 4px; margin-top: 8px; padding-top: 8px;
        border-top: 1px dashed var(--border-color);
    }
    .structure-card-actions button {
        padding: 3px 8px; font-size: 0.7rem; border-radius: 4px;
        border: 1px solid var(--border-color); background: var(--panel-bg);
        color: var(--text-color); cursor: pointer;
    }
    .structure-card-actions button:hover { background: var(--pane-header-bg); }
    .structure-card-actions .btn-delete { color: #dc2626; }
    .structure-card-actions .btn-delete:hover { background: #fee2e2; }

    /* 折りたたまれた子要素 */
    .structure-card.collapsed .structure-children { display: none; }
    .structure-children { margin-top: 6px; }

    /* リンクされた登場人物・世界観の表示 */
    .structure-linked-section {
        margin-top: 6px;
        padding-top: 6px;
        border-top: 1px dashed var(--border-color);
    }
    .structure-linked-label {
        font-size: 0.65rem;
        color: var(--text-muted);
        margin-bottom: 4px;
    }
    .structure-linked-items {
        display: flex;
        flex-wrap: wrap;
        gap: 4px;
        min-width: 0;
        width: 100%;
        max-width: 100%;
        overflow: hidden;
    }
    .structure-linked-item {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.7rem;
        cursor: pointer;
        transition: all 0.15s;
        white-space: nowrap;
        max-width: 100%;
        min-width: 0;
        overflow: hidden;
        box-sizing: border-box;
        flex: 0 1 auto;
    }
    
    .structure-linked-icon { flex: 0 0 auto; }
    .structure-linked-text {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1 1 auto;
    }
.structure-linked-item:hover {
        transform: scale(1.05);
        box-shadow: 0 1px 4px rgba(0,0,0,0.15);
    }
    .structure-linked-character {
        background: #fce7f3;
        color: #be185d;
        border: 1px solid #fbcfe8;
    }
    body.theme-dark .structure-linked-character {
        background: #831843;
        color: #f9a8d4;
        border-color: #9d174d;
    }
    .structure-linked-world {
        background: #ecfdf5;
        color: #047857;
        border: 1px solid #a7f3d0;
    }
    body.theme-dark .structure-linked-world {
        background: #064e3b;
        color: #6ee7b7;
        border-color: #047857;
    }

    .card-linked-section {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px dashed var(--border-color);
        font-size: 0.75rem;
    }
    .card-linked-label {
        font-weight: 600;
        color: var(--text-muted);
        margin-bottom: 4px;
    }
    .card-linked-items {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        min-width: 0;
        width: 100%;
        max-width: 100%;
        overflow: hidden;
    }
    .card-linked-item {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 2px 8px;
        border-radius: 999px;
        font-size: 0.7rem;
        border: 1px solid var(--border-color);
        background: var(--panel-bg);
        cursor: pointer;
        white-space: nowrap;
        transition: all 0.15s;
        max-width: 100%;
        min-width: 0;
        overflow: hidden;
        box-sizing: border-box;
        flex: 0 1 auto;
    }
    .card-linked-item:hover {
        background: #e0f2fe;
        border-color: #7dd3fc;
        color: #0369a1;
    }
    .card-linked-badge {
        font-size: 0.6rem;
        padding: 1px 4px;
        border-radius: 6px;
        background: rgba(0,0,0,0.06);
        color: var(--text-muted);
    }
    
    .card-linked-icon {
        flex: 0 0 auto;
    }
    .card-linked-text {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1 1 auto;
    }
    .card-linked-badge {
        flex: 0 0 auto;
    }
.card-linked-character {
        background: #fce7f3;
        color: #be185d;
        border-color: #f9a8d4;
    }
    .card-linked-world {
        background: #d1fae5;
        color: #065f46;
        border-color: #6ee7b7;
    }
    .card-linked-term{ background: rgba(56,189,248,0.18); border-color: rgba(56,189,248,0.35); }

    .card-linked-structure {
        background: #dbeafe;
        color: #1d4ed8;
        border-color: #93c5fd;
    }
    body.theme-dark .card-linked-character {
        background: #831843;
        color: #f9a8d4;
        border-color: #be185d;
    }
    body.theme-dark .card-linked-world {
        background: #064e3b;
        color: #a7f3d0;
        border-color: #047857;
    }
    body.theme-dark .card-linked-structure {
        background: #1e3a8a;
        color: #bfdbfe;
        border-color: #3b82f6;
    }

    /* リンク情報ポップアップ */
    .structure-link-popup {
        position: fixed;
        z-index: 10003;
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        box-shadow: 0 4px 16px rgba(0,0,0,0.2);
        padding: 12px;
        max-width: 320px;
        min-width: 200px;
    }
    .structure-link-popup-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 8px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--border-color);
    }
    .structure-link-popup-title {
        font-weight: 600;
        font-size: 0.9rem;
    }
    .structure-link-popup-badge {
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 10px;
    }
    .structure-link-popup-badge.character {
        background: #fce7f3;
        color: #be185d;
    }
    .structure-link-popup-badge.world {
        background: #ecfdf5;
        color: #047857;
    }
    .structure-link-popup-desc {
        font-size: 0.8rem;
        color: var(--text-color);
        line-height: 1.5;
        max-height: 150px;
        overflow-y: auto;
    }
    .structure-link-popup-actions {
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px dashed var(--border-color);
        display: flex;
        justify-content: flex-end;
        gap: 6px;
    }
    .structure-link-popup-actions button {
        padding: 4px 10px;
        font-size: 0.75rem;
        border-radius: 4px;
        border: 1px solid var(--border-color);
        background: var(--panel-bg);
        cursor: pointer;
    }
    .structure-link-popup-actions button:hover {
        background: var(--pane-header-bg);
    }
    .structure-link-popup-actions .btn-goto {
        background: #e0f2fe;
        color: #0369a1;
        border-color: #7dd3fc;
    }
    .structure-link-popup-actions .btn-goto:hover {
        background: #bae6fd;
    }

    /* 構成編集モーダル内のリンク選択（タグクリック形式） */
    .structure-link-select-container {
        max-height: 150px;
        overflow-y: auto;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        padding: 6px;
        background: var(--pane-header-bg);
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
    }
    .link-tag-item {
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 10px;
        border-radius: 12px;
        cursor: pointer;
        font-size: 0.8rem;
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        transition: all 0.15s;
        white-space: nowrap;
        max-width: 100%;
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        flex: 0 1 auto;
    }
    .link-tag-text {
        min-width: 0;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        flex: 1 1 auto;
    }
    .link-tag-item:hover {
        background: #e0f2fe;
        border-color: #7dd3fc;
    }
    .link-tag-item.selected {
        background: #dbeafe;
        border-color: #3b82f6;
        color: #1d4ed8;
    }
    .link-tag-item .link-tag-badge {
        flex: 0 0 auto;
        font-size: 0.65rem;
        padding: 1px 4px;
        border-radius: 6px;
        background: rgba(0,0,0,0.08);
    }
    .link-tag-item.selected .link-tag-badge {
        background: rgba(59,130,246,0.2);
    }
    body.theme-dark .link-tag-item:hover {
        background: #1e3a5f;
        border-color: #3b82f6;
    }
    body.theme-dark .link-tag-item.selected {
        background: #1e40af;
        border-color: #60a5fa;
        color: #93c5fd;
    }
    .structure-link-checkbox-item:hover {
        background: rgba(0,0,0,0.05);
    }
    body.theme-dark .structure-link-checkbox-item:hover {
        background: rgba(255,255,255,0.05);
    }
    .structure-link-checkbox-item input {
        width: 16px;
        height: 16px;
        accent-color: #6366f1;
        flex-shrink: 0;
        margin: 0;
    }
    .structure-link-checkbox-item label {
        flex: 1;
        font-size: 0.85rem;
        cursor: pointer;
        margin-bottom: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        min-width: 80px;
    }
    .structure-link-checkbox-item .link-item-badge {
        font-size: 0.65rem;
        padding: 2px 6px;
        border-radius: 8px;
        flex-shrink: 0;
        white-space: nowrap;
    }
    .structure-link-checkbox-item .link-item-badge.role-protagonist {
        background: #fce7f3;
        color: #be185d;
    }
    .structure-link-checkbox-item .link-item-badge.role-heroine {
        background: #fdf2f8;
        color: #db2777;
    }
    .structure-link-checkbox-item .link-item-badge.role-antagonist {
        background: #fce7f3;
        color: #9d174d;
    }
    .structure-link-checkbox-item .link-item-badge.role-supporting {
        background: #dbeafe;
        color: #1d4ed8;
    }
    .structure-link-checkbox-item .link-item-badge.role-mob {
        background: #f3f4f6;
        color: #6b7280;
    }
    .structure-link-checkbox-item .link-item-badge.level-major {
        background: #fef3c7;
        color: #92400e;
    }
    .structure-link-checkbox-item .link-item-badge.level-middle {
        background: #dbeafe;
        color: #1d4ed8;
    }
    .structure-link-checkbox-item .link-item-badge.level-detail {
        background: #f3e8ff;
        color: #7c3aed;
    }

    /* 舞台タグサジェスト */
    .structure-tag-suggestions {
        display: none;
        flex-wrap: wrap;
        gap: 4px;
        margin-top: 6px;
        padding: 8px;
        background: var(--pane-header-bg);
        border: 1px solid var(--border-color);
        border-radius: 6px;
    }
    .structure-tag-suggestions .tag-item {
        display: inline-block;
        padding: 3px 8px;
        border-radius: 12px;
        font-size: 0.75rem;
        cursor: pointer;
        background: #e0f2fe;
        color: #0369a1;
        transition: all 0.15s;
    }
    .structure-tag-suggestions .tag-item:hover {
        background: #7dd3fc;
        color: #0c4a6e;
    }
    .structure-tag-suggestions .no-tags {
        font-size: 0.75rem;
        color: var(--text-muted);
        font-style: italic;
    }
    .structure-suggest-btn {
        display: inline-flex;
        align-items: center;
        gap: 3px;
        padding: 2px 8px;
        font-size: 0.7rem;
        border-radius: 4px;
        border: 1px solid var(--border-color);
        background: var(--panel-bg);
        cursor: pointer;
        margin-left: 8px;
    }
    .structure-suggest-btn:hover {
        background: var(--pane-header-bg);
    }

    /* 編集モーダル */
    #structure-edit-modal {
        position: fixed; inset: 0; display: none; align-items: center; justify-content: center;
        z-index: 10002; background: rgba(0,0,0,0.45);
    }
    #structure-edit-modal.show { display: flex; }
    .structure-edit-box {
        width: min(480px, 92vw); max-height: 85vh; overflow-y: auto;
        background: var(--panel-bg); color: var(--text-color);
        border: 1px solid var(--border-color); border-radius: 12px;
        box-shadow: 0 12px 28px rgba(0,0,0,0.25); padding: 16px;
    }
    .structure-edit-header {
        display: flex; align-items: center; justify-content: space-between;
        margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color);
    }
    .structure-edit-header h3 { margin: 0; font-size: 1rem; }
    .structure-edit-close {
        width: 28px; height: 28px; border-radius: 6px;
        border: 1px solid var(--border-color); background: transparent;
        cursor: pointer; font-size: 1rem; color: var(--text-muted);
    }
    .structure-edit-close:hover { background: #fee2e2; color: #dc2626; }

    .structure-edit-field { margin-bottom: 12px; }
    .structure-edit-field label {
        display: block; font-size: 0.8rem; font-weight: 600;
        margin-bottom: 4px; color: var(--text-color);
    }
    .structure-edit-field input,
    .structure-edit-field textarea,
    .structure-edit-field select {
        width: 100%; padding: 8px 10px; border: 1px solid var(--border-color);
        border-radius: 6px; background: var(--pane-header-bg);
        color: var(--text-color); font-size: 0.85rem;
    }
    .structure-edit-field textarea { min-height: 80px; resize: vertical; }
    .structure-edit-field input:focus,
    .structure-edit-field textarea:focus,
    .structure-edit-field select:focus {
        outline: none; border-color: #3b82f6;
    }
    .structure-edit-hint {
        font-size: 0.7rem; color: var(--text-muted); margin-top: 2px;
    }

    .structure-edit-actions {
        display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px;
    }
    .structure-edit-actions .btn { min-width: 80px; justify-content: center; }

    /* 全画面構成ビュー */
    .structure-fullscreen-btn {
        background: #f3e8ff; color: #7c3aed; border-color: #d8b4fe;
    }
    .structure-fullscreen-btn:hover { background: #ede9fe; }

    body.structure-fullscreen-mode header,
    body.structure-fullscreen-mode .controls-wrapper,
    body.structure-fullscreen-mode .pane-stack,
    body.structure-fullscreen-mode #memo-panel,
    body.structure-fullscreen-mode #search-panel,
    body.structure-fullscreen-mode #outline-panel { display: none !important; }
    body.structure-fullscreen-mode #structure-panel {
        position: fixed !important; inset: 0 !important;
        width: 100% !important; max-width: none !important;
        transform: none !important; z-index: 9999 !important;
        border: none !important; border-radius: 0 !important;
        display: flex !important;
    }
    body.structure-fullscreen-mode .structure-content {
        display: flex; flex-direction: column;
    }
    body.structure-fullscreen-mode .structure-list {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 12px; padding: 12px; flex: 1;
    }
    body.structure-fullscreen-mode .structure-card {
        margin: 0; margin-left: 0 !important;
    }
    body.structure-fullscreen-mode .structure-card.level-episode,
    body.structure-fullscreen-mode .structure-card.level-scene {
        margin-left: 0;
    }

    body.memo-fullscreen-mode header,
    body.memo-fullscreen-mode .controls-wrapper,
    body.memo-fullscreen-mode .pane-stack,
    body.memo-fullscreen-mode #search-panel,
    body.memo-fullscreen-mode #outline-panel,
    body.memo-fullscreen-mode #structure-panel,
    body.memo-fullscreen-mode #character-panel,
    body.memo-fullscreen-mode #world-panel { display: none !important; }
    body.memo-fullscreen-mode #memo-panel {
        position: fixed !important; inset: 0 !important;
        width: 100% !important; max-width: none !important;
        transform: none !important; z-index: 9999 !important;
        border: none !important; border-radius: 0 !important;
        display: flex !important;
    }

    body.character-fullscreen-mode header,
    body.character-fullscreen-mode .controls-wrapper,
    body.character-fullscreen-mode .pane-stack,
    body.character-fullscreen-mode #memo-panel,
    body.character-fullscreen-mode #search-panel,
    body.character-fullscreen-mode #outline-panel,
    body.character-fullscreen-mode #structure-panel,
    body.character-fullscreen-mode #world-panel { display: none !important; }
    body.character-fullscreen-mode #character-panel {
        position: fixed !important; inset: 0 !important;
        width: 100% !important; max-width: none !important;
        transform: none !important; z-index: 9999 !important;
        border: none !important; border-radius: 0 !important;
        display: flex !important;
    }
    body.character-fullscreen-mode .character-content {
        display: flex; flex-direction: column;
    }
    body.character-fullscreen-mode .character-list {
        padding: 12px; flex: 1;
    }

    body.world-fullscreen-mode header,
    body.world-fullscreen-mode .controls-wrapper,
    body.world-fullscreen-mode .pane-stack,
    body.world-fullscreen-mode #memo-panel,
    body.world-fullscreen-mode #search-panel,
    body.world-fullscreen-mode #outline-panel,
    body.world-fullscreen-mode #structure-panel,
    body.world-fullscreen-mode #character-panel { display: none !important; }
    body.world-fullscreen-mode #world-panel {
        position: fixed !important; inset: 0 !important;
        width: 100% !important; max-width: none !important;
        transform: none !important; z-index: 9999 !important;
        border: none !important; border-radius: 0 !important;
        display: flex !important;
    }
    body.world-fullscreen-mode .world-content {
        display: flex; flex-direction: column;
    }
    body.world-fullscreen-mode .world-list {
        padding: 12px; flex: 1;
    }

    /* ========== 登場人物パネル ========== */
    #character-panel {
        position: fixed; top: var(--dock-top, 44px); left: 0; bottom: 0;
        width: 300px; max-width: 45vw;
        background: var(--pane-character-bg, #fdf2f8);
        border-right: 1px solid #f9a8d4;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(-100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    .main-container.character-right #character-panel {
        left: auto; right: 0;
        border-right: none; border-left: 1px solid #f9a8d4;
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        transform: translateX(100%);
    }
    .main-container.character-right #character-panel.open { transform: translateX(0); }
    /* character: 右側（未ドック時） */
    .main-container.character-right:not(.character-docked) #character-panel{ left:auto; right:0; border-right:none; border-left: 1px solid #f9a8d4; box-shadow: -2px 0 5px rgba(0,0,0,0.1); transform: translateX(100%); }
    .main-container.character-right:not(.character-docked) #character-panel.open{ transform: translateX(0); }

    body.theme-dark #character-panel { background: var(--pane-character-bg, #4a044e); border-color: #a21caf; }
    #character-panel.open { transform: translateX(0); }
    .main-container.character-docked #character-panel {
        position: relative; top: auto; left: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 300px;
        border-right: 1px solid #f9a8d4; border-left: none;
        order: -7;
    }
    .main-container.character-docked #character-panel.open { display: flex; }
    .main-container.character-docked.character-right #character-panel { order: 8; border-right: none; border-left: 1px solid #f9a8d4; }
    .main-container.character-docked #character-panel.open ~ #resizer-character { display: flex; }
    .main-container.character-docked.character-right #resizer-character { order: 6; }
    .main-container.character-docked:not(.character-right) #resizer-character { order: -6; }
    body.focus-mode #character-panel { display: none !important; }

    .character-header {
        padding: 8px 10px; background: var(--pane-character-head, #fce7f3); border-bottom: 1px solid #f9a8d4;
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
        font-size: 0.85rem; flex-wrap: wrap; gap: 4px;
    }
    body.theme-dark .character-header { background: var(--pane-character-head, #701a75); border-color: #a21caf; }
    .character-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .character-toolbar {
        display: flex; gap: 4px; flex-wrap: wrap; padding: 8px 10px;
        border-bottom: 1px solid var(--border-color);
        background: var(--pane-character-head, #fce7f3);
    }
    body.theme-dark .character-toolbar { background: var(--pane-character-head, #701a75); }
    .character-toolbar .btn { padding: 2px 6px; font-size: 0.7rem; }
    .character-content { flex: 1; overflow: auto; padding: 10px; }
    .character-list { overflow: visible; }

    .character-card {
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; margin-bottom: 6px; cursor: grab;
        transition: box-shadow 0.2s, transform 0.15s; position: relative;
    }
    .character-card.has-custom-color { background: var(--character-card-bg, var(--panel-bg)); }
    .character-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .character-card.dragging { opacity: 0.5; transform: scale(0.98); }
    .character-card.drag-over { border-color: #ec4899; box-shadow: 0 0 0 2px rgba(236,72,153,0.3); }
    .character-card.role-protagonist { border-left: 4px solid #ec4899; background: linear-gradient(to right, rgba(236,72,153,0.08), transparent); }
    .character-card.has-custom-color.role-protagonist { border-left-color: var(--character-card-accent, #ec4899); background: var(--character-card-bg, var(--panel-bg)); }
    .character-card.role-heroine { border-left: 4px solid #f472b6; background: linear-gradient(to right, rgba(244,114,182,0.06), transparent); }
    .character-card.has-custom-color.role-heroine { border-left-color: var(--character-card-accent, #f472b6); background: var(--character-card-bg, var(--panel-bg)); }
    .character-card.role-antagonist { border-left: 4px solid #be185d; background: linear-gradient(to right, rgba(190,24,93,0.06), transparent); }
    .character-card.has-custom-color.role-antagonist { border-left-color: var(--character-card-accent, #be185d); background: var(--character-card-bg, var(--panel-bg)); }
    .character-card.role-supporting { margin-left: 16px; border-left: 3px solid #f9a8d4; background: linear-gradient(to right, rgba(249,168,212,0.04), transparent); }
    .character-card.has-custom-color.role-supporting { border-left-color: var(--character-card-accent, #f9a8d4); background: var(--character-card-bg, var(--panel-bg)); }
    .character-card.role-mob { margin-left: 32px; border-left: 2px solid #fbcfe8; font-size: 0.9em; }
    .character-card.has-custom-color.role-mob { border-left-color: var(--character-card-accent, #fbcfe8); }

    .character-card-header { display: flex; align-items: center; gap: 6px; padding: 8px 10px; cursor: pointer; border-bottom: 1px solid transparent; }
    .character-select { width: 14px; height: 14px; accent-color: #ec4899; cursor: pointer; flex-shrink: 0; }
    .character-move-group { display: flex; flex-direction: column; gap: 1px; flex-shrink: 0; }
    .character-move-btn { width: 16px; height: 12px; font-size: 8px; padding: 0; border: 1px solid var(--border-color); border-radius: 2px; background: var(--panel-bg); cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--text-muted); }
    .character-move-btn:hover { background: #fce7f3; color: #ec4899; }
    .character-toggle { font-size: 0.7rem; color: var(--text-muted); width: 14px; cursor: pointer; flex-shrink: 0; }
    .character-toggle:hover { color: #ec4899; }
    .character-name { flex: 1; font-weight: 600; color: var(--text-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85rem; }
    .character-reading { font-size: 0.7rem; color: var(--text-muted); margin-left: 4px; }
    .character-card.expanded .character-card-header { border-bottom-color: var(--border-color); }

    .character-role-badge { font-size: 0.65rem; padding: 2px 6px; border-radius: 10px; white-space: nowrap; flex-shrink: 0; }
    .character-role-badge.role-protagonist { background: #fce7f3; color: #be185d; }
    .character-role-badge.role-heroine { background: #fdf2f8; color: #db2777; }
    .character-role-badge.role-antagonist { background: #fce7f3; color: #9d174d; }
    .character-role-badge.role-supporting { background: #fdf4ff; color: #a855f7; }
    .character-role-badge.role-mob { background: #f3f4f6; color: #6b7280; }
    body.theme-dark .character-role-badge.role-protagonist { background: #831843; color: #f9a8d4; }
    body.theme-dark .character-role-badge.role-heroine { background: #701a75; color: #f0abfc; }
    body.theme-dark .character-role-badge.role-antagonist { background: #4a044e; color: #f9a8d4; }
    body.theme-dark .character-role-badge.role-supporting { background: #4c1d95; color: #c4b5fd; }
    body.theme-dark .character-role-badge.role-mob { background: #374151; color: #9ca3af; }

    .character-card-body { display: none; padding: 8px 10px; font-size: 0.8rem;         overflow-x: hidden;
    }
.character-card.expanded .character-card-body { display: block; }
    /* 4段階展開システム */
    .character-card.expand-1 .character-card-body { display: block; }
    .character-card.expand-2 .character-card-body { display: block; }
    .character-card.expand-3 .character-card-body { display: block; }
    /* expand-1: タグのみ */
    .character-card.expand-1 .character-description { display: none; }
    .character-card.expand-1 .character-description-preview { display: none; }
    .character-card.expand-1 .card-linked-section { display: none; }
    .character-card.expand-1 .character-card-actions { display: none; }
    /* expand-2: タグ + プレビュー */
    .character-card.expand-2 .character-description { display: none; }
    .character-card.expand-2 .character-description-preview { display: block; }
    .character-card.expand-2 .card-linked-section { display: none; }
    .character-card.expand-2 .character-card-actions { display: none; }
    /* expand-3: すべて表示 */
    .character-card.expand-3 .character-description-preview { display: none; }
    .character-description-preview {
        display: none;
        font-size: 0.75rem;
        color: var(--text-muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px dashed var(--border-color);
    }
    /* ラベル非表示設定 */
    .character-card.hide-labels .character-field-label { display: none; }
    .character-card.hide-labels .character-field { margin-bottom: 4px; }
    .character-field { margin-bottom: 6px; }
    .character-field:last-child { margin-bottom: 0; }
    .character-field-label { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 2px; }
    .character-tags { display: flex; flex-wrap: wrap; gap: 4px; }
    .character-affiliation-tag { background: #fce7f3; color: #be185d; padding: 1px 6px; border-radius: 10px; font-size: 0.7rem; }
    body.theme-dark .character-affiliation-tag { background: #831843; color: #f9a8d4; }
    .character-free-tag { background: #e0e7ff; color: #4338ca; padding: 1px 6px; border-radius: 10px; font-size: 0.7rem; }
    body.theme-dark .character-free-tag { background: #312e81; color: #a5b4fc; }
    .character-card-actions { display: flex; gap: 4px; margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--border-color); }
    .character-card-actions button { padding: 3px 8px; font-size: 0.7rem; border-radius: 4px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-color); cursor: pointer; }
    .character-card-actions button:hover { background: var(--pane-header-bg); }
    .character-card-actions .btn-delete { color: #dc2626; }
    .character-card-actions .btn-delete:hover { background: #fee2e2; }

    #character-edit-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10002; background: rgba(0,0,0,0.45); }
    #character-edit-modal.show { display: flex; }
    .character-edit-box { width: min(480px, 92vw); max-height: 85vh; overflow-y: auto; background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: 0 12px 28px rgba(0,0,0,0.25); padding: 16px; }
    .character-edit-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); }
    .character-edit-header h3 { margin: 0; font-size: 1rem; }
    .character-edit-close { width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border-color); background: transparent; cursor: pointer; font-size: 1rem; color: var(--text-muted); }
    .character-edit-close:hover { background: #fee2e2; color: #dc2626; }
    .character-edit-field { margin-bottom: 12px; }
    .character-edit-field label { display: block; font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; color: var(--text-color); }
    .character-edit-field input, .character-edit-field textarea, .character-edit-field select { width: 100%; padding: 8px 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--pane-header-bg); color: var(--text-color); font-size: 0.85rem; box-sizing: border-box; }
    .character-edit-field textarea { min-height: 80px; resize: vertical; }
    .character-edit-field input:focus, .character-edit-field textarea:focus, .character-edit-field select:focus { outline: none; border-color: #ec4899; }
    .character-edit-hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 2px; }
    .character-edit-actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }
    .tag-suggest-btn { font-size: 0.65rem; padding: 2px 6px; margin-left: 6px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--panel-bg); cursor: pointer; color: var(--text-muted); }
    .tag-suggest-btn:hover { background: #fce7f3; color: #ec4899; }
    .tag-suggestions { display: flex; flex-wrap: wrap; gap: 4px; margin-top: 4px; padding: 6px; background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px; max-height: 120px; overflow-y: auto; }
    .tag-suggestions .tag-item { font-size: 0.7rem; padding: 3px 8px; background: #fce7f3; color: #be185d; border-radius: 12px; cursor: pointer; border: 1px solid #f9a8d4; transition: all 0.15s; }
    .tag-suggestions .tag-item:hover { background: #ec4899; color: white; }
    .tag-suggestions .no-tags { font-size: 0.7rem; color: var(--text-muted); font-style: italic; }

    /* ========== 世界観パネル ========== */
    #world-panel {
        position: fixed; top: var(--dock-top, 44px); left: 0; bottom: 0;
        width: 300px; max-width: 45vw;
        background: var(--pane-world-bg, #ecfdf5);
        border-right: 1px solid #6ee7b7;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(-100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    .main-container.world-right #world-panel {
        left: auto; right: 0;
        border-right: none; border-left: 1px solid #6ee7b7;
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        transform: translateX(100%);
    }
    .main-container.world-right #world-panel.open { transform: translateX(0); }
    /* world: 右側（未ドック時） */
    .main-container.world-right:not(.world-docked) #world-panel{ left:auto; right:0; border-right:none; border-left: 1px solid #6ee7b7; box-shadow: -2px 0 5px rgba(0,0,0,0.1); transform: translateX(100%); }
    .main-container.world-right:not(.world-docked) #world-panel.open{ transform: translateX(0); }

    body.theme-dark #world-panel { background: var(--pane-world-bg, #064e3b); border-color: #059669; }
    #world-panel.open { transform: translateX(0); }
    .main-container.world-docked #world-panel {
        position: relative; top: auto; left: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 300px;
        border-right: 1px solid #6ee7b7; border-left: none;
        order: -8;
    }
    .main-container.world-docked #world-panel.open { display: flex; }
    .main-container.world-docked.world-right #world-panel { order: 9; border-right: none; border-left: 1px solid #6ee7b7; }
    .main-container.world-docked #world-panel.open ~ #resizer-world { display: flex; }
    .main-container.world-docked.world-right #resizer-world { order: 7; }
    .main-container.world-docked:not(.world-right) #resizer-world { order: -7; }
    body.focus-mode #world-panel { display: none !important; }

    .world-header {
        padding: 8px 10px; background: var(--pane-world-head, #d1fae5); border-bottom: 1px solid #6ee7b7;
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
        font-size: 0.85rem; flex-wrap: wrap; gap: 4px;
    }
    body.theme-dark .world-header { background: var(--pane-world-head, #065f46); border-color: #059669; }
    .world-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .world-toolbar {
        display: flex; gap: 4px; flex-wrap: wrap; padding: 8px 10px;
        border-bottom: 1px solid var(--border-color);
        background: var(--pane-world-head, #d1fae5);
    }
    body.theme-dark .world-toolbar { background: var(--pane-world-head, #065f46); }
    .world-toolbar .btn { padding: 2px 6px; font-size: 0.7rem; }
    .world-content { flex: 1; overflow: auto; padding: 10px; }
    .world-list { overflow: visible; }

    .world-card {
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; margin-bottom: 6px; cursor: grab;
        transition: box-shadow 0.2s, transform 0.15s; position: relative;
    }
    .world-card.has-custom-color { background: var(--world-card-bg, var(--panel-bg)); }
    .world-card:hover { box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
    .world-card.dragging { opacity: 0.5; transform: scale(0.98); }
    .world-card.drag-over { border-color: #10b981; box-shadow: 0 0 0 2px rgba(16,185,129,0.3); }
    .world-card.level-major { border-left: 4px solid #10b981; background: linear-gradient(to right, rgba(16,185,129,0.08), transparent); }
    .world-card.has-custom-color.level-major { border-left-color: var(--world-card-accent, #10b981); background: var(--world-card-bg, var(--panel-bg)); }
    .world-card.level-middle { margin-left: 16px; border-left: 3px solid #34d399; background: linear-gradient(to right, rgba(52,211,153,0.05), transparent); }
    .world-card.has-custom-color.level-middle { border-left-color: var(--world-card-accent, #34d399); background: var(--world-card-bg, var(--panel-bg)); }
    .world-card.level-detail { margin-left: 32px; border-left: 2px solid #6ee7b7; font-size: 0.9em; }
    .world-card.has-custom-color.level-detail { border-left-color: var(--world-card-accent, #6ee7b7); }

    .world-card-header { display: flex; align-items: center; gap: 6px; padding: 8px 10px; cursor: pointer; border-bottom: 1px solid transparent; }
    .world-select { width: 14px; height: 14px; accent-color: #10b981; cursor: pointer; flex-shrink: 0; }
    .world-move-group { display: flex; flex-direction: column; gap: 1px; flex-shrink: 0; }
    .world-move-btn { width: 16px; height: 12px; font-size: 8px; padding: 0; border: 1px solid var(--border-color); border-radius: 2px; background: var(--panel-bg); cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--text-muted); }
    .world-move-btn:hover { background: #d1fae5; color: #10b981; }
    .world-toggle { font-size: 0.7rem; color: var(--text-muted); width: 14px; cursor: pointer; flex-shrink: 0; }
    .world-toggle:hover { color: #10b981; }
    .world-name { flex: 1; font-weight: 600; color: var(--text-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-size: 0.85rem; }
    .world-card.level-major .world-name { font-size: 0.95rem; }
    .world-card.expanded .world-card-header { border-bottom-color: var(--border-color); }

    .world-level-badge { font-size: 0.65rem; padding: 2px 6px; border-radius: 10px; white-space: nowrap; flex-shrink: 0; }
    .world-level-badge.level-major { background: #d1fae5; color: #065f46; }
    .world-level-badge.level-middle { background: #ecfdf5; color: #047857; }
    .world-level-badge.level-detail { background: #f0fdf4; color: #059669; }
    body.theme-dark .world-level-badge.level-major { background: #064e3b; color: #6ee7b7; }
    body.theme-dark .world-level-badge.level-middle { background: #065f46; color: #a7f3d0; }
    body.theme-dark .world-level-badge.level-detail { background: #047857; color: #d1fae5; }

    .world-card-body { display: none; padding: 8px 10px; font-size: 0.8rem;         overflow-x: hidden;
    }
.world-card.expanded .world-card-body { display: block; }
    /* 4段階展開システム */
    .world-card.expand-1 .world-card-body { display: block; }
    .world-card.expand-2 .world-card-body { display: block; }
    .world-card.expand-3 .world-card-body { display: block; }
    /* expand-1: タグのみ */
    .world-card.expand-1 .world-description { display: none; }
    .world-card.expand-1 .world-description-preview { display: none; }
    .world-card.expand-1 .card-linked-section { display: none; }
    .world-card.expand-1 .world-card-actions { display: none; }
    /* expand-2: タグ + プレビュー */
    .world-card.expand-2 .world-description { display: none; }
    .world-card.expand-2 .world-description-preview { display: block; }
    .world-card.expand-2 .card-linked-section { display: none; }
    .world-card.expand-2 .world-card-actions { display: none; }
    /* expand-3: すべて表示 */
    .world-card.expand-3 .world-description-preview { display: none; }
    .world-description-preview {
        display: none;
        font-size: 0.75rem;
        color: var(--text-muted);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        margin-top: 4px;
        padding-top: 4px;
        border-top: 1px dashed var(--border-color);
    }
    /* ラベル非表示設定 */
    .world-card.hide-labels .world-field-label { display: none; }
    .world-card.hide-labels .world-field { margin-bottom: 4px; }
    .world-field { margin-bottom: 6px; }
    .world-field:last-child { margin-bottom: 0; }
    .world-field-label { font-size: 0.7rem; color: var(--text-muted); margin-bottom: 2px; }
    .world-tags { display: flex; flex-wrap: wrap; gap: 4px; }
    .world-term-tag { background: #d1fae5; color: #065f46; padding: 1px 6px; border-radius: 10px; font-size: 0.7rem; }
    body.theme-dark .world-term-tag { background: #064e3b; color: #6ee7b7; }
    .world-card-actions { display: flex; gap: 4px; margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--border-color); }
    .world-card-actions button { padding: 3px 8px; font-size: 0.7rem; border-radius: 4px; border: 1px solid var(--border-color); background: var(--panel-bg); color: var(--text-color); cursor: pointer; }
    .world-card-actions button:hover { background: var(--pane-header-bg); }
    .world-card-actions .btn-delete { color: #dc2626; }
    .world-card-actions .btn-delete:hover { background: #fee2e2; }
    .world-card-actions .btn-add-child { color: #10b981; }
    .world-card-actions .btn-add-child:hover { background: #d1fae5; }

    #world-edit-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10002; background: rgba(0,0,0,0.45); }
    #world-edit-modal.show { display: flex; }
    .world-edit-box { width: min(480px, 92vw); max-height: 85vh; overflow-y: auto; background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color); border-radius: 12px; box-shadow: 0 12px 28px rgba(0,0,0,0.25); padding: 16px; }
    .world-edit-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-color); }
    .world-edit-header h3 { margin: 0; font-size: 1rem; }
    .world-edit-close { width: 28px; height: 28px; border-radius: 6px; border: 1px solid var(--border-color); background: transparent; cursor: pointer; font-size: 1rem; color: var(--text-muted); }
    .world-edit-close:hover { background: #fee2e2; color: #dc2626; }
    .world-edit-field { margin-bottom: 12px; }
    .world-edit-field label { display: block; font-size: 0.8rem; font-weight: 600; margin-bottom: 4px; color: var(--text-color); }
    .world-edit-field input, .world-edit-field textarea, .world-edit-field select { width: 100%; padding: 8px 10px; border: 1px solid var(--border-color); border-radius: 6px; background: var(--pane-header-bg); color: var(--text-color); font-size: 0.85rem; box-sizing: border-box; }
    .world-edit-field textarea { min-height: 80px; resize: vertical; }
    .world-edit-field input:focus, .world-edit-field textarea:focus, .world-edit-field select:focus { outline: none; border-color: #10b981; }
    .world-edit-hint { font-size: 0.7rem; color: var(--text-muted); margin-top: 2px; }
    .world-edit-actions { display: flex; justify-content: flex-end; gap: 8px; margin-top: 16px; }


    /* 固定パネル上限ダイアログ */
    .pinned-limit-overlay{
        position: fixed; top:0; left:0; right:0; bottom:0;
        background: rgba(0,0,0,0.5); z-index: 10002;
        display: none; justify-content: center; align-items: center;
    }
    .pinned-limit-dialog{
        background: var(--panel-bg);
        border: 1px solid var(--border-color);
        border-radius: 10px;
        width: min(520px, 92vw);
        padding: 16px 18px;
        box-shadow: 0 12px 30px rgba(0,0,0,0.25);
    }
    .pinned-limit-dialog h3{
        margin: 0 0 10px 0;
        font-size: 1rem;
    }
    .pinned-limit-dialog p{
        margin: 0 0 12px 0;
        font-size: 0.9rem;
        color: var(--text-color);
        opacity: 0.9;
    }
    .pinned-limit-dialog .row{
        display:flex; gap:10px; align-items:center;
        margin-bottom: 14px;
    }
    .pinned-limit-dialog select{
        width: 100%;
        padding: 6px 10px;
        border: 1px solid var(--border-color);
        border-radius: 6px;
        background: var(--panel-bg);
        color: var(--text-color);
    }
    .pinned-limit-dialog .btns{
        display:flex; justify-content:flex-end; gap:10px;
    }


/* ===== Dynamic dock resizers (auto between adjacent panels) ===== */
.dock-resizer{ display:none !important; } /* disable legacy per-boundary resizers */
#dock-resizer-overlay{ position:absolute; inset:0; pointer-events:none; z-index: 9999; }
.dynamic-dock-resizer{
  position:absolute; top:0; bottom:0; width:8px; margin-left:-4px;
  cursor: col-resize; pointer-events:auto;
  background: transparent;
}
.dynamic-dock-resizer:hover{ background: rgba(0,0,0,0.06); }
body.theme-dark .dynamic-dock-resizer:hover{ background: rgba(255,255,255,0.08); }

/* search: left floating support */
.main-container.search-left:not(.search-docked) #search-panel{
  right:auto; left:0; border-left:none; border-right:1px solid var(--border-color);
  box-shadow: 2px 0 5px rgba(0,0,0,0.1); transform: translateX(-100%);
}
.main-container.search-left:not(.search-docked) #search-panel.open{ transform: translateX(0); }

/* outline/search: docked right border support */
.main-container.outline-docked.outline-right #outline-panel{
  border-right:none; border-left:1px solid var(--border-color);
}
.main-container.search-docked.search-right #search-panel{
  border-right:none; border-left:1px solid var(--border-color);
}


/* fix5: hide per-panel width settings in Settings UI */
.st-hide-pane-width{display:none !important;}

    .header-menu-sep{ margin: 0 6px; color: var(--text-muted); user-select:none; }
    .btn-project-new{ padding: 4px 8px; font-size: 0.75rem; }

    /* Terms fullscreen */
    body.terms-fullscreen-mode header,
    body.terms-fullscreen-mode .controls-wrapper,
    body.terms-fullscreen-mode .pane-stack,
    body.terms-fullscreen-mode #memo-panel,
    body.terms-fullscreen-mode #search-panel,
    body.terms-fullscreen-mode #outline-panel,
    body.terms-fullscreen-mode #structure-panel,
    body.terms-fullscreen-mode #character-panel,
    body.terms-fullscreen-mode #world-panel { display:none !important; }
    body.terms-fullscreen-mode #terms-panel{
        position: fixed !important; inset:0 !important;
        width: 100% !important; max-width:none !important;
        transform:none !important; z-index:9999 !important;
        border:none !important; border-radius:0 !important;
        display:flex !important;
        background: var(--pane-terms-bg, #fffbeb) !important;
    }
</style>

<!-- ===== v0.96 hotfix (reader/search/bookmark, active tab color, tab context menu, per-tab stats, focus shortcuts) ===== -->
<style>
  /* アクティブタブ色を入力/プレビュー/メモで統一（設定色を反映） */
  .memo-tab.active,
  .preview-tab.active,
  .pv-tab.active {
    background: var(--active-tab-bg) !important;
    color: var(--active-tab-text) !important;
    font-weight: bold !important;
    border-top: 2px solid var(--active-tab-border) !important;
  }

  /* タブの字数表示 */
  .tab-meta {
    margin-left: 8px;
    font-size: 0.75rem;
    opacity: 0.85;
    white-space: nowrap;
  }
  .tab-meta .today {
    margin-left: 6px;
    font-weight: 600;
  }

  /* 集中モードの一時表示（オーバーレイ） */
  #focus-overlay {
    position: fixed;
    inset: 0;
    z-index: 99999;
    background: rgba(0,0,0,0.55);
    display: none;
    align-items: center;
    justify-content: center;
  }
  #focus-overlay.show { display: flex; }
  #focus-overlay .fo-box {
    width: min(1100px, calc(100vw - 24px));
    height: min(85vh, calc(100vh - 24px));
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
  }
  #focus-overlay .fo-head {
    display:flex;
    align-items:center;
    justify-content: space-between;
    padding: 10px 12px;
    background: var(--header-bg);
    border-bottom: 1px solid var(--border-color);
    gap: 10px;
  }
  #focus-overlay .fo-title { font-weight: 700; }
  #focus-overlay .fo-body {
    flex: 1;
    overflow: auto;
    padding: 12px;
    background: var(--panel-bg);
    color: var(--text-color);
  }
  #focus-overlay .fo-body.vertical-mode { writing-mode: vertical-rl; }
  #focus-overlay pre {
    white-space: pre-wrap;
    word-break: break-word;
    margin: 0;
    font: inherit;
  }

  /* 閲覧検索ハイライト */
  mark.reader-hit {
    padding: 0 2px;
    border-radius: 4px;
    background: rgba(255, 230, 0, 0.55);
  }
  mark.reader-hit.active {
    outline: 2px solid rgba(255, 140, 0, 0.9);
    background: rgba(255, 200, 0, 0.85);
  }

  /* Context menu styles */
  .context-menu {
    position: fixed;
    min-width: 200px;
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.15);
    z-index: 2000;
    display: none;
    padding: 6px 0;
  }
  .context-menu.show { display: block; }
  .context-menu-item {
    padding: 8px 16px;
    cursor: pointer;
    font-size: 0.85rem;
  }
  .context-menu-item:hover {
    background: var(--pane-header-bg, #f3f4f6);
  }
  body.theme-dark .context-menu-item:hover {
    background: #4b5563;
  }

  /* Floating panel styles */
  .floating-panel {
    font-family: inherit;
  }
  .floating-panel-header {
    user-select: none;
  }
</style>

<script>
// ===== v0.96 hotfix JS =====
(function(){
  'use strict';

  // -----------------------------
  // 0) 安全ユーティリティ
  // -----------------------------
  function clamp(n, min, max){ return Math.min(Math.max(n, min), max); }
  function parseTimeToMinutes(hhmm){
    if (!hhmm || typeof hhmm !== 'string') return 0;
    const m = hhmm.trim().match(/^(\d{1,2}):(\d{2})$/);
    if (!m) return 0;
    const h = clamp(parseInt(m[1],10)||0, 0, 23);
    const mi = clamp(parseInt(m[2],10)||0, 0, 59);
    return h*60 + mi;
  }
  function shadeHex(hex, percent){
    // percent: -1..1 (negative darker)
    if (!hex) return '#fff59d';
    const m = hex.trim().match(/^#?([0-9a-fA-F]{6})$/);
    if (!m) return hex;
    const n = parseInt(m[1],16);
    let r = (n>>16)&255, g=(n>>8)&255, b=n&255;
    const t = percent<0 ? 0 : 255;
    const p = Math.abs(percent);
    r = Math.round((t-r)*p + r);
    g = Math.round((t-g)*p + g);
    b = Math.round((t-b)*p + b);
    return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
  }

  // -----------------------------
  // 1) 「今日」開始時刻を反映：getTodayDateStrを論理日付に置換
  // -----------------------------
  const DAY_START_LS_KEY = 'cc_day_start_hhmm';
  function getDayStartHHMM(){
    const el = document.getElementById('st-day-start');
    const v = (el && el.value) ? el.value : (localStorage.getItem(DAY_START_LS_KEY) || '00:00');
    return v || '00:00';
  }
  function saveDayStartHHMM(v){
    if (!v) return;
    localStorage.setItem(DAY_START_LS_KEY, v);
  }

  // 既存関数を上書き（以後の「今日」計算はこの論理日付を使う）
  window.getTodayDateStr = function(){
    const now = new Date();
    const offsetMin = parseTimeToMinutes(getDayStartHHMM());
    const adj = new Date(now.getTime() - offsetMin*60*1000);
    const y = adj.getFullYear();
    const m = String(adj.getMonth()+1).padStart(2,'0');
    const d = String(adj.getDate()).padStart(2,'0');
    return `${y}-${m}-${d}`;
  };

  // UIから変更 → 保存＆再計算
  function hookDayStartUI(){
    const el = document.getElementById('st-day-start');
    if (!el) return;
    // ローカル保存値を優先して反映
    const saved = localStorage.getItem(DAY_START_LS_KEY);
    if (saved && !el.value) el.value = saved;
    if (saved && el.value !== saved) el.value = saved;
    el.addEventListener('change', () => {
      saveDayStartHHMM(el.value || '00:00');
      // 「今日」基準が変わるので、今日開始文字数を再読込して表示更新
      try { loadTodayStart(); } catch(e) {}
      try { updateInputStats(); } catch(e) {}
      try { updatePreview(); } catch(e) {}
      try { updateTabMetaLabels(); } catch(e) {}
    });
  }

  // -----------------------------
  // 2) アクティブタブ色設定
  // -----------------------------
  const ACTIVE_TAB_COLOR_KEY = 'cc_active_tab_color';
  function applyActiveTabColor(hex){
    const root = document.documentElement;
    const bg = hex || '#fff59d';
    root.style.setProperty('--active-tab-bg', bg);
    root.style.setProperty('--active-tab-border', shadeHex(bg, -0.35));
    root.style.setProperty('--active-tab-text', 'var(--text-color)');
  }
  function hookActiveTabColorUI(){
    const el = document.getElementById('st-active-tab-color');
    if (!el) return;
    const saved = localStorage.getItem(ACTIVE_TAB_COLOR_KEY);
    if (saved) {
      el.value = saved;
      applyActiveTabColor(saved);
    } else {
      applyActiveTabColor(el.value);
    }
    el.addEventListener('input', () => {
      applyActiveTabColor(el.value);
    });
    el.addEventListener('change', () => {
      localStorage.setItem(ACTIVE_TAB_COLOR_KEY, el.value);
      try { if (typeof saveSettingsToStorage==='function') saveSettingsToStorage(); } catch(e) {}
    });
  }

  // -----------------------------
  // 3) 閲覧（Reader）：検索＆しおりを実装
  // -----------------------------
  let readerMatches = [];
  let readerMatchIndex = -1;
  const READER_BM_KEY = 'cc_reader_bookmarks_v1';
  let readerBookmarks = [];

  function readerGetEls(){
    return {
      overlay: document.getElementById('reader-overlay'),
      scroll: document.getElementById('reader-scroll'),
      content: document.getElementById('reader-content'),
      input: document.getElementById('reader-search-input'),
      info: document.getElementById('reader-search-info'),
      select: document.getElementById('reader-bookmark-select')
    };
  }

  function clearReaderHighlights(){
    const {content, info} = readerGetEls();
    if (!content) return;
    // unwrap marks
    content.querySelectorAll('mark.reader-hit').forEach(m => {
      const parent = m.parentNode;
      while (m.firstChild) parent.insertBefore(m.firstChild, m);
      parent.removeChild(m);
      parent.normalize();
    });
    readerMatches = [];
    readerMatchIndex = -1;
    if (info) info.textContent = '0/0';
  }

  function highlightReaderQuery(q){
    const {content} = readerGetEls();
    if (!content) return;
    if (!q) return;
    const query = q;
    const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, {
      acceptNode(node){
        if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
        const p = node.parentNode;
        if (!p) return NodeFilter.FILTER_REJECT;
        if (p.closest && p.closest('script, style')) return NodeFilter.FILTER_REJECT;
        return node.nodeValue.includes(query) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
    });

    const nodes = [];
    while (walker.nextNode()) nodes.push(walker.currentNode);

    nodes.forEach(node => {
      const text = node.nodeValue;
      let idx = text.indexOf(query);
      if (idx === -1) return;
      const frag = document.createDocumentFragment();
      let last = 0;
      while (idx !== -1) {
        if (idx > last) frag.appendChild(document.createTextNode(text.slice(last, idx)));
        const mark = document.createElement('mark');
        mark.className = 'reader-hit';
        mark.textContent = text.slice(idx, idx + query.length);
        frag.appendChild(mark);
        readerMatches.push(mark);
        last = idx + query.length;
        idx = text.indexOf(query, last);
      }
      if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
      node.parentNode.replaceChild(frag, node);
    });
  }

  function setReaderActiveHit(i){
    const {scroll, info} = readerGetEls();
    if (!scroll) return;
    readerMatches.forEach(m => m.classList.remove('active'));
    if (readerMatches.length === 0) {
      readerMatchIndex = -1;
      if (info) info.textContent = '0/0';
      return;
    }
    readerMatchIndex = ((i % readerMatches.length) + readerMatches.length) % readerMatches.length;
    const el = readerMatches[readerMatchIndex];
    el.classList.add('active');
    el.scrollIntoView({block:'center', inline:'center'});
    if (info) info.textContent = `${readerMatchIndex+1}/${readerMatches.length}`;
  }

  window.readerDoSearch = function(){
    const {input} = readerGetEls();
    const q = (input?.value || '').trim();
    clearReaderHighlights();
    if (!q) return;
    highlightReaderQuery(q);
    setReaderActiveHit(0);
  };
  window.readerFindNext = function(){
    if (readerMatches.length === 0) { window.readerDoSearch(); return; }
    setReaderActiveHit(readerMatchIndex + 1);
  };
  window.readerFindPrev = function(){
    if (readerMatches.length === 0) { window.readerDoSearch(); return; }
    setReaderActiveHit(readerMatchIndex - 1);
  };

  function loadReaderBookmarks(){
    try {
      const s = localStorage.getItem(READER_BM_KEY);
      readerBookmarks = s ? JSON.parse(s) : [];
      if (!Array.isArray(readerBookmarks)) readerBookmarks = [];
    } catch(e){ readerBookmarks = []; }
  }
  function saveReaderBookmarks(){
    try { localStorage.setItem(READER_BM_KEY, JSON.stringify(readerBookmarks)); } catch(e) {}
  }
  function renderReaderBookmarks(){
    const {select} = readerGetEls();
    if (!select) return;
    select.innerHTML = '<option value="">🔖 しおり</option>';
    readerBookmarks.forEach((b, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = b.label;
      select.appendChild(opt);
    });
  }

  window.readerAddBookmark = function(){
    const {scroll} = readerGetEls();
    if (!scroll) return;
    const y = scroll.scrollTop;
    const x = scroll.scrollLeft;
    const label = `しおり ${readerBookmarks.length+1}（${Math.round(y)}px）`;
    readerBookmarks.push({top:y, left:x, label, created: Date.now()});
    saveReaderBookmarks();
    renderReaderBookmarks();
    const {select} = readerGetEls();
    if (select) select.value = String(readerBookmarks.length-1);
  };
  window.readerJumpBookmark = function(){
    const {select, scroll} = readerGetEls();
    if (!select || !scroll) return;
    const idx = parseInt(select.value, 10);
    if (Number.isNaN(idx)) return;
    const b = readerBookmarks[idx];
    if (!b) return;
    scroll.scrollTop = b.top;
    scroll.scrollLeft = b.left;
  };

  // openReaderView / closeReaderView をフック：検索ハイライト初期化＆しおり反映
  function wrapReaderViewFunctions(){
    if (typeof window.openReaderView === 'function' && !window.openReaderView.__hotfixWrapped) {
      const base = window.openReaderView;
      const wrapped = function(){
        try { clearReaderHighlights(); } catch(e) {}
        loadReaderBookmarks();
        renderReaderBookmarks();
        return base.apply(this, arguments);
      };
      wrapped.__hotfixWrapped = true;
      window.openReaderView = wrapped;
    }
    if (typeof window.closeReaderView === 'function' && !window.closeReaderView.__hotfixWrapped) {
      const base = window.closeReaderView;
      const wrapped = function(){
        try { clearReaderHighlights(); } catch(e) {}
        return base.apply(this, arguments);
      };
      wrapped.__hotfixWrapped = true;
      window.closeReaderView = wrapped;
    }
  }

  // -----------------------------
  // 4) タブ右クリックメニュー
  // -----------------------------
  let ctxTabId = null;
  function hideCtx(){
    const m = document.getElementById('tab-context-menu');
    if (!m) return;
    m.style.display = 'none';
    m.setAttribute('aria-hidden','true');
    ctxTabId = null;
  }
  function showCtx(tabId, x, y){
    const m = document.getElementById('tab-context-menu');
    if (!m) return;
    ctxTabId = tabId;
    m.style.display = 'block';
    m.setAttribute('aria-hidden','false');
    const w = m.offsetWidth || 180;
    const h = m.offsetHeight || 140;
    const left = clamp(x, 8, window.innerWidth - w - 8);
    const top  = clamp(y, 8, window.innerHeight - h - 8);
    m.style.left = left + 'px';
    m.style.top  = top + 'px';
  }

  // 入力タブ：右クリックメニュー（委譲バインドで取りこぼし防止）
  function bindInputTabContextMenuDelegation(){
    const container = document.getElementById('input-tabs-container');
    if (!container || container.__ctxDelegationBound) return;
    container.__ctxDelegationBound = true;
    container.addEventListener('contextmenu', (e) => {
      const tabEl = e.target && e.target.closest ? e.target.closest('.input-tab') : null;
      if (!tabEl || !container.contains(tabEl)) return;
      const id = parseInt(tabEl.dataset.tabId, 10);
      if (Number.isNaN(id)) return;
      e.preventDefault();
      e.stopPropagation();
      showCtx(id, e.clientX, e.clientY);
    }, true);
  }


  // ctx action functions
  window.ctxRenameTab = function(){
    if (ctxTabId == null) return;
    hideCtx();
    try { startEditTabName(ctxTabId); } catch(e) {}
  };
  window.ctxDuplicateTab = function(){
    if (ctxTabId == null) return;
    hideCtx();
    try {
      const t = inputTabs.find(tt => tt.id === ctxTabId);
      if (!t) return;
      // active tab content flush
      const cur = inputTabs.find(tt => tt.id === activeTabId);
      if (cur) cur.content = inputArea.value;
      const copy = { id: nextTabId++, name: (t.name || 'タブ') + '（複製）', content: t.content || '' };
      const idx = inputTabs.findIndex(tt => tt.id === ctxTabId);
      inputTabs.splice(idx+1, 0, copy);
      activeTabId = copy.id;
      inputArea.value = copy.content;
      renderInputTabs();
      updateInputStats();
      saveTabsToStorage();
    } catch(e) {}
  };
  window.ctxNewTab = function(){ hideCtx(); try { addNewTab(); } catch(e) {} };
  window.ctxCloseTab = function(){
    if (ctxTabId == null) return;
    const id = ctxTabId;
    hideCtx();
    try { deleteTab(id); } catch(e) {}
  };

  // renderInputTabs を上書き：右クリック＋タブ字数表示（本体JSの定義後にフック）
  function wrapRenderInputTabs(){
    if (typeof window.renderInputTabs !== 'function' || window.renderInputTabs.__hotfixWrapped) return;
    const base = window.renderInputTabs;
    const wrapped = function(){
      const r = base.apply(this, arguments);
      // 既存renderが作ったDOMに対して後付けで右クリックと字数表示を付与
      const container = document.getElementById('input-tabs-container');
      if (container) {
        container.querySelectorAll('.input-tab').forEach(tabEl => {
          // 二重バインド防止
          if (tabEl.__ctxBound) return;
          tabEl.__ctxBound = true;
          const id = parseInt(tabEl.dataset.tabId, 10);
          if (!Number.isNaN(id)) {
            tabEl.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              e.stopPropagation();
              showCtx(id, e.clientX, e.clientY);
            });
          }
        });
      }
      try { updateTabMetaLabels(); } catch(e) {}
      return r;
    };
    wrapped.__hotfixWrapped = true;
    window.renderInputTabs = wrapped;
  }

  // クリック外で閉じる
  document.addEventListener('pointerdown', (e) => {
    const m = document.getElementById('tab-context-menu');
    if (!m || m.style.display !== 'block') return;
    if (m.contains(e.target)) return;
    hideCtx();
  });
  window.addEventListener('scroll', hideCtx, true);
  window.addEventListener('resize', hideCtx);

  // -----------------------------
  // 5) タブごとの字数（＋今日増分）
  // -----------------------------
  const TAB_DAY_BASE_KEY = 'cc_tab_day_baselines_v1';
  let tabDayBaselines = { date: null, base: {} };

  function normalizedLen(text){
    return String(text || '').replace(/[\n\r\s　]/g,'').length;
  }
  function loadTabBaselines(){
    try {
      const s = localStorage.getItem(TAB_DAY_BASE_KEY);
      tabDayBaselines = s ? JSON.parse(s) : {date:null, base:{}};
      if (!tabDayBaselines || typeof tabDayBaselines !== 'object') tabDayBaselines = {date:null, base:{}};
      if (!tabDayBaselines.base || typeof tabDayBaselines.base !== 'object') tabDayBaselines.base = {};
    } catch(e){ tabDayBaselines = {date:null, base:{}}; }
  }
  function saveTabBaselines(){
    try { localStorage.setItem(TAB_DAY_BASE_KEY, JSON.stringify(tabDayBaselines)); } catch(e) {}
  }
  function ensureTabBaselinesForToday(){
    const today = window.getTodayDateStr();
    if (tabDayBaselines.date !== today) {
      tabDayBaselines = { date: today, base: {} };
    }
    // base未登録は現在値を採用
    inputTabs.forEach(t => {
      const key = String(t.id);
      if (tabDayBaselines.base[key] == null) {
        tabDayBaselines.base[key] = normalizedLen(t.content || '');
      }
    });
    saveTabBaselines();
  }

  window.updateTabMetaLabels = function(){
    try {
      // activeタブの内容を退避
      const cur = inputTabs.find(t => t.id === activeTabId);
      if (cur) cur.content = inputArea.value;
    } catch(e) {}

    loadTabBaselines();
    ensureTabBaselinesForToday();

    const container = document.getElementById('input-tabs-container');
    if (!container) return;
    container.querySelectorAll('.input-tab').forEach(tabEl => {
      const id = parseInt(tabEl.dataset.tabId,10);
      if (Number.isNaN(id)) return;
      const t = inputTabs.find(tt => tt.id === id);
      if (!t) return;
      const len = normalizedLen(t.content || '');
      const base = tabDayBaselines.base[String(id)] ?? len;
      const delta = Math.max(0, len - base);

      let meta = tabEl.querySelector('.tab-meta');
      if (!meta) {
        meta = document.createElement('span');
        meta.className = 'tab-meta';
        tabEl.querySelector('.tab-name')?.after(meta);
      }
      meta.innerHTML = `${len}字<span class="today">+${delta}</span>`;
    });
  };

  // 入力のたびにメタだけ更新（重い再描画はしない）
  function wrapUpdateInputStats(){
    if (typeof window.updateInputStats !== 'function' || window.updateInputStats.__hotfixWrapped) return;
    const base = window.updateInputStats;
    const wrapped = function(){
      const r = base.apply(this, arguments);
      try { updateTabMetaLabels(); } catch(e) {}
      return r;
    };
    wrapped.__hotfixWrapped = true;
    window.updateInputStats = wrapped;
  }

  // -----------------------------
  // 6) 集中モード中のショートカット（Ctrl+Shift+P/M/O）
  // -----------------------------
  function ensureFocusOverlay(){
    let ov = document.getElementById('focus-overlay');
    if (ov) return ov;
    ov = document.createElement('div');
    ov.id = 'focus-overlay';
    ov.innerHTML = `
      <div class="fo-box" role="dialog" aria-label="集中モード一時表示">
        <div class="fo-head">
          <div class="fo-title" id="fo-title">一時表示</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span style="font-size:0.85rem; opacity:0.8;">Escで閉じる</span>
            <button class="btn" id="fo-close" type="button">✕</button>
          </div>
        </div>
        <div class="fo-body" id="fo-body"></div>
      </div>
    `;
    document.body.appendChild(ov);
    ov.addEventListener('pointerdown', (e) => {
      if (e.target === ov) closeFocusOverlay();
    });
    ov.querySelector('#fo-close')?.addEventListener('click', closeFocusOverlay);
    return ov;
  }
  function openFocusOverlay(kind){
    const ov = ensureFocusOverlay();
    const titleEl = ov.querySelector('#fo-title');
    const bodyEl = ov.querySelector('#fo-body');
    if (!bodyEl || !titleEl) return;

    // reset
    bodyEl.classList.remove('vertical-mode');
    bodyEl.innerHTML = '';

    if (kind === 'preview') {
      titleEl.textContent = '🪞 プレビュー（一時表示）';
      try { if (typeof updatePreview === 'function') updatePreview(); } catch(e) {}
      // previewScroll が縦書きなら同様に
      const pvScroll = document.getElementById('preview-scroll');
      const pvContent = document.getElementById('preview-content');
      const wrap = document.createElement('div');
      wrap.innerHTML = pvContent ? pvContent.innerHTML : '';
      bodyEl.appendChild(wrap);
      if (pvScroll && pvScroll.classList.contains('vertical-mode')) bodyEl.classList.add('vertical-mode');
    } else if (kind === 'memo') {
      titleEl.textContent = '🗒 メモ（一時表示）';
      const memoArea = document.getElementById('memo-area');
      const pre = document.createElement('pre');
      pre.textContent = memoArea ? memoArea.value : '';
      bodyEl.appendChild(pre);
    } else if (kind === 'outline') {
      titleEl.textContent = '📑 目次（一時表示）';
      const outline = document.getElementById('outline-list');
      const div = document.createElement('div');
      div.innerHTML = outline ? outline.innerHTML : '<div style="opacity:0.7;">目次がありません</div>';
      bodyEl.appendChild(div);
    }

    ov.classList.add('show');
  }
  function closeFocusOverlay(){
    const ov = document.getElementById('focus-overlay');
    if (!ov) return;
    ov.classList.remove('show');
  }
  // Escで閉じる（Reader優先）
  document.addEventListener('keydown', (e) => {
    const ov = document.getElementById('focus-overlay');
    if (ov && ov.classList.contains('show') && e.key === 'Escape') {
      e.preventDefault();
      closeFocusOverlay();
    }
  });

  // 既存のキー処理に追加（重複しても安全にする）
  document.addEventListener('keydown', (e) => {
    if (!document.body.classList.contains('focus-mode')) return;
    if (!e.ctrlKey || !e.shiftKey) return;
    const k = e.key;
    if (k === 'P' || k === 'p') { e.preventDefault(); openFocusOverlay('preview'); }
    if (k === 'M' || k === 'm') { e.preventDefault(); openFocusOverlay('memo'); }
    if (k === 'O' || k === 'o') { e.preventDefault(); openFocusOverlay('outline'); }
  }, true);

  // -----------------------------
  // 7) ルビモーダル：存在してもエラーにならないよう最低限だけ（現状仕様は維持）
  // -----------------------------
  window.closeRubyModal = window.closeRubyModal || function(){
    const m = document.getElementById('ruby-modal');
    if (!m) return;
    m.classList.remove('show');
    m.setAttribute('aria-hidden','true');
  };
  window.confirmRubyModal = window.confirmRubyModal || function(){
    // 現状はモーダル運用していないため、誤って開いてもキャンセル扱い
    window.closeRubyModal();
  };

  // -----------------------------
  // 8) 初期化：起動時にフックを有効化
  // -----------------------------
  function initHotfix(){
    hookDayStartUI();
    hookActiveTabColorUI();
    wrapReaderViewFunctions();
    wrapRenderInputTabs();
    bindInputTabContextMenuDelegation();
    wrapUpdateInputStats();
    initAppContextMenu();
    try{ if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses(); }catch(e){}
    try{ if (typeof window.__ccInitPanelDnDAndResizers === 'function') window.__ccInitPanelDnDAndResizers(); }catch(e){}
    
    try{ if (typeof window.bindPanelFrontTracking === "function") window.bindPanelFrontTracking(); }catch(e){}
// 既に描画済みのタブへ右クリック/字数表示を反映させるため、1度だけ再描画
    try { if (typeof window.renderInputTabs === 'function') window.renderInputTabs(); } catch(e) {}
    loadTabBaselines();
    ensureTabBaselinesForToday();
    try { updateTabMetaLabels(); } catch(e) {}
    loadReaderBookmarks();
    renderReaderBookmarks();
  }

/* ===== Panel DnD reorder + Dynamic dock resizers ===== */
(function(){
  const PANEL_KEYS = ['memo','outline','world','character','structure','terms','search'];

  function keyFromPanelId(panelId){
    if (!panelId) return null;
    if (panelId.endsWith('-panel')) return panelId.replace('-panel','');
    return panelId;
  }

  function ensureOverlay(){
    const c = document.getElementById('main-container');
    if (!c) return null;
    let ov = document.getElementById('dock-resizer-overlay');
    if (!ov){
      ov = document.createElement('div');
      ov.id = 'dock-resizer-overlay';
      c.style.position = c.style.position || 'relative';
      c.appendChild(ov);
    }
    return ov;
  }

  function isDockedOpen(key){
    const c = document.getElementById('main-container');
    const p = document.getElementById(key+'-panel');
    if (!c || !p) return false;
    return c.classList.contains(key+'-docked') && p.classList.contains('open');
  }

  function isFlexFixed(el){
    const cs = window.getComputedStyle(el);
    const fg = parseFloat(cs.flexGrow || '0');
    return fg === 0;
  }

  function getVisibleColumns(){
    const c = document.getElementById('main-container');
    if (!c) return [];
    const cols = [];
    // docked panels that are open
    PANEL_KEYS.forEach(k=>{
      if (isDockedOpen(k)){
        const el = document.getElementById(k+'-panel');
        if (el) cols.push(el);
      }
    });
    // center stack
    const stack = document.getElementById('pane-stack');
    if (stack) cols.push(stack);

    // plus any right-side docked panels (same list already contains; order sorted by x)
    // sort by actual x position
    const cRect = c.getBoundingClientRect();
    const items = cols.map(el=>{
      const r = el.getBoundingClientRect();
      return {el, left: r.left - cRect.left, right: r.right - cRect.left, width: r.width};
    }).filter(it=>it.width>5);
    items.sort((a,b)=>a.left-b.left);
    return items;
  }

  window.__ccUpdateDockResizers = function(){
    const c = document.getElementById('main-container');
    const ov = ensureOverlay();
    if (!c || !ov) return;

    ov.innerHTML = '';
    const items = getVisibleColumns();
    if (items.length < 2) return;

    // create resizers between adjacent items
    for (let i=0;i<items.length-1;i++){
      const left = items[i], right = items[i+1];
      const x = left.right; // boundary
      const rz = document.createElement('div');
      rz.className = 'dynamic-dock-resizer';
      rz.style.left = x + 'px';
      rz.dataset.leftId = left.el.id;
      rz.dataset.rightId = right.el.id;
      ov.appendChild(rz);
    }
  };

  function widthInputIdForKey(key){
    if (!key) return null;
    return 'st-pane-' + key + '-width';
  }

  function applyWidthToPanel(key, px){
    const el = document.getElementById(key+'-panel');
    if (!el) return;
    el.style.width = px + 'px';
    el.style.flexBasis = px + 'px';
  }

  function setSettingWidth(key, px){
    const id = widthInputIdForKey(key);
    const el = document.getElementById(id);
    if (el){
      el.value = String(px);
      // persist via applyDockedPanelWidths' localStorage pattern by calling applyPaneWidthSettings or applyDockedPanelWidths
    }
  }

  // Drag handling for dynamic resizers
  function bindResizerDrag(){
    const ov = document.getElementById('dock-resizer-overlay');
    if (!ov) return;
    let drag = null;

    ov.addEventListener('pointerdown', (e)=>{
      const rz = e.target.closest('.dynamic-dock-resizer');
      if (!rz) return;
      const leftEl = document.getElementById(rz.dataset.leftId);
      const rightEl = document.getElementById(rz.dataset.rightId);
      if (!leftEl || !rightEl) return;

      e.preventDefault();
      rz.setPointerCapture(e.pointerId);

      const leftRect = leftEl.getBoundingClientRect();
      const rightRect = rightEl.getBoundingClientRect();
      const startX = e.clientX;

      drag = {
        pointerId: e.pointerId,
        rz,
        leftEl,
        rightEl,
        startX,
        startLeftW: leftRect.width,
        startRightW: rightRect.width
      };
    });

    window.addEventListener('pointermove', (e)=>{
      if (!drag) return;
      const dx = e.clientX - drag.startX;

      const leftFixed = isFlexFixed(drag.leftEl);
      const rightFixed = isFlexFixed(drag.rightEl);

      // clamp values
      const minW = 140;
      const maxTotal = drag.startLeftW + drag.startRightW;

      if (leftFixed && rightFixed){
        let newLeft = drag.startLeftW + dx;
        newLeft = Math.max(minW, Math.min(maxTotal - minW, newLeft));
        const newRight = maxTotal - newLeft;

        // apply both
        const leftKey = keyFromPanelId(drag.leftEl.id);
        const rightKey = keyFromPanelId(drag.rightEl.id);
        if (leftKey) { applyWidthToPanel(leftKey, Math.round(newLeft)); setSettingWidth(leftKey, Math.round(newLeft)); }
        if (rightKey && rightKey !== 'pane-stack') { applyWidthToPanel(rightKey, Math.round(newRight)); setSettingWidth(rightKey, Math.round(newRight)); }
      } else {
        // one side is flexible (likely pane-stack): adjust the fixed side only
        const targetEl = leftFixed ? drag.leftEl : (rightFixed ? drag.rightEl : null);
        if (!targetEl) return;
        const isLeftTarget = targetEl === drag.leftEl;
        const startW = isLeftTarget ? drag.startLeftW : drag.startRightW;
        let newW = startW + (isLeftTarget ? dx : -dx);
        newW = Math.max(minW, newW);

        const key = keyFromPanelId(targetEl.id);
        if (key) { applyWidthToPanel(key, Math.round(newW)); setSettingWidth(key, Math.round(newW)); }
      }

      if (typeof applyDockedPanelWidths === 'function') applyDockedPanelWidths();
      if (typeof adjustPaneWidthsOnVisibility === 'function') adjustPaneWidthsOnVisibility();
      window.__ccUpdateDockResizers();
    });

    window.addEventListener('pointerup', (e)=>{
      if (!drag) return;
      drag = null;
      // persist widths through existing "適用" flow: store dock widths
      try{
        if (typeof applyPaneWidthSettings === 'function') {
          // only saves input/preview; dock widths saved in applyDockedPanelWidths if it stores localStorage itself
        }
      }catch(e){}
    });
  }

  // DnD reorder within same side
  function bindPanelDnD(){
    // Make it easy: allow dropping on header OR anywhere on the panel body.
    const getKey = (el)=>{
      if(!el) return null;
      const pid = el.dataset.panelId || el.getAttribute('data-panel-id') || el.id;
      return keyFromPanelId(pid);
    };

    const clearOver = ()=>{
      document.querySelectorAll('.panel-drag-handle.drag-over, .panel-dnd-dropzone.drag-over')
        .forEach(x=>x.classList.remove('drag-over'));
    };

    // Ensure title spans also start drag (some browsers are picky when dragging child elements).
    document.querySelectorAll('.panel-drag-handle').forEach(h=>{
      const titleSpan = h.querySelector('span');
      if (titleSpan && !titleSpan.hasAttribute('draggable')){
        titleSpan.setAttribute('draggable','true');
        titleSpan.dataset.panelId = h.dataset.panelId || h.getAttribute('data-panel-id') || h.id;
        titleSpan.classList.add('panel-drag-handle');
      }
    });

    const dragStart = (e)=>{
      const key = getKey(e.currentTarget);
      if (!key) return;
      try{
        e.dataTransfer.setData('text/plain', key);
        e.dataTransfer.effectAllowed = 'move';
      }catch(err){}
      e.currentTarget.classList.add('dragging');
    };
    const dragEnd = (e)=>{
      e.currentTarget.classList.remove('dragging');
      clearOver();
    };
    const dragOver = (e)=>{
      const sourceKey = (()=>{ try{return e.dataTransfer.getData('text/plain');}catch(_){return '';}})();
      const targetKey = getKey(e.currentTarget);
      if (!sourceKey || !targetKey || sourceKey===targetKey) return;
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      e.currentTarget.classList.add('drag-over');
    };
    const drop = (e)=>{
      e.preventDefault();
      const sourceKey = (()=>{ try{return e.dataTransfer.getData('text/plain');}catch(_){return '';}})();
      const targetKey = getKey(e.currentTarget);
      if (!sourceKey || !targetKey || sourceKey===targetKey) return;

      if (typeof window.__ccGetPanelSide === 'function'){
        const s1 = window.__ccGetPanelSide(sourceKey);
        const s2 = window.__ccGetPanelSide(targetKey);
        if (s1 !== s2 && typeof window.__ccSetPanelSide === 'function'){
          window.__ccSetPanelSide(sourceKey, s2, false);
        }
      }
      if (typeof window.__ccReorderWithinSide === 'function'){
        window.__ccReorderWithinSide(sourceKey, targetKey);
      }
      clearOver();
      if (typeof window.__ccUpdateDockResizers === 'function') window.__ccUpdateDockResizers();
    };

    // Headers as drag sources + drop targets
    document.querySelectorAll('.panel-drag-handle[draggable="true"]').forEach(h=>{
      h.addEventListener('dragstart', dragStart);
      h.addEventListener('dragend', dragEnd);
      h.addEventListener('dragover', dragOver);
      h.addEventListener('dragleave', ()=>h.classList.remove('drag-over'));
      h.addEventListener('drop', drop);
    });

    // Whole panels as drop targets (user can drop on body to swap)
    PANEL_KEYS.forEach(k=>{
      const p = document.getElementById(k+'-panel');
      if(!p) return;
      p.classList.add('panel-dnd-dropzone');
      p.addEventListener('dragover', dragOver);
      p.addEventListener('dragleave', ()=>p.classList.remove('drag-over'));
      p.addEventListener('drop', drop);
    });
  }
window.__ccInitPanelDnDAndResizers = function(){
    if (typeof window.__ccInitPanelSideState === 'function') window.__ccInitPanelSideState();
    bindPanelDnD();
    window.__ccUpdateDockResizers();
    bindResizerDrag();

    // keep updated
    window.addEventListener('resize', ()=>window.__ccUpdateDockResizers());
  };
})();


  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHotfix);
  } else {
    initHotfix();
  }
})();
</script>
</head>
<body>

<header class="app-header">
    <div class="ribbon-row">
        <div class="ribbon-left">
            <button class="app-icon" id="app-icon" title="アプリメニュー">
                <img src="icons/favicon-32.png" alt="アプリアイコン">
            </button>
            <span class="app-title" id="app-title">ⓒエディタver.0.99</span>
            <nav class="ribbon-menu" aria-label="リボンメニュー">
                <button class="ribbon-menu-btn" data-section-target="file" onclick="setActiveRibbonSection('file')">ファイル</button>
                <button class="ribbon-menu-btn" data-section-target="view" onclick="setActiveRibbonSection('view')">表示</button>
                <button class="ribbon-menu-btn" data-section-target="work" onclick="setActiveRibbonSection('work')">作品</button>
                <button class="ribbon-menu-btn" data-section-target="tools" onclick="setActiveRibbonSection('tools')">ツール</button>
                <button class="ribbon-menu-btn" data-section-target="extensions" onclick="setActiveRibbonSection('extensions')">拡張</button>
                <button class="ribbon-menu-btn" data-section-target="help" onclick="setActiveRibbonSection('help')">ヘルプ</button>
            </nav>
        </div>
        <button class="btn ribbon-toggle" id="btn-ribbon-toggle" onclick="toggleRibbonContent()">▴ パネルをたたむ</button>
    </div>
    <div class="ribbon-section ribbon-home" data-section="home">
        <div class="ribbon-home-left">
            <button class="btn btn-undo" onclick="undoInput()" title="元に戻す">↩</button>
            <button class="btn btn-undo" onclick="redoInput()" title="やり直し">↪</button>
            <span class="ribbon-separator">|</span>
            <button class="btn panel-toggle" id="btn-toggle-search" onclick="toggleSearchPanel()" data-label="🔍 検索">
                <span class="panel-label">🔍 検索</span><span class="panel-state-icon">▾</span>
            </button>
            <span class="ribbon-separator">|</span>
            <div class="dropdown">
                <button class="btn dropdown-btn" onclick="toggleDropdown('insert-dropdown')">📝 挿入</button>
                <div id="insert-dropdown" class="dropdown-content">
                    <button onclick="insertText('――')">―― ダッシュ</button>
                    <button onclick="insertText('……')">…… 三点リーダー</button>
                    <button onclick="insertText('「」', 1)">「」 鉤括弧</button>
                    <button onclick="insertText('『』', 1)">『』 二重鉤括弧</button>
                    <button onclick="insertText('｜《》', 1)">｜《》 ルビ記法</button>
                    <button onclick="insertText('《《》》', 2)">《《》》 傍点記法</button>
                    <button onclick="insertText('__下線__', 2)">__下線__ 下線</button>
                    <button onclick="insertText('==強調==', 2)">==強調== 強調表示</button>
                    <button onclick="insertRubyToSelection()">🈂️ 選択文字にルビ</button>
                    <button onclick="insertBoutenToSelection()">⚫ 選択文字に傍点</button>
                </div>
            </div>
            <span class="ribbon-separator">|</span>
            <div class="ribbon-inline-slot" id="ribbon-inline-slot"></div>
        </div>
        <button class="btn ribbon-home-toggle" id="btn-ribbon-home-toggle" onclick="toggleRibbon()" title="リボン展開/たたむ">▴ リボンをたたむ</button>
    </div>
    <div class="ribbon-section ribbon-file" data-section="file">
        <div class="ribbon-group">
            <input type="file" id="file-input" accept=".txt" onchange="loadFile(this)">
            <input type="file" id="project-file-input" accept=".ccproj,.json" onchange="handleProjectFileLoad(this)">
            <div class="header-file-group">
                <div class="header-file-dropdown" id="text-file-dropdown">
                    <button class="btn btn-text-file" onclick="toggleTextFileDropdown()" title="テキストファイル">📄 テキスト ▾</button>
                    <div class="header-file-dropdown-content">
                        <div class="dropdown-item" onclick="openFileWithChoice(); closeAllFileDropdowns();">📂 開く</div>
                        <div class="dropdown-item" onclick="showTextSaveOptions(); closeAllFileDropdowns();">💾 保存</div>
                    </div>
                </div>
                <div class="header-file-dropdown" id="project-file-dropdown">
                    <button class="btn btn-project-file" onclick="toggleProjectFileDropdown()" title="プロジェクトファイル">📦 プロジェクト ▾</button>
                    <span class="header-menu-sep">｜</span>
                    <button class="btn btn-project-new" onclick="confirmStartNewProject(); closeAllFileDropdowns();" title="新規プロジェクト">🆕 新規プロジェクト</button>
                    <div class="header-file-dropdown-content">
                        <div class="dropdown-item" onclick="openProjectFile(); closeAllFileDropdowns();">📂 開く</div>
                        <div class="dropdown-item" onclick="openProjectSaveDialog(); closeAllFileDropdowns();">💾 保存</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="ribbon-section ribbon-work" data-section="work">
        <div class="ribbon-group">
            <button class="btn panel-toggle" id="btn-toggle-structure" onclick="toggleStructurePanel()" data-label="📋 構成">
                <span class="panel-label">📋 構成</span><span class="panel-state-icon">▾</span>
            </button>
            <button class="btn panel-toggle" id="btn-toggle-world" onclick="toggleWorldPanel()" data-label="🌍 世界観">
                <span class="panel-label">🌍 世界観</span><span class="panel-state-icon">▾</span>
            </button>
            <button class="btn panel-toggle" id="btn-toggle-character" onclick="toggleCharacterPanel()" data-label="👤 人物">
                <span class="panel-label">👤 人物</span><span class="panel-state-icon">▾</span>
            </button>
            
            <button class="btn panel-toggle" id="btn-toggle-terms" onclick="toggleTermsPanel()" data-label="📚 用語">
                <span class="panel-label">📚 用語</span><span class="panel-state-icon">▾</span>
            </button>
<button class="btn panel-toggle" id="btn-toggle-memo" onclick="toggleMemoPanel()" data-label="📝 メモ">
                <span class="panel-label">📝 メモ</span><span class="panel-state-icon">▾</span>
            </button>
            <button class="btn panel-toggle" id="btn-toggle-outline" onclick="toggleOutlinePanel()" data-label="📑 目次">
                <span class="panel-label">📑 目次</span><span class="panel-state-icon">▾</span>
            </button>
        </div>
    </div>
    <div class="ribbon-section ribbon-view" data-section="view">
        <div class="ribbon-group">
            <button class="btn" onclick="toggleLayoutAxis()">↕ 縦横切替</button>
            <button class="btn" id="btn-layout-swap" onclick="toggleLayoutOrder()">⇄ 入替</button>
            <span class="ribbon-separator">|</span>
            <button class="btn btn-view" onclick="openReaderView()" title="全タブをまとめて閲覧（Escで戻る）">👁 閲覧</button>
            <button class="btn btn-analysis" onclick="showAnalysis()">📊 分析</button>
            <button class="btn btn-focus" id="btn-focus" onclick="toggleFocusMode()">🧘 集中</button>
            <button class="btn btn-sync" id="btn-sync" onclick="syncPreviewPosition()">📲 同期</button>
        </div>
    </div>
    <div class="ribbon-section ribbon-tools" data-section="tools">
        <div class="ribbon-group">
            <button class="btn panel-toggle" id="btn-toggle-settings" onclick="togglePanel('settings-bar')" data-label="⚙️ 設定">
                <span class="panel-label">⚙️ 設定</span><span class="panel-state-icon">▾</span>
            </button>
        </div>
    </div>
    <div class="ribbon-section ribbon-extensions" data-section="extensions">
        <span class="ribbon-menu-item">🚧 開発中</span>
    </div>
    <div class="ribbon-section ribbon-help" data-section="help">
        <button class="btn panel-toggle" id="btn-toggle-help" onclick="togglePanel('help-bar')" data-label="❓ 使い方">
            <span class="panel-label">❓ 使い方</span><span class="panel-state-icon">▾</span>
        </button>
    </div>
</header>

<div id="app-context-menu" class="context-menu" role="menu" aria-label="アプリメニュー">
    <div class="context-menu-item" data-action="reset-all">💀 全体初期化</div>
</div>

<div class="controls-wrapper">
    <div id="help-bar" class="control-panel">
        <div class="panel-action-buttons">
            <button class="panel-pin-btn" onclick="togglePanelPin('help-bar')" title="固定">📌</button>
            <button class="panel-close-btn" onclick="closeControlPanel('help-bar')">✕</button>
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 16px;">
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【基本操作】</div>
                ・<b>入力エリア</b>：文章を入力<br>
                                ・<b>📲 同期</b>：カーソル位置にプレビュー移動<br>
                ・<b>👁 閲覧</b>：全タブをまとめて全画面表示（区切り記号「◆」付き / Escで戻る）<br>
                ・閲覧中は『縦書きへ/横書きへ』で書字方向を切替できます<br>
                ・終了は <b>Esc</b> または『↩ 元の画面に戻る』です<br>
                ・<b>縦横切替</b>：レイアウト変更<br>
                ・<b>入替</b>：ペインの順序を入れ替え
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【ショートカットキー】</div>
                ・<b>Ctrl+S</b>：保存ダイアログ<br>
                ・<b>Ctrl+F</b>：検索パネル<br>
                ・<b>Ctrl+G</b>：行番号ジャンプ<br>
                ・<b>Ctrl+Z</b>：元に戻す<br>
                ・<b>Ctrl+Y</b>：やり直し<br>
                ・<b>F11</b>：集中モード切替<br>
                ・<b>Esc</b>：ダイアログ閉じる
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【記法（小説向け）】</div>
                ・<b>ルビ</b>：｜漢字《かんじ》<br>
                ・<b>傍点</b>：《《強調》》<br>
                ・<b>傍線</b>：__下線__<br>
                <small>※テキスト選択時、ポップアップからワンクリックでルビ・傍点挿入可能</small>
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【執筆支援】</div>
                ・<b>🧘 集中モード</b>：UIを隠して執筆に集中<br>
                ・<b>タイプライター</b>：カーソル位置を中央に固定<br>
                ・<b>執筆時間トラッカー</b>：自動計測<br>
                ・<b>📊 分析</b>：文字種・文長・頻出語を分析
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【目標機能】</div>
                ・<b>全体目標</b>：作品全体の目標文字数<br>
                ・<b>今日の目標</b>：1日の執筆目標<br>
                ・目標達成時に🎉お祝いアニメーション表示<br>
                ・進捗に応じて色が変化
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【目次・ブックマーク】</div>
                ・<b>📑 目次</b>：見出し（■□▲など）を自動検出<br>
                ・<b>🔖 ブックマーク</b>：任意の位置を保存<br>
                ・クリックでその位置にジャンプ<br>
                ・📌固定で常に表示
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【保存・読込】</div>
                ・<b>💾 保存</b>：テキスト/HTML形式で保存<br>
                ・<b>📂 開く</b>：テキストファイルを読込（開く先を毎回選択：現在タブ/新規タブ）<br>
                ・設定の📤エクスポート/📥インポート
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【設定】</div>
                ・<b>フォント</b>：明朝・ゴシック・筆文字など<br>
                ・<b>縦書き/横書き</b>：切替可能<br>
                ・<b>テーマ</b>：ライト・ダーク・セピアなど<br>
                ・<b>原稿用紙換算</b>：枚数を自動計算
            </div>
        </div>
    </div>

    <div id="settings-bar" class="control-panel">
        <div class="panel-action-buttons">
            <button class="panel-pin-btn" onclick="togglePanelPin('settings-bar')" title="固定">📌</button>
            <button class="panel-close-btn" onclick="closeControlPanel('settings-bar')">✕</button>
        </div>
        <div class="setting-group">
            <div class="setting-title">入力エリア <button class="btn btn-apply" onclick="applyInputSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>文字: <input type="number" id="st-in-size" value="17" min="10" max="60"></label>
                <label>行間: <input type="number" id="st-in-line" value="1.7" step="0.1" min="1.0" max="5.0"></label>
                <label><input type="checkbox" id="st-in-v" checked> 縦書き</label>
                    <label>フォント: 
                    <select id="st-in-font">
                        <option value="font-gothic" selected>ゴシック</option>
                        <option value="font-mincho">明朝体</option>
                        <option value="font-old">アンティーク</option>
                        <option value="font-round">丸ゴシック</option>
                        <option value="font-brush">筆文字</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">プレビュー <button class="btn btn-apply" onclick="applyPreviewSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>文字: <input type="number" id="st-pv-size" value="17" min="10" max="60"></label>
                <label>行間: <input type="number" id="st-pv-line" value="1.7" step="0.1" min="1.0" max="5.0"></label>
                <label><input type="checkbox" id="st-pv-v" checked> 縦書き</label>
                    <label>フォント: 
                    <select id="st-pv-font">
                        <option value="font-gothic" selected>ゴシック</option>
                        <option value="font-mincho">明朝体</option>
                        <option value="font-old">アンティーク</option>
                        <option value="font-round">丸ゴシック</option>
                        <option value="font-brush">筆文字</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">表示オプション <button class="btn btn-apply" onclick="applyDisplaySettings()">適用</button></div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-show-space" checked> スペース可視化</label>
                <label><input type="checkbox" id="st-show-highlight" checked> ハイライト</label>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="check-show-input" checked> 入力表示</label>
                <label><input type="checkbox" id="check-show-preview" checked> プレビュー表示</label>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-default-preview-hidden"> 起動時プレビュー非表示</label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">執筆支援 <button class="btn btn-apply" onclick="applyWritingSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label><input type="checkbox" id="st-typewriter-mode"> タイプライター</label>
                <label><input type="checkbox" id="st-writing-tracker" checked> 時間トラッカー</label>
            </div>
            <div class="setting-row" id="writing-time-display" style="color: #8b5cf6; font-weight: bold;">執筆時間: 00:00:00</div>
        </div>

        <div class="setting-group">
            <div class="setting-title">目標・統計 <button class="btn btn-apply" onclick="applyGoalSettings()">適用</button></div>
            <div class="setting-row">
                <label>全体目標: <input type="number" id="st-goal-chars" value="150000" min="0" max="999999" style="width:70px;"> 字</label>
            </div>
            <div class="setting-row">
                <label>今日の目標: <input type="number" id="st-today-goal" value="2000" min="0" max="99999" style="width:60px;"> 字</label>
            </div>
            <div class="setting-row">
                <button class="btn btn-apply" onclick="resetTodayStart()" style="font-size:0.65rem;">開始点リセット</button>
            </div>
            <div class="setting-row">
              <label>「今日」の開始時刻: 
                <input id="st-day-start" type="time" list="day-start-presets" value="00:00" style="width:120px;">
              </label>
              <datalist id="day-start-presets">
                <option value="00:00"></option><option value="01:00"></option><option value="02:00"></option>
                <option value="03:00"></option><option value="04:00"></option><option value="05:00"></option><option value="06:00"></option>
              </datalist>
              <button class="btn btn-apply" onclick="applyExtendedSettings()" style="font-size:0.65rem;">適用</button>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-show-reading-time" checked> 読み上げ時間</label>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-celebrate-goal" checked> 目標達成時にお祝い表示</label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">用紙設定 <button class="btn btn-apply" onclick="applyPaperSettings()">適用</button></div>
            <div class="setting-row vertical">
                <div>行: <input type="number" id="st-manuscript-rows" value="34" min="1" max="100" style="width:50px;"> ×文字: <input type="number" id="st-manuscript-cols" value="42" min="1" max="100" style="width:50px;"></div>
                <label><input type="checkbox" id="st-show-manuscript" checked> 換算表示</label>
                <label>テーマ:
                    <select id="st-theme-preset">
                        <option value="">ライト</option>
                        <option value="theme-dark">ダーク</option>
                        <option value="theme-sepia">セピア</option>
                        <option value="theme-blue">ブルー</option>
                        <option value="theme-green">グリーン</option>
                    </select>
                </label>
                <label>文字色:
                    <span style="display:inline-flex; align-items:center; gap:6px;">
                        <input type="color" id="st-text-color" value="#1f2937" style="width:44px; height:28px;">
                        <input type="text" id="st-text-color-text" placeholder="#RRGGBB" style="width:96px;">
                    </span>
                </label>
            </div>

            <div class="setting-row">
                <label>固定パネル上限:
                    <select id="st-max-pinned-panels">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4" selected>4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                    
                        <option value="8">8</option></select>
                </label>
            </div>

        </div>

        <div class="setting-group">
            <div class="setting-title">開く <button class="btn btn-apply" onclick="applyOpenSettingsAndSave()">適用</button></div>
            <div class="setting-row vertical">
                <label><input type="radio" name="st-open-mode" value="current" checked > 現在のタブに開く</label>
                <label><input type="radio" name="st-open-mode" value="new" > 新しいタブに開く</label>
            </div>
        </div>

        <!-- 目次抽出ルールは目次パネルの⚙ボタンから設定可能 -->

        <div class="setting-group">
            <div class="setting-title">ペイン幅 <button class="btn btn-apply" onclick="applyPaneWidthSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>入力: <input type="number" id="st-pane-input-width" value="520" min="120" max="3000" style="width:70px;">px</label>
                <label>プレビュー: <input type="number" id="st-pane-preview-width" value="520" min="120" max="3000" style="width:70px;">px</label>
                                <label>サイド: <input type="number" id="st-pane-side-width" value="300" min="160" max="1200" style="width:70px;">px</label>
<label class="st-hide-pane-width">メモ: <input type="number" id="st-pane-memo-width" value="260" min="160" max="1200" style="width:70px;">px</label>
                <label class="st-hide-pane-width">目次: <input type="number" id="st-pane-outline-width" value="260" min="160" max="1200" style="width:70px;">px</label>
                <label class="st-hide-pane-width">構成: <input type="number" id="st-pane-structure-width" value="300" min="160" max="1200" style="width:70px;">px</label>
                <label>検索: <input type="number" id="st-pane-search-width" value="320" min="160" max="1200" style="width:70px;">px</label>
                <label class="st-hide-pane-width">登場人物: <input type="number" id="st-pane-character-width" value="300" min="160" max="1200" style="width:70px;">px</label>
                <label class="st-hide-pane-width">世界観: <input type="number" id="st-pane-world-width" value="300" min="160" max="1200" style="width:70px;">px</label>
                <label class="st-hide-pane-width">用語: <input type="number" id="st-pane-terms-width" value="300" min="160" max="1200" style="width:70px;">px</label>
                <label>仕切り幅: <input type="number" id="st-divider-width" value="2" min="1" max="12" style="width:70px;" onchange="applyDividerSettings()">px</label>
            </div>
            <div class="setting-row">
                <button class="btn btn-apply" onclick="resetPaneWidths()" style="font-size:0.65rem;">全幅リセット</button>
                <button class="btn btn-apply" onclick="resetDividerWidth()" style="font-size:0.65rem;">仕切り初期化</button>
                </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">保存 <button class="btn btn-apply" onclick="applyAutoSaveSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label><input type="checkbox" id="st-autosave-enabled" onchange="applyAutoSaveSettings()"> 自動保存を有効にする</label>
                <label>自動保存間隔: <input type="number" id="st-autosave-interval" value="60" min="5" max="600" style="width:70px;" onchange="applyAutoSaveSettings()"> 秒</label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">縦並び高さ <button class="btn btn-apply" onclick="applyPaneHeightSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>入力: <input type="number" id="st-pane-input-height" value="520" min="160" max="2000" style="width:70px;">px</label>
                <label>プレビュー: <input type="number" id="st-pane-preview-height" value="520" min="160" max="2000" style="width:70px;">px</label>
            </div>
            <div class="setting-row">
                <button class="btn btn-apply" onclick="resetPaneHeights()" style="font-size:0.65rem;">高さをリセット</button>
            </div>
        </div>

        <div class="setting-group settings-actions">
            <div class="settings-actions-row">
                <div class="dropdown settings-dropdown">
                    <button class="btn settings-action-btn dropdown-btn" onclick="toggleDropdown('settings-transfer-dropdown')">📦 設定の移行</button>
                    <div id="settings-transfer-dropdown" class="dropdown-content">
                        <button onclick="exportSettings()">📤 設定をエクスポート</button>
                        <button onclick="document.getElementById('settings-file-input').click()">📥 設定をインポート</button>
                    </div>
                </div>
                <button class="btn settings-action-btn" onclick="resetAllSettings()" style="font-size:0.7rem; background:#fee2e2; color:#dc2626; border-color:#fecaca;">🔄 設定を初期化</button>
                <button class="btn btn-apply-all settings-action-btn" onclick="applyAllSettings()">⚡ 一括適用</button>
            </div>
            <input type="file" id="settings-file-input" accept=".json" onchange="importSettings(this)" style="display:none;">
        </div>
    </div>
</div>

<div class="main-container outline-left" id="main-container">
    <div class="pane-stack" id="pane-stack">
        <div class="pane" id="pane-input">
            <div class="pane-header">
        <div class="pane-title">
            <h2><span class="novel-title-name" id="novel-title" ondblclick="startEditNovelTitle()" title="ダブルクリックで作品名を変更">ここにプロジェクトタイトルを入力してください。</span></h2>
            <span class="pane-total-stats" id="input-total-stats">全タブ: 0字 / 0行</span>
        </div>
                <div class="pane-actions">
                    <button class="pane-layout-btn" id="btn-input-writing-mode" onclick="toggleInputWritingMode()" title="書字方向切替">横書きへ</button>
                    <button class="pane-close-btn" onclick="hidePane('input')">✕</button>
                </div>
            </div>
            <div class="tabs-scroll-wrap" id="input-tabs-wrap">
                <button class="tab-scroll-btn left" type="button" aria-label="タブを左へ" data-target="input-tabs-container">◀</button>
                <div class="input-tabs-container" id="input-tabs-container">
                    <!-- Tabs will be dynamically generated -->
                </div>
                <button class="tab-scroll-btn right" type="button" aria-label="タブを右へ" data-target="input-tabs-container">▶</button>
            </div>
            <div class="pane-subheader" id="input-pos-bar">現在: 1 行目</div>
            <div class="pane-body">
                <div id="input-mirror-container"></div>
                <textarea id="input-area" spellcheck="false"></textarea>
                <div id="input-sel-overlay" class="selection-overlay"></div>
            </div>
            <div class="pane-footer">
                <span id="char-count">全体: 0</span>
                <span id="input-net-count" class="net-count">実質: 0</span>
                <span id="line-count">0 行</span>
                <span id="input-goal-display" class="goal-display"></span>
                <span id="input-today-goal" class="today-goal"></span>
                <span id="input-writing-time" class="writing-time"></span>
                <span id="input-reading-time" class="reading-time"></span>
                <span id="input-manuscript" class="manuscript-pages"></span>
            </div>
        </div>

        <div class="pane-resizer" id="resizer-input-preview"></div>

        <div class="pane" id="pane-preview">
            <div class="pane-header">
                <div class="pane-title">
                    <h2>プレビュー</h2>
                    <span class="pane-total-stats" id="preview-total-stats">全タブ: 0字 / 0行</span>
                </div>
                <div class="pane-actions">
                    <button class="pane-layout-btn" id="btn-preview-writing-mode" onclick="togglePreviewWritingMode()" title="書字方向切替">横書きへ</button>
                    <button class="pane-close-btn" onclick="hidePane('preview')">✕</button>
                </div>
            </div>
            <div class="tabs-scroll-wrap" id="preview-tabs-wrap">
                <button class="tab-scroll-btn left" type="button" aria-label="タブを左へ" data-target="preview-tabs-container">◀</button>
                <div class="preview-tabs-container" id="preview-tabs-container">
                    <!-- Preview tabs will be dynamically generated -->
                </div>
                <button class="tab-scroll-btn right" type="button" aria-label="タブを右へ" data-target="preview-tabs-container">▶</button>
            </div>
            <div class="pane-subheader" id="preview-pos-bar">位置: 0%</div>
            <div class="pane-body">
                <div id="preview-scroll">
                    <div id="preview-content"></div>
                </div>
                <div id="preview-sel-overlay" class="selection-overlay"></div>
            </div>
            <div class="pane-footer">
                <span id="pv-time" class="timestamp">未更新</span>
                <span style="border-left:1px solid var(--border-color); height:12px; margin:0 5px;"></span>
                <span id="pv-total-count">全体: 0</span>
                <span id="pv-net-count" class="net-count">実質: 0</span>
                <span id="pv-line-count">0 行</span>
                <span id="pv-goal-display" class="goal-display"></span>
                <span id="pv-today-goal" class="today-goal"></span>
                <span id="pv-reading-time" class="reading-time"></span>
                <span id="pv-manuscript" class="manuscript-pages"></span>
            </div>
        </div>
    </div>

<!-- Independent Search Panel -->
<div id="search-panel" style="display:none;">
  <div class="search-header panel-drag-handle" data-panel-id="search-panel" draggable="true" style="display:flex; justify-content:space-between; align-items:center; padding: 8px 10px; background: var(--pane-search-head, var(--pane-header-bg)); border-bottom: 1px solid var(--border-color); font-weight:bold; font-size:0.85rem; flex-wrap:wrap; gap:4px;">
    <span>🔍 検索</span>
    <div class="search-controls" style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
      <button id="btn-search-swap" class="btn panel-swap-btn" onclick="swapSearchSide()">左右入替</button>
      <button class="panel-pin-btn" id="btn-search-pin" onclick="toggleSearchDockPin()" title="固定/浮動切り替え">📌</button>
      <input type="checkbox" id="check-search-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('search')">
      <button class="panel-close-btn" onclick="closeSearchPanel()" style="background:none; border:none; cursor:pointer;">✖</button>
    </div>
  </div>
  <div class="search-body" style="padding:10px; display:flex; flex-direction:column; gap:8px; flex:1; overflow:auto;">
    <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center;">
      <input type="text" id="search-input" placeholder="検索ワード..." style="flex:1; min-width:120px; padding:6px 10px; border:1px solid var(--border-color); border-radius:6px; background:var(--panel-bg); color:var(--text-color);" onkeydown="if(event.key==='Enter') doSearch()">
      <select id="search-scope" style="height:32px; border-radius:6px; border:1px solid var(--border-color); padding:0 6px; background:var(--panel-bg); color:var(--text-color);">
        <option value="current">このタブ</option>
        <option value="all">全タブ</option>
      </select>
    </div>
    <div style="display:flex; gap:6px; flex-wrap:wrap;">
      <button class="btn btn-search-exec" onclick="doSearch()">検索</button>
      <button class="btn" onclick="findPrev()">▲ 前へ</button>
      <button class="btn" onclick="findNext()">▼ 次へ</button>
      <button class="btn btn-search-reset" onclick="resetSearchPanel()">リセット</button>
      <span id="search-match-info" style="font-size:0.85rem; color:var(--text-muted);">0 / 0</span>
    </div>
    <div style="display:flex; gap:6px; align-items:center; padding-top:6px; border-top:1px solid var(--border-color);">
      <input type="text" id="replace-input" placeholder="置換後..." style="flex:1; min-width:100px; padding:6px 10px; border:1px solid var(--border-color); border-radius:6px; background:var(--panel-bg); color:var(--text-color);">
      <button class="btn" onclick="replaceOne()">置換</button>
      <button class="btn" onclick="replaceAll()">全置換</button>
    </div>
    <div id="search-hits" style="flex:1; overflow:auto; border:1px solid var(--border-color); border-radius:6px; padding:6px; min-height:100px; background:var(--bg-color);"></div>
  </div>
</div>
<div id="resizer-search" class="dock-resizer" style="display:none;" title="検索パネルの幅を調整します"></div>

<div id="memo-panel">
  <div class="memo-header panel-drag-handle" data-panel-id="memo-panel" draggable="true" style="display:flex; justify-content:space-between; align-items:center; padding: 8px 10px; background: var(--pane-memo-head, var(--pane-header-bg)); border-bottom: 1px solid var(--border-color); font-weight:bold; font-size:0.85rem; flex-wrap:wrap; gap:4px;">
    <span style="font-family: var(--font-ui);">📝 メモ</span>
    <div class="memo-controls" style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
<button id="btn-memo-swap" class="btn panel-swap-btn" onclick="swapMemoSide()">左右入替</button>
<button class="panel-pin-btn" id="btn-memo-pin" onclick="toggleMemoDockPin()" title="固定/浮動切り替え">📌</button>
<input type="checkbox" id="check-memo-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('memo')">
      <button class="btn structure-fullscreen-btn" onclick="toggleMemoFullscreen()">⛶</button>
      <button class="panel-close-btn" onclick="closeMemoPanel(true)" style="background:none; border:none; cursor:pointer;">✖</button>
    </div>
  </div>



    <div class="memo-toolbar" style="background: var(--bg-color); padding: 4px 4px 0 4px; border-bottom: 1px solid var(--border-color);">
        <div class="tabs-scroll-wrap memo-tabs-wrap" id="memo-tabs-wrap">
            <button class="tab-scroll-btn left" type="button" aria-label="メモタブを左へ" data-target="memo-tabs-container">◀</button>
            <div id="memo-tabs-container" class="memo-tabs"></div>
            <button class="tab-scroll-btn right" type="button" aria-label="メモタブを右へ" data-target="memo-tabs-container">▶</button>
        </div>
    </div>

    <textarea id="memo-area" placeholder="ここに入力..." oninput="updateMemoCharCount(); saveMemoTabs()" style="flex: 1; width: 100%; resize: none; border: none; padding: 8px; font-family: inherit; box-sizing: border-box; outline: none;"></textarea>
    
    <div class="memo-footer" style="padding: 2px 8px; font-size: 0.75rem; color: var(--text-muted); border-top: 1px solid var(--border-color); display:flex; justify-content:space-between;">
        <span id="memo-char-count">0字</span>
        <div class="memo-file-btns" style="display:flex; gap:4px;">
            <button onclick="openMemoImportDialog()" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">📂 開く</button>
            <button onclick="showSaveFormatMenu(event,'memo')" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">💾 保存</button>
</div>
    </div>
</div>
<div id="resizer-memo" class="dock-resizer" title="(左境界) プレビューとメモの幅を調整します"></div>

<div id="structure-panel">
    <div class="structure-header panel-drag-handle" data-panel-id="structure-panel" draggable="true">
        <span>📋 構成</span>
        <div class="structure-controls">
            <button id="btn-structure-swap" class="btn panel-swap-btn" onclick="swapStructureSide()">左右入替</button>
            <button class="panel-pin-btn" id="btn-structure-pin" onclick="toggleStructureDockPin()" title="固定/浮動切り替え">📌</button>
            <input type="checkbox" id="check-structure-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('structure')">
            <button class="panel-close-btn" onclick="closeStructurePanel(true)">✕</button>
        </div>
    </div>
    <div class="structure-toolbar">
        <select id="structure-add-level" style="padding:4px 6px; border:1px solid var(--border-color); border-radius:6px; background:var(--panel-bg); color:var(--text-color); font-size:0.75rem;">
            <option value="chapter">章</option>
            <option value="episode">話</option>
            <option value="scene">シーン</option>
        </select>
        <button class="btn" onclick="createStructureCardFromSelection()">＋新しいカード</button>
        <button class="btn btn-update" onclick="refreshStructurePanel()">更新</button>
        <button class="btn" id="btn-structure-bulk-up" onclick="expandAllStructure()" title="一括で最大まで展開します">全展開</button>
        <button class="btn" id="btn-structure-bulk-down" onclick="collapseAllStructure()" title="一括で表示段階を下げます（4段階）">全折畳</button>
        <button class="btn" onclick="deleteSelectedStructureCards()">選択削除</button>
        <button class="btn" onclick="deleteAllStructureCards()">全削除</button>
        <button class="btn structure-fullscreen-btn" onclick="toggleStructureFullscreen()">⛶</button>
    </div>
    <div class="structure-content">
        <div class="structure-list" id="structure-list"></div>
    </div>
    <div class="structure-footer" style="padding: 2px 8px; font-size: 0.75rem; color: var(--text-muted); border-top: 1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center; background: var(--pane-structure-head, #e0e7ff);">
        <span id="structure-count">0件</span>
        <div style="display:flex; gap:4px;">
            <button onclick="openStructureImportDialog()" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">📂 開く</button>
            <button onclick="showSaveFormatMenu(event,'structure')" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">💾 保存</button>
</div>
    </div>
</div>
<div id="resizer-structure" class="dock-resizer" title="構成パネルの幅を調整します"></div>

<!-- 登場人物パネル -->
<div id="character-panel">
    <div class="character-header panel-drag-handle" data-panel-id="character-panel" draggable="true">
        <span>👤 登場人物</span>
        <div class="character-controls">
            <button id="btn-character-swap" class="btn panel-swap-btn" onclick="swapCharacterSide()">左右入替</button>
            <button class="panel-pin-btn" id="btn-character-pin" onclick="toggleCharacterDockPin()" title="固定/浮動切り替え">📌</button>
            <input type="checkbox" id="check-character-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('character')">
            <button class="panel-close-btn" onclick="closeCharacterPanel(true)">✕</button>
        </div>
    </div>
    <div class="character-toolbar">
        <select id="character-add-role" style="padding:4px 6px; border:1px solid var(--border-color); border-radius:6px; background:var(--panel-bg); color:var(--text-color); font-size:0.75rem;">
            <option value="protagonist">主人公</option>
            <option value="heroine">ヒロイン</option>
            <option value="antagonist">敵役</option>
            <option value="supporting">サブ</option>
            <option value="mob">モブ</option>
        </select>
        <button class="btn" onclick="createCharacterCardFromSelection()">＋新しいカード</button>
        <button class="btn btn-update" onclick="refreshCharacterPanel()">更新</button>
        <button class="btn" id="btn-character-bulk-up" onclick="expandAllCharacter()" title="一括で最大まで展開します">全展開</button>
        <button class="btn" id="btn-character-bulk-down" onclick="collapseAllCharacter()" title="一括で表示段階を下げます（4段階）">全折畳</button>
        <button class="btn" onclick="deleteSelectedCharacterCards()">選択削除</button>
        <button class="btn" onclick="deleteAllCharacterCards()">全削除</button>
        <button class="btn structure-fullscreen-btn" onclick="toggleCharacterFullscreen()">⛶</button>
    </div>
    <div class="character-content">
        <div class="character-list" id="character-list"></div>
    </div>
    <div class="character-footer" style="padding: 2px 8px; font-size: 0.75rem; color: var(--text-muted); border-top: 1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center; background: var(--pane-character-head, #fce7f3);">
        <span id="character-count">0人</span>
        <div style="display:flex; gap:4px;">
            <button onclick="openCharacterImportDialog()" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">📂 開く</button>
            <button onclick="showSaveFormatMenu(event,'character')" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">💾 保存</button>
</div>
    </div>
</div>
<div id="resizer-character" class="dock-resizer" title="登場人物パネルの幅を調整します"></div>

<!-- 世界観パネル -->
<div id="world-panel">
    <div class="world-header panel-drag-handle" data-panel-id="world-panel" draggable="true">
        <span>🌍 世界観</span>
        <div class="world-controls">
            <button id="btn-world-swap" class="btn panel-swap-btn" onclick="swapWorldSide()">左右入替</button>
            <button class="panel-pin-btn" id="btn-world-pin" onclick="toggleWorldDockPin()" title="固定/浮動切り替え">📌</button>
            <input type="checkbox" id="check-world-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('world')">
            <button class="panel-close-btn" onclick="closeWorldPanel(true)">✕</button>
        </div>
    </div>
    <div class="world-toolbar">
        <select id="world-add-level" style="padding:4px 6px; border:1px solid var(--border-color); border-radius:6px; background:var(--panel-bg); color:var(--text-color); font-size:0.75rem;">
            <option value="major">大カテゴリ</option>
            <option value="middle">中カテゴリ</option>
            <option value="detail">詳細項目</option>
        </select>
        <button class="btn" onclick="createWorldCardFromSelection()">＋新しいカード</button>
        <button class="btn btn-update" onclick="refreshWorldPanel()">更新</button>
        <button class="btn" id="btn-world-bulk-up" onclick="expandAllWorld()" title="一括で最大まで展開します">全展開</button>
        <button class="btn" id="btn-world-bulk-down" onclick="collapseAllWorld()" title="一括で表示段階を下げます（4段階）">全折畳</button>
        <button class="btn" onclick="deleteSelectedWorldCards()">選択削除</button>
        <button class="btn" onclick="deleteAllWorldCards()">全削除</button>
        <button class="btn structure-fullscreen-btn" onclick="toggleWorldFullscreen()">⛶</button>
    </div>
    <div class="world-content">
        <div class="world-list" id="world-list"></div>
    </div>
    <div class="world-footer" style="padding: 2px 8px; font-size: 0.75rem; color: var(--text-muted); border-top: 1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center; background: var(--pane-world-head, #d1fae5);">
        <span id="world-count">0件</span>
        <div style="display:flex; gap:4px;">
            <button onclick="openWorldImportDialog()" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">📂 開く</button>
            <button onclick="showSaveFormatMenu(event,'world')" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">💾 保存</button>
</div>
    </div>
</div>
<div id="resizer-world" class="dock-resizer" title="世界観パネルの幅を調整します"></div>

<!-- 用語パネル -->
<div id="terms-panel">
    <div class="terms-header panel-drag-handle" data-panel-id="terms-panel" draggable="true">
        <span>📚 用語</span>
        <div class="terms-controls">
            <button id="btn-terms-swap" class="btn panel-swap-btn" onclick="swapTermsSide()">左右入替</button>
            <button class="panel-pin-btn" id="btn-terms-pin" onclick="toggleTermsDockPin()" title="固定/浮動切り替え">📌</button>
            <input type="checkbox" id="check-terms-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('terms')">
            <button class="panel-close-btn" onclick="closeTermsPanel(true)">✕</button>
        </div>
    </div>
    <div class="terms-toolbar">
        <button class="btn" onclick="createTermsCard()">＋新しいカード</button>
        <button class="btn btn-update" onclick="refreshTermsPanel()">更新</button>
        <button class="btn" onclick="expandAllTerms()">全展開 +◆</button>
        <button class="btn" onclick="collapseAllTerms()">全折畳 -◆</button>
        <button class="btn" onclick="deleteSelectedTerms()">選択削除</button>
        <button class="btn" onclick="deleteAllTerms()">全削除</button>
        <button class="btn structure-fullscreen-btn" onclick="toggleTermsFullscreen()">⛶</button>
    </div>
    <div class="terms-content">
        <div id="terms-list" class="terms-list"></div>
    </div>
    <div class="terms-footer" style="padding: 2px 8px; font-size:0.75rem; border-top:1px solid var(--border-color); display:flex; justify-content:space-between; align-items:center; background:var(--panel-bg);">
        <span id="terms-count">0語</span>
        <div class="terms-file-btns" style="display:flex; gap:4px;">
            <button onclick="openTermsImportDialog()" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">📂 開く</button>
            <button onclick="showSaveFormatMenu(event,'terms')" style="font-size:0.7rem; cursor:pointer; padding:2px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--panel-bg);">💾 保存</button>
</div>
    </div>
</div>
<div id="resizer-terms" class="dock-resizer" title="用語パネルの幅を調整します"></div>



    <div class="dock-resizer" id="resizer-memo-outline" title="(右境界) Alt+ドラッグでメモと目次の配分を調整します"></div>
    <div id="outline-panel">
        <div class="outline-header panel-drag-handle" data-panel-id="outline-panel" draggable="true">
            <span>📑 目次</span>
            <div class="outline-controls">
                <button id="btn-outline-settings" class="btn" onclick="toggleOutlineSettings()" title="抽出ルール設定" style="padding:2px 6px; font-size:0.75rem;">⚙</button>
                <button id="btn-outline-swap" class="btn panel-swap-btn" onclick="swapOutlineSide()">左右入替</button>
                <input type="checkbox" id="check-outline-dock" class="dock-pin-checkbox" onchange="onDockCheckboxChange('outline')">
                <button class="panel-pin-btn" id="btn-outline-pin" onclick="toggleOutlineDockPin()" title="固定">📌</button>
                <button class="panel-close-btn" onclick="closeOutlinePanel()">✕</button>
            </div>
        </div>
        <div class="outline-toolbar" style="display:flex; padding:4px 8px; background:var(--pane-outline-head, var(--pane-header-bg)); border-bottom:1px solid var(--border-color); gap:4px; align-items:center;">
            <div class="nav-jump-controls" title="ジャンプ履歴"><button id="btn-nav-back" class="nav-jump-btn" type="button" aria-label="戻る">◀</button><button id="btn-nav-forward" class="nav-jump-btn" type="button" aria-label="進む">▶</button></div><div class="outline-tabs-inner" style="display:flex; gap:2px; flex:1;">
                <span class="memo-tab active" onclick="switchOutlineTab('outline')" style="cursor:pointer;">目次</span>
                <span class="memo-tab" onclick="switchOutlineTab('bookmark')" style="cursor:pointer;">🔖しおり</span>
            </div>
        </div>
        <!-- Outline extraction rules settings overlay -->
        <div id="outline-settings-overlay" style="display:none; position:absolute; top:80px; left:10px; right:10px; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; padding:12px; z-index:100; box-shadow:0 4px 12px rgba(0,0,0,0.15);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <span style="font-weight:bold;">目次抽出ルール</span>
                <button onclick="toggleOutlineSettings()" style="background:none; border:none; cursor:pointer; font-size:1.1rem;">✕</button>
            </div>
            <div id="outline-rules-container" style="display:flex; flex-wrap:wrap; gap:8px; margin-bottom:10px;">
                <label><input type="checkbox" id="or-use-hash" checked> #</label>
                <label><input type="checkbox" id="or-use-box" checked> ■□</label>
                <label><input type="checkbox" id="or-use-tri" checked> ▲</label>
                <label><input type="checkbox" id="or-use-dia" checked> ◆</label>
                <label><input type="checkbox" id="or-use-cir" checked> ○</label>
                <label><input type="checkbox" id="or-use-chapter" checked> 第○章</label>
                <label><input type="checkbox" id="or-use-circnum" checked> ①</label>
                <label><input type="checkbox" id="or-use-roman" checked> Ⅰ</label>
            </div>
            <div style="margin-bottom:8px;">
                <label>追加記号 (例: ★●◎ など):
                    <input type="text" id="or-extra" placeholder="任意" style="width:100px; padding:2px 6px; border:1px solid var(--border-color); border-radius:4px;">
                </label>
            </div>
            <div style="font-size:0.78rem; color:var(--text-muted); margin-bottom:10px;">チェックされたパターンから、行頭の見出しを抽出します。</div>
            <button class="btn btn-apply" onclick="applyOutlineRulesFromOverlay()">適用</button>
        </div>
        <div class="outline-content">
            <div id="outline-tab-outline" class="outline-tab-content active">
                <div style="margin-bottom:8px; display:flex; gap:4px; flex-wrap:wrap;">
                    <button class="btn" style="padding:2px 6px; font-size:0.7rem;" onclick="generateOutline()">🔄更新</button>
                    <button class="btn" style="padding:2px 6px; font-size:0.7rem;" onclick="expandAllOutline()">全展開</button>
                    <button class="btn" style="padding:2px 6px; font-size:0.7rem;" onclick="collapseAllOutline()">全折畳</button>
                </div>
                <div id="outline-list"></div>
            </div>
            <div id="outline-tab-bookmark" class="outline-tab-content">
                <button class="bookmark-add-btn" onclick="addBookmark()">＋ 現在位置にブックマークを追加</button>
                <div id="bookmark-actions" style="display:none; margin-bottom: 8px; padding: 4px; background: #fef3c7; border-radius: 4px;">
                    <label style="font-size: 0.8rem; cursor: pointer;"><input type="checkbox" id="bookmark-select-all" onchange="toggleAllBookmarks()"> 全選択</label>
                    <button onclick="deleteSelectedBookmarks()" style="margin-left: 8px; padding: 2px 8px; font-size: 0.75rem; background: #fee2e2; border: 1px solid #fecaca; border-radius: 4px; cursor: pointer;">🗑 選択削除</button>
                </div>
                <div id="bookmark-list"></div>
            </div>
        </div>
        <div id="outline-summary" class="outline-summary"></div>
    </div>

    <div class="dock-resizer" id="resizer-outline" title="目次の幅を調整します"></div>
</div>

<div class="focus-exit-hint">ESCキーで集中モードを解除</div>
<button class="focus-exit-btn" onclick="toggleFocusMode()" title="集中モードを解除">✕</button>

<div id="celebration-overlay" class="celebration-overlay"></div>
<div id="celebration-message" class="celebration-message">
    <span class="emoji">🎉</span>
    <span id="celebration-text">やったね！</span>
    <span class="sub" id="celebration-sub"></span>
</div>

<div id="quick-insert-popup" class="quick-insert-popup">
    <button class="qip-ruby" onclick="quickInsertRuby()">🔤ルビ</button>
    <button class="qip-bouten" onclick="quickInsertBouten()">⚫傍点</button>
    <button onclick="quickWrapSelection('「', '」')">「」</button>
    <button onclick="quickWrapSelection('『', '』')">『』</button>
    <button onclick="quickWrapSelection('（', '）')">（）</button>
    <button style="color:#d97706;" onclick="quickAddBookmark()">🔖しおり</button>
</div>

<div id="save-dialog-overlay" class="save-dialog-overlay" style="display:none;">
    <div class="save-dialog">
        <h3>保存形式を選択</h3>
        <div style="margin-bottom: 15px; font-size: 0.85rem;">
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="save-scope" value="current" checked> 現在のタブのみ
            </label>
            <label style="display: block;">
                <input type="radio" name="save-scope" value="all"> 全タブを結合（章区切り付き）
            </label>
        </div>
        <div class="save-dialog-buttons">
            <button class="btn" onclick="saveAsText()">📄 テキスト</button>
            <button class="btn" onclick="saveAsHTML()">🌐 HTML</button>
            <button class="btn" onclick="closeSaveDialog()">キャンセル</button>
        </div>
    </div>
</div>

<div id="pinned-limit-overlay" class="pinned-limit-overlay">
  <div class="pinned-limit-dialog">
    <h3 id="pinned-limit-title">固定パネル上限に達しています</h3>
    <p id="pinned-limit-message">固定を入れ替える対象を選んでください。</p>
    <div class="row">
      <select id="pinned-limit-select"></select>
    </div>
    <div class="btns">
      <button class="btn" id="pinned-limit-cancel" onclick="__ccHandlePinnedDialogCancel()">キャンセル</button>
      <button class="btn btn-primary" id="pinned-limit-ok" onclick="__ccHandlePinnedDialogOk()">入れ替える</button>
    </div>
  </div>
</div>



<div id="memo-save-dialog" class="save-dialog-overlay" style="display:none;">
    <div class="save-dialog" style="background:#fefce8;">
        <h3>📝 メモを保存</h3>
        <div style="margin-bottom: 15px; font-size: 0.85rem;">
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="memo-save-scope" value="current" checked> 現在のタブのみ
            </label>
            <label style="display: block;">
                <input type="radio" name="memo-save-scope" value="all"> 全タブを結合
            </label>
        </div>
        <div class="save-dialog-buttons">
            <button class="btn" onclick="executeMemoSave()">💾 保存</button>
            <button class="btn" onclick="closeMemoSaveDialog()">キャンセル</button>
        </div>
    </div>
</div>

<div id="project-save-dialog" class="save-dialog-overlay" style="display:none;">
    <div class="save-dialog" style="max-width:400px;">
        <h3>📦 プロジェクト保存</h3>
        <p style="font-size:0.8rem; color:var(--text-muted); margin-bottom:12px;">保存する項目を選択してください</p>
        <div style="margin-bottom: 15px; font-size: 0.85rem; max-height:200px; overflow-y:auto;">
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-text" checked> 入力テキスト（全タブ）</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-memo" checked> メモ（全タブ）</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-structure" checked> 構成</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-character" checked> 登場人物</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-world" checked> 世界観</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-terms" checked> 用語</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-bookmarks" checked> しおり</label>
            <label style="display: block; margin-bottom: 5px;"><input type="checkbox" id="proj-save-settings" checked> 設定（ペイン幅・色など）</label>
        </div>
        <div id="proj-save-newproject-hint" style="display:none; margin: 0 0 10px 0; font-size:0.78rem; color:var(--text-muted);">
            新規プロジェクトを開始する前にバックアップを推奨します。必要なら「保存して新規開始」を押してください。
        </div>
        <div class="save-dialog-buttons">
            <button class="btn btn-save" id="btn-proj-save" onclick="executeProjectSave()">💾 保存</button>
            <button class="btn btn-save" id="btn-proj-save-and-new" style="display:none;" onclick="executeProjectSaveAndContinueNewProject()">💾 保存して新規開始</button>
            <button class="btn" id="btn-proj-skip-and-new" style="display:none;" onclick="skipProjectSaveAndContinueNewProject()">保存せず新規開始</button>
            <button class="btn" id="btn-proj-cancel" onclick="closeProjectSaveDialog()">キャンセル</button>
        </div>
    </div>
</div>

<!-- パネル別インポートダイアログ -->
<div id="panel-import-dialog" class="import-dialog-overlay">
    <div class="import-dialog">
        <h3 id="panel-import-title">📂 データを開く</h3>
        <p style="font-size:0.8rem; color:var(--text-muted); margin-bottom:12px;">既存データとの扱いを選択してください</p>
        <div class="import-options">
            <label class="import-option selected" data-value="overwrite">
                <input type="radio" name="import-mode" value="overwrite" checked>
                <div class="import-option-content">
                    <strong>🔄 上書き</strong>
                    <span style="font-size:0.75rem; color:var(--text-muted);">既存データを置き換える</span>
                </div>
            </label>
            <label class="import-option" data-value="merge">
                <input type="radio" name="import-mode" value="merge">
                <div class="import-option-content">
                    <strong>➕ 追加</strong>
                    <span style="font-size:0.75rem; color:var(--text-muted);">既存データに追加する</span>
                </div>
            </label>
        </div>
        <div class="save-dialog-buttons" style="margin-top:16px;">
            <button class="btn btn-save" onclick="executeImport()">📂 ファイルを選択</button>
            <button class="btn" onclick="closePanelImportDialog()">キャンセル</button>
        </div>
    </div>
</div>

<div id="autosave-toast" class="autosave-toast">自動保存しました♪</div>
<div id="autosave-error" class="autosave-error-overlay">
    <div class="autosave-error">
        自動保存できませんでした😢　自動保存をオフにします
        <div><button onclick="closeAutoSaveError()">OK</button></div>
    </div>
</div>

<div id="analysis-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header"><h3>📊 テキスト分析</h3><button class="modal-close" onclick="closeAnalysis()">✕</button></div>
        <div id="analysis-results"></div>
    </div>
</div>

<div id="structure-edit-modal">
    <div class="structure-edit-box">
        <div class="structure-edit-header">
            <h3 id="structure-edit-title">構成カードを編集</h3>
            <button class="structure-edit-close" onclick="closeStructureEditModal()">✕</button>
        </div>
        <div class="structure-edit-field">
            <label for="structure-edit-name">タイトル</label>
            <input type="text" id="structure-edit-name" placeholder="章/話/シーンのタイトル">
        </div>
        <div class="structure-edit-field">
            <label for="structure-edit-summary">要約</label>
            <textarea id="structure-edit-summary" placeholder="この章/話/シーンの概要（500文字以内）" maxlength="500"></textarea>
            <div class="structure-edit-hint"><span id="structure-summary-count">0</span>/500文字</div>
        </div>
        <div class="structure-edit-field">
            <label for="structure-edit-viewpoint">視点<button type="button" class="structure-suggest-btn" onclick="toggleStructureViewpointSuggestions()">📋 既存視点</button></label>
            <input type="text" id="structure-edit-viewpoint" placeholder="主人公名 or 一人称/三人称">
            <div id="structure-viewpoint-suggestions" class="structure-tag-suggestions"></div>
        </div>
        <div class="structure-edit-field">
            <label for="structure-edit-tags">舞台タグ（カンマ区切り）<button type="button" class="structure-suggest-btn" onclick="toggleStructureTagSuggestions()">📋 既存タグ</button></label>
            <input type="text" id="structure-edit-tags" placeholder="例: 学校, 放課後, 屋上">
            <div id="structure-tag-suggestions" class="structure-tag-suggestions"></div>
        </div>
        <div class="structure-edit-field">
            <label>登場人物</label>
            <div id="structure-edit-characters" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">登場人物パネルにキャラクターを追加してください</div>
            </div>
            <div class="structure-edit-hint">この章/話/シーンに登場するキャラクターを選択</div>
        </div>
        <div class="structure-edit-field">
            <label>世界観・アイテム</label>
            <div id="structure-edit-worlds" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">世界観パネルに設定を追加してください</div>
            </div>
            <div class="structure-edit-hint">この章/話/シーンに関連する世界観設定を選択</div>
        </div>
        <div class="structure-edit-field">
    <label>関連する用語</label>
    <div id="structure-edit-terms" class="structure-link-select-container"></div>
</div>
<div class="structure-edit-field">
            <label for="structure-edit-status">進捗ステータス</label>
            <select id="structure-edit-status">
                <option value="none">未着手</option>
                <option value="draft">草稿</option>
                <option value="revise">推敲</option>
                <option value="done">完了</option>
            </select>
        </div>
        <div class="structure-edit-field">
            <label for="structure-edit-tab">紐づけタブ</label>
            <select id="structure-edit-tab">
                <option value="">（なし）</option>
            </select>
            <div class="structure-edit-hint">クリック時にジャンプするタブを選択</div>
        </div>
        <div class="structure-edit-actions">
            <button class="btn" onclick="closeStructureEditModal()">キャンセル</button>
            <button class="btn btn-save" onclick="saveStructureCard()">保存</button>
        </div>
    </div>
</div>

<!-- 登場人物編集モーダル -->
<div id="character-edit-modal">
    <div class="character-edit-box">
        <div class="character-edit-header">
            <h3 id="character-edit-title">キャラクターを編集</h3>
            <button class="character-edit-close" onclick="closeCharacterEditModal()">✕</button>
        </div>
        <div class="character-edit-field">
            <label for="character-edit-name">名前</label>
            <input type="text" id="character-edit-name" placeholder="キャラクターの名前">
        </div>
        <div class="character-edit-field">
            <label for="character-edit-reading">読み仮名</label>
            <input type="text" id="character-edit-reading" placeholder="ふりがな">
        </div>
        <div class="character-edit-field" style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="flex:1; min-width:120px;">
                <label for="character-edit-level">アウトラインレベル</label>
                <select id="character-edit-level" style="width:100%;">
                    <option value="1">レベル1（大）</option>
                    <option value="2">レベル2（中）</option>
                    <option value="3">レベル3（小）</option>
                    <option value="4">レベル4（微）</option>
                </select>
            </div>
            <div style="flex:2; min-width:180px;">
                <label for="character-edit-role">役割タグ<button type="button" class="tag-suggest-btn" onclick="toggleCharacterRoleSuggestions()">既存タグ▼</button></label>
                <input type="text" id="character-edit-role" placeholder="例: 主人公, ヒロイン, 敵役">
                <div id="character-role-suggestions" class="tag-suggestions" style="display:none;"></div>
            </div>
        </div>
        <div class="character-edit-field">
            <label for="character-edit-affiliation">所属タグ（カンマ区切り）<button type="button" class="tag-suggest-btn" onclick="toggleCharacterAffiliationSuggestions()">既存タグ▼</button></label>
            <input type="text" id="character-edit-affiliation" placeholder="例: 生徒会, A組, 剣道部">
            <div id="character-affiliation-suggestions" class="tag-suggestions" style="display:none;"></div>
            <div class="character-edit-hint">所属する組織・グループなど</div>
        </div>
        <div class="character-edit-field">
            <label for="character-edit-freetags">自由タグ（カンマ区切り）<button type="button" class="tag-suggest-btn" onclick="toggleCharacterFreetagSuggestions()">既存タグ▼</button></label>
            <input type="text" id="character-edit-freetags" placeholder="例: 幼馴染, ツンデレ, 眼鏡">
            <div id="character-freetag-suggestions" class="tag-suggestions" style="display:none;"></div>
            <div class="character-edit-hint">属性・特徴など</div>
        </div>
        <div class="character-edit-field">
            <label for="character-edit-description">説明</label>
            <textarea id="character-edit-description" placeholder="キャラクターの説明（300文字以内）" maxlength="300"></textarea>
            <div class="character-edit-hint"><span id="character-description-count">0</span>/300文字</div>
        </div>
        <div class="character-edit-field">
            <label>関連する構成</label>
            <div id="character-edit-structures" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">構成パネルにカードを追加してください</div>
            </div>
        </div>
        <div class="character-edit-field">
            <label>関連する世界観</label>
            <div id="character-edit-worlds" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">世界観パネルに設定を追加してください</div>
            </div>
        </div>
        <div class="character-edit-field">
            <label>関連する用語</label>
            <div id="character-edit-terms" class="structure-link-select-container"></div>
        </div>
        <div class="character-edit-field">
            <label for="character-edit-tab">紐づけタブ</label>
            <select id="character-edit-tab">
                <option value="">（なし）</option>
            </select>
            <div class="character-edit-hint">カードからジャンプするタブを選択</div>
        </div>
        <div class="character-edit-actions">
            <button class="btn" onclick="closeCharacterEditModal()">キャンセル</button>
            <button class="btn btn-save" onclick="saveCharacterCard()">保存</button>
        </div>
    </div>
</div>

<!-- 世界観編集モーダル -->
<div id="world-edit-modal">
    <div class="world-edit-box">
        <div class="world-edit-header">
            <h3 id="world-edit-title">項目を編集</h3>
            <button class="world-edit-close" onclick="closeWorldEditModal()">✕</button>
        </div>
        <div class="world-edit-field">
            <label for="world-edit-name">名前</label>
            <input type="text" id="world-edit-name" placeholder="項目名">
        </div>
        <div class="world-edit-field" style="display:flex; gap:12px; flex-wrap:wrap;">
            <div style="flex:1; min-width:120px;">
                <label for="world-edit-outline-level">アウトラインレベル</label>
                <select id="world-edit-outline-level" style="width:100%;">
                    <option value="1">レベル1（大）</option>
                    <option value="2">レベル2（中）</option>
                    <option value="3">レベル3（小）</option>
                    <option value="4">レベル4（微）</option>
                </select>
            </div>
            <div style="flex:2; min-width:180px;">
                <label for="world-edit-level">カテゴリタグ<button type="button" class="tag-suggest-btn" onclick="toggleWorldLevelSuggestions()">既存タグ▼</button></label>
                <input type="text" id="world-edit-level" placeholder="例: 大カテゴリ, 中カテゴリ, 詳細項目">
                <div id="world-level-suggestions" class="tag-suggestions" style="display:none;"></div>
            </div>
        </div>
        <div class="world-edit-field">
            <label for="world-edit-termtags">用語タグ（カンマ区切り）<button type="button" class="tag-suggest-btn" onclick="toggleWorldTermtagSuggestions()">既存タグ▼</button></label>
            <input type="text" id="world-edit-termtags" placeholder="例: 魔法, 古代文明, 禁術">
            <div id="world-termtag-suggestions" class="tag-suggestions" style="display:none;"></div>
            <div class="world-edit-hint">関連する用語やキーワード</div>
        </div>
        <div class="world-edit-field">
            <label for="world-edit-description">説明</label>
            <textarea id="world-edit-description" placeholder="この項目の説明（500文字以内）" maxlength="500"></textarea>
            <div class="world-edit-hint"><span id="world-description-count">0</span>/500文字</div>
        </div>
        <div class="world-edit-field">
            <label>関連する登場人物</label>
            <div id="world-edit-characters" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">登場人物パネルにキャラクターを追加してください</div>
            </div>
        </div>
        <div class="world-edit-field">
            <label>関連する構成</label>
            <div id="world-edit-structures" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">構成パネルにカードを追加してください</div>
            </div>
        </div>
        <div class="world-edit-field">
    <label>関連する用語</label>
    <div id="world-edit-terms" class="structure-link-select-container"></div>
</div>
<div class="world-edit-field">
            <label>関連する世界観</label>
            <div id="world-edit-worlds" class="structure-link-select-container">
                <div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">他の世界観設定と関連付け</div>
            </div>
        </div>
        <div class="world-edit-field">
            <label for="world-edit-tab">紐づけタブ</label>
            <select id="world-edit-tab">
                <option value="">（なし）</option>
            </select>
            <div class="world-edit-hint">カードからジャンプするタブを選択</div>
        </div>
        <div class="world-edit-actions">
            <button class="btn" onclick="closeWorldEditModal()">キャンセル</button>
            <button class="btn btn-save" onclick="saveWorldCard()">保存</button>
        </div>
    </div>
</div>


<!-- 用語 編集モーダル -->
<div class="terms-edit-modal" id="terms-edit-modal" style="display:none;">
  <div class="terms-edit-box">
    <div class="terms-edit-header">
      <h3 id="terms-edit-title">用語を編集</h3>
      <button class="terms-edit-close" onclick="closeTermEditModal()">✕</button>
    </div>
    <div class="terms-edit-field">
      <label for="terms-edit-name">用語名</label>
      <input type="text" id="terms-edit-name" placeholder="例：魔力結晶">
    </div>
    <div class="terms-edit-field">
      <label for="terms-edit-category">カテゴリ <button type="button" class="tag-suggest-btn" onclick="toggleTermsCategorySuggestions()">既存タグ▼</button></label>
      <input type="text" id="terms-edit-category" list="terms-category-datalist"  placeholder="例：アイテム / 概念 / 組織 など">
      <datalist id="terms-category-datalist"></datalist>
      <div id="terms-category-suggestions" class="tag-suggestions" style="display:none;"></div>
    </div>
    <div class="terms-edit-field">
      <label for="terms-edit-desc">説明</label>
      <textarea id="terms-edit-desc" rows="5" placeholder="説明を書いてください"></textarea>
    </div>
    <div class="terms-edit-field">
      <label for="terms-edit-tab">紐づけタブ</label>
      <select id="terms-edit-tab">
        <option value="">（なし）</option>
      </select>
      <div class="terms-edit-hint">カードからジャンプするタブを選択</div>
    </div>

    <div class="terms-edit-field">
      <div class="terms-edit-hint">関連リンク（クリックで選択/解除）</div>
      <div style="margin-top:6px;">
        <div style="font-size:0.75rem; font-weight:bold; margin-bottom:4px;">👤 登場人物</div>
        <div id="terms-link-characters" class="structure-link-select-container"></div>
      </div>
      <div style="margin-top:10px;">
        <div style="font-size:0.75rem; font-weight:bold; margin-bottom:4px;">🌍 世界観</div>
        <div id="terms-link-worlds" class="structure-link-select-container"></div>
      </div>
      <div style="margin-top:10px;">
        <div style="font-size:0.75rem; font-weight:bold; margin-bottom:4px;">📋 構成</div>
        <div id="terms-link-structures" class="structure-link-select-container"></div>
      </div>
    </div>

    <div class="terms-edit-actions">
      <button class="btn" onclick="closeTermEditModal()">キャンセル</button>
      <button class="btn btn-primary" onclick="saveTermCard()">保存</button>
    </div>
  </div>
</div>

<!-- 開く（読み込み）時の選択ダイアログ：現在タブ or 新規タブ -->
<div id="open-choice-modal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content" style="max-width: 420px;">
        <div class="modal-header">
            <h3>📂 開く</h3>
            <button class="modal-close" onclick="closeOpenChoiceModal()">✕</button>
        </div>
        <div style="font-size:0.9rem; line-height:1.6; margin-bottom: 12px;">
            読み込んだテキストを、どこに開きますか？
            <div style="font-size:0.8rem; color: var(--text-muted); margin-top:6px;">
                
                <div style="margin-top:10px;">
                  <label style="font-size:0.85rem; color:var(--text-muted);">
                    <input type="checkbox" id="check-open-set-default"> 今回の選択を既定にする
                  </label>
                </div>
            </div>
        </div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
            <button class="btn" id="btn-open-choice-current" onclick="chooseOpenModeAndPickFile('current')">現在のタブに開く</button>
            <button class="btn btn-apply-all" id="btn-open-choice-new" onclick="chooseOpenModeAndPickFile('new')">新しいタブに開く</button>
            <button class="btn" onclick="closeOpenChoiceModal()">キャンセル</button>
        </div>
    </div>
</div>

<div id="reader-overlay" aria-hidden="true">
    <div id="reader-header">
        <div id="reader-title">👁 閲覧（全タブ） <span class="reader-hint">※保存時の区切り記号「◆」を表示 / Escでも戻れます</span></div>
        <div id="reader-controls">
            <input type="text" id="reader-search-input" placeholder="閲覧内検索..." style="height:30px; width:160px; border-radius:10px; border:1px solid var(--border-color); padding:0 10px; background:var(--panel-bg); color:var(--text-color);" onkeydown="if(event.key==='Enter') readerDoSearch()">
            <button class="btn" onclick="readerDoSearch()">検索</button>
            <button class="btn" onclick="readerFindPrev()">▲</button>
            <button class="btn" onclick="readerFindNext()">▼</button>
            <span id="reader-search-info" style="min-width:52px; display:inline-block; text-align:right;">0/0</span>
            <button class="btn" id="btn-reader-writing-mode" onclick="toggleReaderWritingMode()" title="書字方向切替">縦書きへ</button>
            <button class="btn btn-sync" onclick="closeReaderView()" title="元の画面に戻る（Esc）">↩ 元の画面に戻る</button>
            <button class="btn" onclick="closeReaderView()" title="閉じる">✕</button>
        </div>
    </div>
    <div id="reader-scroll"><div id="reader-content"></div></div>
</div>

<div id="jump-dialog" class="jump-dialog">
    <h4>行番号ジャンプ</h4>
    <input type="number" id="jump-line-input" placeholder="行番号を入力..." min="1">
    <div class="jump-dialog-buttons">
        <button class="btn" onclick="executeJump()">ジャンプ</button>
        <button class="btn" onclick="closeJumpDialog()">キャンセル</button>
    </div>
</div>


<!-- タブ右クリックメニュー (動的に生成される) -->

<!-- ルビ入力モーダル -->
<div id="ruby-modal" aria-hidden="true">
  <div class="ruby-box" role="dialog" aria-label="ルビ入力">
    <div class="ruby-header">
      <h3>🈂️ ルビ</h3>
      <button class="ruby-close" onclick="closeRubyModal()" title="閉じる">✕</button>
    </div>
    <div class="ruby-target">対象：<b id="ruby-target-text"></b></div>
    <input id="ruby-input" type="text" placeholder="ルビを入力（Enterで確定）">
    <div class="ruby-actions">
      <button class="btn" onclick="closeRubyModal()">キャンセル</button>
      <button class="btn btn-apply-all" onclick="confirmRubyModal()">OK</button>
    </div>
  </div>
</div>

<!-- 集中モード用 一時表示オーバーレイ -->
<div id="focus-overlay" aria-hidden="true">
  <div class="focus-box" role="dialog" aria-label="集中モード一時表示">
    <div class="focus-header">
      <h3 id="focus-overlay-title">表示</h3>
      <button class="btn" onclick="closeFocusOverlay()">✕</button>
    </div>
    <div class="focus-body" id="focus-overlay-body"></div>
  </div>
</div>

<script>

  // 先にダミーを作って未定義落ちを防ぐ（あとで本物があれば上書きされる）
  window.setupMemoInteractionGuard = window.setupMemoInteractionGuard || function(){};

  // エラー回避：未実装でも落ちないようにする（最初の<script>の先頭に置く）
  window.updateActiveTabTitle = window.updateActiveTabTitle || function () {};

  // togglePanel仮定義（後で本物が上書きする）
  window.togglePanel = window.togglePanel || function(id) {
    const p = document.getElementById(id);
    if (p) p.classList.toggle('open');
  };

  // 構成関連の関数を仮定義
  window.toggleStructureViewpointSuggestions = window.toggleStructureViewpointSuggestions || function(){};
  window.setStructureViewpoint = window.setStructureViewpoint || function(){};
  window.toggleStructureCharacterLink = window.toggleStructureCharacterLink || function(){};
  window.toggleStructureWorldLink = window.toggleStructureWorldLink || function(){};

  // 登場人物関連の関数を仮定義
  window.toggleCharacterRoleSuggestions = window.toggleCharacterRoleSuggestions || function(){};
  window.setCharacterRole = window.setCharacterRole || function(){};
  window.toggleCharacterStructureLink = window.toggleCharacterStructureLink || function(){};
  window.toggleCharacterWorldLink = window.toggleCharacterWorldLink || function(){};

  // 世界観関連の関数を仮定義
  window.toggleWorldLevelSuggestions = window.toggleWorldLevelSuggestions || function(){};
  window.setWorldLevel = window.setWorldLevel || function(){};
  window.toggleWorldCharacterLink = window.toggleWorldCharacterLink || function(){};
  window.toggleWorldTermLink = window.toggleWorldTermLink || function(){};
  window.toggleWorldStructureLink = window.toggleWorldStructureLink || function(){};
  window.toggleWorldWorldLink = window.toggleWorldWorldLink || function(){};

  window.updateMemoCharCount = function () {
    const memoArea = document.getElementById('memo-area');
    const countEl  = document.getElementById('memo-char-count');
    if (memoArea && countEl) countEl.innerText = memoArea.value.length + '字';
  };
    window.updateMemoCharCount = function () {
    const memoArea = document.getElementById('memo-area');
    const countEl  = document.getElementById('memo-char-count');
    if (memoArea && countEl) countEl.innerText = memoArea.value.length + '字';
  };

// パネル操作中フラグ（浮動パネルが意図せず閉じないようにする）
window.memoInteracting = false;
window.outlineInteracting = false;
window.structureInteracting = false;
window.characterInteracting = false;
window.worldInteracting = false;

function setupMemoInteractionGuard() {
  const memo = document.getElementById('memo-panel');
  if (!memo) return;

  const on = () => { window.memoInteracting = true; };
  const off = () => { window.memoInteracting = false; };

  // マウスが乗っている間／フォーカス中は「操作中」
  memo.addEventListener('pointerenter', on);
  memo.addEventListener('pointerleave', off);
  memo.addEventListener('focusin', on);
  memo.addEventListener('focusout', off);

  // クリック・ドラッグの最中も「操作中」
  memo.addEventListener('pointerdown', on, { capture: true });
  memo.addEventListener('pointerup', off, { capture: true });
  memo.addEventListener('pointercancel', off, { capture: true });
}

function setupOutlineInteractionGuard() {
  const outline = document.getElementById('outline-panel');
  if (!outline) return;

  const on = () => { window.outlineInteracting = true; };
  const off = () => { window.outlineInteracting = false; };

  outline.addEventListener('pointerenter', on);
  outline.addEventListener('pointerleave', off);
  outline.addEventListener('focusin', on);
  outline.addEventListener('focusout', off);
  outline.addEventListener('pointerdown', on, { capture: true });
  outline.addEventListener('pointerup', off, { capture: true });
  outline.addEventListener('pointercancel', off, { capture: true });
}

function setupStructureInteractionGuard() {
  const panel = document.getElementById('structure-panel');
  if (!panel) return;

  const on = () => { window.structureInteracting = true; };
  const off = () => { window.structureInteracting = false; };

  panel.addEventListener('pointerenter', on);
  panel.addEventListener('pointerleave', off);
  panel.addEventListener('focusin', on);
  panel.addEventListener('focusout', off);
  const delayedOff = () => setTimeout(off, 0);
  panel.addEventListener('pointerdown', on, { capture: true });
  panel.addEventListener('pointerup', delayedOff, { capture: true });
  panel.addEventListener('pointercancel', delayedOff, { capture: true });
}

function setupCharacterInteractionGuard() {
  const panel = document.getElementById('character-panel');
  if (!panel) return;

  const on = () => { window.characterInteracting = true; };
  const off = () => { window.characterInteracting = false; };

  panel.addEventListener('pointerenter', on);
  panel.addEventListener('pointerleave', off);
  panel.addEventListener('focusin', on);
  panel.addEventListener('focusout', off);
  const delayedOff = () => setTimeout(off, 0);
  panel.addEventListener('pointerdown', on, { capture: true });
  panel.addEventListener('pointerup', delayedOff, { capture: true });
  panel.addEventListener('pointercancel', delayedOff, { capture: true });
}

function setupWorldInteractionGuard() {
  const panel = document.getElementById('world-panel');
  if (!panel) return;

  const on = () => { window.worldInteracting = true; };
  const off = () => { window.worldInteracting = false; };

  panel.addEventListener('pointerenter', on);
  panel.addEventListener('pointerleave', off);
  panel.addEventListener('focusin', on);
  panel.addEventListener('focusout', off);
  const delayedOff = () => setTimeout(off, 0);
  panel.addEventListener('pointerdown', on, { capture: true });
  panel.addEventListener('pointerup', delayedOff, { capture: true });
  panel.addEventListener('pointercancel', delayedOff, { capture: true });
}

// タブバー左右スクロール
function setupTabScrollButtons() {
  document.querySelectorAll('.tab-scroll-btn').forEach(btn => {
    btn.addEventListener('click', ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const targetId = btn.dataset.target;
      const container = document.getElementById(targetId);
      if (!container) return;
      const dir = btn.classList.contains('left') ? -1 : 1;
      container.scrollBy({ left: dir * 200, behavior: 'smooth' });
    });
  });
}

function updateTabScrollButtonsFor(targetId) {
  const container = document.getElementById(targetId);
  if (!container) return;
  const wrap = container.closest('.tabs-scroll-wrap');
  if (!wrap) return;
  const leftBtn = wrap.querySelector('.tab-scroll-btn.left');
  const rightBtn = wrap.querySelector('.tab-scroll-btn.right');
  if (!leftBtn || !rightBtn) return;

  const needs = container.scrollWidth > container.clientWidth + 1;
  leftBtn.classList.toggle('show', needs);
  rightBtn.classList.toggle('show', needs);
  if (!needs) {
    leftBtn.disabled = true;
    rightBtn.disabled = true;
    leftBtn.style.opacity = '0.35';
    rightBtn.style.opacity = '0.35';
    return;
  }

  const maxScroll = container.scrollWidth - container.clientWidth;
  const atLeft = container.scrollLeft <= 0;
  const atRight = container.scrollLeft >= maxScroll - 1;
  leftBtn.disabled = atLeft;
  rightBtn.disabled = atRight;
  leftBtn.style.opacity = atLeft ? '0.35' : '1';
  rightBtn.style.opacity = atRight ? '0.35' : '1';
}

function initTabScrollers() {
  setupTabScrollButtons();
  ['input-tabs-container', 'preview-tabs-container', 'memo-tabs-container'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('scroll', () => updateTabScrollButtonsFor(id), { passive: true });
  });
  window.addEventListener('resize', () => {
    updateTabScrollButtonsFor('input-tabs-container');
    updateTabScrollButtonsFor('preview-tabs-container');
    updateTabScrollButtonsFor('memo-tabs-container');
  });

  // 初期状態
  updateTabScrollButtonsFor('input-tabs-container');
  updateTabScrollButtonsFor('preview-tabs-container');
  updateTabScrollButtonsFor('memo-tabs-container');
}

// 起動時に1回だけセットアップ
setupMemoInteractionGuard();
setupOutlineInteractionGuard();
setupStructureInteractionGuard();
setupCharacterInteractionGuard();
setupWorldInteractionGuard();
initTabScrollers();

	
    const inputArea = document.getElementById('input-area');
    window.inputArea = inputArea;
    const inputMirror = document.getElementById('input-mirror-container');
    const previewContent = document.getElementById('preview-content');
    const previewScroll = document.getElementById('preview-scroll');
    const inputPosBar = document.getElementById('input-pos-bar');
    const previewPosBar = document.getElementById('preview-pos-bar');
    const charCountEl = document.getElementById('char-count');
    const lineCountEl = document.getElementById('line-count');
    const inputNetCountEl = document.getElementById('input-net-count');
    const inputGoalEl = document.getElementById('input-goal-display');
    const inputTodayGoalEl = document.getElementById('input-today-goal');
    const inputWritingTimeEl = document.getElementById('input-writing-time');
    const inputReadingEl = document.getElementById('input-reading-time');
    const inputManuscriptEl = document.getElementById('input-manuscript');
    const inputSelOverlay = document.getElementById('input-sel-overlay');
    const pvTotalCountEl = document.getElementById('pv-total-count');
    const pvNetCountEl = document.getElementById('pv-net-count');
    const pvLineCountEl = document.getElementById('pv-line-count');
    const pvTimeEl = document.getElementById('pv-time');
    const pvGoalEl = document.getElementById('pv-goal-display');
    const pvTodayGoalEl = document.getElementById('pv-today-goal');
    const pvReadingEl = document.getElementById('pv-reading-time');
    const pvManuscriptEl = document.getElementById('pv-manuscript');
    const previewSelOverlay = document.getElementById('preview-sel-overlay');
    const btnSwap = document.getElementById('btn-layout-swap');
    const paneStack = document.getElementById('pane-stack');

    if (inputSelOverlay) inputSelOverlay.title = '選択中の文字数と行数を表示します。';
    if (previewSelOverlay) previewSelOverlay.title = 'プレビューで選択した範囲の文字数と行数を表示します。';

    let layoutAxis = 'row', layoutReversed = false;
    const LAYOUT_AXIS_KEY = 'cc_layout_axis';
    const LAYOUT_REVERSED_KEY = 'cc_layout_reversed';

    let settingsCache = {
        goalChars: 150000, todayGoal: 2000, manuscriptRows: 34, manuscriptCols: 42,
        showReadingTime: true, showManuscript: true, showSpace: true, showHighlight: true,
        typewriterMode: false, writingTracker: true, defaultPreviewHidden: false,
        celebrateGoal: true, openMode: 'current', autosaveInterval: 60, autosaveEnabled: false, maxPinnedPanels: 4,
        panelSideMap: { memo:'left', outline:'left', search:'left', structure:'left', character:'left', world:'left', terms:'left' }
    };
    let goalAchieved = { today: false, total: false };
    let previewUpdateTimeout = null;

    // 「📂 開く」を押した時に、その場で「現在タブ / 新規タブ」を選べるようにするための一時設定
    // （loadFile() 内で優先して参照し、処理後に null に戻します）
    let pendingOpenMode = null;

    const PANE_WIDTH_KEYS = {
        input: 'cc_pane_input_width_px',
        preview: 'cc_pane_preview_width_px',
                side: 'cc_side_width_px',
memo: 'cc_memo_width_px',
        outline: 'cc_outline_width_px',
        structure: 'cc_structure_width_px',
        search: 'cc_search_width_px',
        character: 'cc_character_width_px',
        world: 'cc_world_width_px',
        terms: 'cc_terms_width_px',
        legacyInput: 'cc_pane_input_width',
        legacyPreview: 'cc_pane_preview_width'
    };
    const PANE_HEIGHT_KEYS = {
        input: 'cc_pane_input_height_px',
        preview: 'cc_pane_preview_height_px'
    };
    const DIVIDER_WIDTH_KEY = 'cc_divider_width_px';

    const TODAY_START_KEY = 'cc_editor_today_start';
    const WRITING_TIME_KEY = 'cc_editor_writing_time';
    const BOOKMARKS_KEY = 'cc_editor_bookmarks';
    const SETTINGS_KEY = 'cc_editor_settings';
    const TABS_KEY = 'cc_editor_tabs';
    const NOVEL_TITLE_KEY = 'cc_editor_novel_title';
    const DEFAULT_NOVEL_TITLE = 'ここにプロジェクトタイトルを入力してください。';
    let todayStartChars = 0, writingSeconds = 0, lastInputTime = 0, writingTimerInterval = null, bookmarks = [];
    let novelTitle = DEFAULT_NOVEL_TITLE;
    let lastTextSaveHandle = null;
    let lastHtmlSaveHandle = null;
    let lastMemoSaveHandle = null;
    let autoSaveTarget = { handle: null, type: null };

    // Utility function - must be defined before use in renderInputTabs
    function escapeHtml(s) { return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])); }

    function saveLayoutSettings() {
        localStorage.setItem(LAYOUT_AXIS_KEY, layoutAxis);
        localStorage.setItem(LAYOUT_REVERSED_KEY, layoutReversed ? 'true' : 'false');
    }

    function applyLayoutState() {
        if (layoutAxis === 'column') {
            document.body.classList.add('scroll-mode');
            btnSwap.innerText = '上下入替';
        } else {
            document.body.classList.remove('scroll-mode');
            btnSwap.innerText = '左右入替';
        }
        paneStack.classList.remove('reverse-row', 'reverse-col');
        if (layoutReversed) paneStack.classList.add(layoutAxis === 'row' ? 'reverse-row' : 'reverse-col');
    }

    function loadLayoutSettings() {
        const savedAxis = localStorage.getItem(LAYOUT_AXIS_KEY);
        const savedReversed = localStorage.getItem(LAYOUT_REVERSED_KEY);
        if (savedAxis === 'row' || savedAxis === 'column') layoutAxis = savedAxis;
        layoutReversed = savedReversed === 'true';
        applyLayoutState();
    }

    function setPaneSplitEqual() {
        if (document.body.classList.contains('scroll-mode')) {
            const inputPane = document.getElementById('pane-input');
            const baseHeight = Math.round(inputPane?.getBoundingClientRect().height || 520);
            const equalHeight = clampValue(baseHeight, 160, 2000);
            document.getElementById('st-pane-input-height').value = equalHeight;
            document.getElementById('st-pane-preview-height').value = equalHeight;
            localStorage.setItem(PANE_HEIGHT_KEYS.input, String(equalHeight));
            localStorage.setItem(PANE_HEIGHT_KEYS.preview, String(equalHeight));
            applyPaneHeightSettings();
        } else {
            const mainContainer = document.getElementById('main-container');
            const containerWidth = mainContainer.getBoundingClientRect().width || 1000;
            const halfWidth = clampValue(Math.round(containerWidth / 2), 120, 3000);
            document.getElementById('st-pane-input-width').value = halfWidth;
            document.getElementById('st-pane-preview-width').value = halfWidth;
            localStorage.setItem(PANE_WIDTH_KEYS.input, halfWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.preview, halfWidth);
            applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
        }
    }

    // Input Tabs System
    let inputTabs = [{ id: 1, name: 'タブはリネームできます', content: '' }];
    let activeTabId = 1;
    let nextTabId = 2;
    let draggingInputTabId = null;
    window.inputTabs = inputTabs;
    Object.defineProperty(window, 'activeTabId', {
        get: () => activeTabId,
        set: (value) => { activeTabId = value; }
    });
    Object.defineProperty(window, 'nextTabId', {
        get: () => nextTabId,
        set: (value) => { nextTabId = value; }
    });

    function renderInputTabs() {
        const container = document.getElementById('input-tabs-container');
        container.innerHTML = '';
        inputTabs.forEach(tab => {
            const tabEl = document.createElement('div');
            tabEl.className = 'input-tab' + (tab.id === activeTabId ? ' active' : '');
            tabEl.draggable = true;
            tabEl.dataset.tabId = tab.id;
            tabEl.innerHTML = `
                <span class="tab-name" ondblclick="startEditTabName(${tab.id})">${escapeHtml(tab.name)}</span>
                ${inputTabs.length > 1 ? `<span class="tab-close" onclick="event.stopPropagation(); deleteTab(${tab.id})">✕</span>` : ''}
            `;
            tabEl.onclick = () => switchTab(tab.id);
            tabEl.addEventListener('dragstart', e => {
                draggingInputTabId = tab.id;
                tabEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            tabEl.addEventListener('dragend', () => {
                draggingInputTabId = null;
                tabEl.classList.remove('dragging');
            });
            tabEl.addEventListener('dragover', e => {
                if (draggingInputTabId === null || draggingInputTabId === tab.id) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            tabEl.addEventListener('drop', e => {
                e.preventDefault();
                if (draggingInputTabId === null || draggingInputTabId === tab.id) return;
                const fromIndex = inputTabs.findIndex(t => t.id === draggingInputTabId);
                const toIndex = inputTabs.findIndex(t => t.id === tab.id);
                if (fromIndex === -1 || toIndex === -1) return;
                const [moved] = inputTabs.splice(fromIndex, 1);
                inputTabs.splice(toIndex, 0, moved);
                renderInputTabs();
                saveTabsToStorage();
            });
            container.appendChild(tabEl);
        });
        const addBtn = document.createElement('button');
        addBtn.className = 'input-tab-add';
        addBtn.textContent = '＋';
        addBtn.title = '新しいタブを追加';
        addBtn.onclick = addNewTab;
        container.appendChild(addBtn);
        updateTabScrollButtonsFor('input-tabs-container');
        updateActiveTabTitle();
        updatePreviewTabOptions();
    }
    function sanitizeFileName(name) {
        return name.replace(/[\\/:*?"<>|]/g, '').trim();
    }
    function setNovelTitle(title, save = true) {
        novelTitle = title.trim() || DEFAULT_NOVEL_TITLE;
        const titleEl = document.getElementById('novel-title');
        if (titleEl) titleEl.textContent = novelTitle;
        if (save) localStorage.setItem(NOVEL_TITLE_KEY, novelTitle);
    }
    function loadNovelTitle() {
        const saved = localStorage.getItem(NOVEL_TITLE_KEY);
        setNovelTitle(saved || DEFAULT_NOVEL_TITLE, false);
    }
    function startEditNovelTitle() {
        const titleEl = document.getElementById('novel-title');
        if (!titleEl) return;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'novel-title-input';
        input.value = novelTitle;
        input.onblur = () => finishEditNovelTitle(input.value);
        input.onkeydown = e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') { input.value = novelTitle; input.blur(); } };
        titleEl.replaceWith(input);
        input.focus();
        input.select();
    }
    function finishEditNovelTitle(newTitle) {
        setNovelTitle(newTitle);
        const input = document.querySelector('.pane-title input.novel-title-input');
        if (!input) return;
        const span = document.createElement('span');
        span.className = 'novel-title-name';
        span.id = 'novel-title';
        span.title = 'ダブルクリックで作品名を変更';
        span.ondblclick = startEditNovelTitle;
        span.textContent = novelTitle;
        input.replaceWith(span);
        addTitleContextMenu();
    }

function switchTab(tabId) {
  // Save current tab content
  const currentTab = inputTabs.find(t => t.id === activeTabId);
  if (currentTab) currentTab.content = inputArea.value;

  // Switch to new tab
  activeTabId = tabId;
  const newTab = inputTabs.find(t => t.id === tabId);
  if (newTab) inputArea.value = newTab.content;

  renderInputTabs();
  updateInputStats();

  // ★ここではプレビューを更新しない（完全独立）

  saveTabsToStorage();
}

function addNewTab() {
  const currentTab = inputTabs.find(t => t.id === activeTabId);
  if (currentTab) currentTab.content = inputArea.value;

  const newTab = { id: nextTabId++, name: `タブ${inputTabs.length + 1}`, content: '' };
  inputTabs.push(newTab);

  activeTabId = newTab.id;
  inputArea.value = '';

  renderInputTabs();
  updateInputStats();

  // ★ここではプレビューを更新しない（完全独立）
  // updatePreview();

  saveTabsToStorage();
}


    function deleteTab(tabId) {
        if (inputTabs.length <= 1) return;
        if (!confirm('このタブを削除しますか？')) return;
        const idx = inputTabs.findIndex(t => t.id === tabId);
        inputTabs.splice(idx, 1);
        if (activeTabId === tabId) {
            activeTabId = inputTabs[Math.max(0, idx - 1)].id;
            inputArea.value = inputTabs.find(t => t.id === activeTabId).content;
        }
        renderInputTabs();
        updateInputStats();
        updatePreview();
        saveTabsToStorage();
    }

    function startEditTabName(tabId) {
        const container = document.getElementById('input-tabs-container');
        const tabEl = container.querySelector(`.input-tab.active .tab-name`) || container.querySelector(`.input-tab:nth-child(${inputTabs.findIndex(t => t.id === tabId) + 1}) .tab-name`);
        const tab = inputTabs.find(t => t.id === tabId);
        if (!tabEl || !tab) return;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'tab-name-input';
        input.value = tab.name;
        input.onblur = () => finishEditTabName(tabId, input.value);
        input.onkeydown = e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') { input.value = tab.name; input.blur(); } };
        tabEl.replaceWith(input);
        input.focus();
        input.select();
    }

    function finishEditTabName(tabId, newName) {
        const tab = inputTabs.find(t => t.id === tabId);
        if (tab) tab.name = newName.trim() || tab.name;
        updateActiveTabTitle();
        renderInputTabs();
        saveTabsToStorage();
    }

    function saveTabsToStorage() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;
        localStorage.setItem(TABS_KEY, JSON.stringify({ tabs: inputTabs, activeTabId, nextTabId }));
    }

    function loadTabsFromStorage() {
        const s = localStorage.getItem(TABS_KEY);
        if (s) {
            try {
                const d = JSON.parse(s);
                if (d.tabs && d.tabs.length > 0) {
                    inputTabs = d.tabs;
                    window.inputTabs = inputTabs;
                    activeTabId = d.activeTabId || inputTabs[0].id;
                    nextTabId = d.nextTabId || inputTabs.length + 1;
                    const activeTab = inputTabs.find(t => t.id === activeTabId);
                    if (activeTab) inputArea.value = activeTab.content;
                    return true;
                }
            } catch (e) {}
        }
        return false;
    }

    function getAllTabsContent() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;
        let combined = '';
        inputTabs.forEach((tab, idx) => {
            if (idx > 0) combined += '\n\n';
            combined += `◆ ${tab.name}\n\n${tab.content}`;
        });
        return combined;
    }

    function getCurrentTabContent() {
        return inputArea.value;
    }

    function getTodayDateStr() { const n = new Date(); return `${n.getFullYear()}-${(n.getMonth()+1).toString().padStart(2,'0')}-${n.getDate().toString().padStart(2,'0')}`; }

    function loadTodayStart() {
        const s = localStorage.getItem(TODAY_START_KEY);
        if (s) { try { const d = JSON.parse(s); if (d.date === getTodayDateStr()) { todayStartChars = d.startChars; return; } } catch (e) {} }
        saveTodayStart();
    }
    function saveTodayStart() { const n = inputArea.value.replace(/[\n\s　]/g, '').length; todayStartChars = n; localStorage.setItem(TODAY_START_KEY, JSON.stringify({ date: getTodayDateStr(), startChars: n })); }
    function resetTodayStart() { if (confirm('今日の開始点をリセットしますか？')) { saveTodayStart(); updateInputStats(); updatePreview(); } }

    function loadWritingTime() {
        const s = localStorage.getItem(WRITING_TIME_KEY);
        if (s) { try { const d = JSON.parse(s); if (d.date === getTodayDateStr()) { writingSeconds = d.seconds; return; } } catch (e) {} }
        writingSeconds = 0; saveWritingTime();
    }
    function saveWritingTime() { localStorage.setItem(WRITING_TIME_KEY, JSON.stringify({ date: getTodayDateStr(), seconds: writingSeconds })); }
    function formatTime(s) { return `${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
    function updateWritingTimeDisplay() {
        const t = formatTime(writingSeconds);
        document.getElementById('writing-time-display').textContent = `執筆時間: ${t}`;
        inputWritingTimeEl.textContent = settingsCache.writingTracker ? `⏱${t}` : '';
    }
    function startWritingTimer() {
        if (writingTimerInterval) return;
        writingTimerInterval = setInterval(() => { if (Date.now() - lastInputTime < 5000) { writingSeconds++; updateWritingTimeDisplay(); if (writingSeconds % 30 === 0) saveWritingTime(); } }, 1000);
    }

    function loadBookmarks() { const s = localStorage.getItem(BOOKMARKS_KEY); if (s) { try { bookmarks = JSON.parse(s); } catch (e) { bookmarks = []; } } renderBookmarks(); }
    function saveBookmarks() { localStorage.setItem(BOOKMARKS_KEY, JSON.stringify(bookmarks)); }
    function addBookmark() {
        const pos = inputArea.selectionStart, text = inputArea.value;
        const lineStart = text.lastIndexOf('\n', pos - 1) + 1, lineEnd = text.indexOf('\n', pos);
        const lineText = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd).trim();
        const preview = lineText.substring(0, 30) + (lineText.length > 30 ? '...' : '');
        const lineNum = (text.substring(0, pos).match(/\n/g) || []).length + 1;
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        bookmarks.push({ pos, lineNum, preview, created: Date.now(), tabId: activeTabId, tabName: currentTab?.name || '' });
        saveBookmarks();
        renderBookmarks();
    }
    function deleteBookmark(i) { bookmarks.splice(i, 1); saveBookmarks(); renderBookmarks(); }
    function jumpToBookmark(pos, tabId) {
        if (tabId && tabId !== activeTabId) {
            switchTab(tabId);
        }
        inputArea.focus();
        inputArea.setSelectionRange(pos, pos);
        setTimeout(() => scrollToCursorPosition(pos), 100);
        updateCursorLineDisplay();
    }
    function toggleAllBookmarks() {
        const checked = document.getElementById('bookmark-select-all').checked;
        document.querySelectorAll('.bookmark-checkbox').forEach(cb => cb.checked = checked);
    }
    function deleteSelectedBookmarks() {
        const checkboxes = document.querySelectorAll('.bookmark-checkbox:checked');
        if (checkboxes.length === 0) return;
        if (!confirm(`${checkboxes.length}件のブックマークを削除しますか？`)) return;
        const indices = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index)).sort((a, b) => b - a);
        indices.forEach(i => bookmarks.splice(i, 1));
        saveBookmarks(); renderBookmarks();
        document.getElementById('bookmark-select-all').checked = false;
    }
    function renderBookmarks() {
        const l = document.getElementById('bookmark-list'); l.innerHTML = '';
        const actions = document.getElementById('bookmark-actions');
        if (bookmarks.length === 0) { l.innerHTML = '<div class="outline-empty">ブックマークがありません</div>'; actions.style.display = 'none'; return; }
        actions.style.display = 'block';
        bookmarks.forEach((b, i) => {
            const tabName = b.tabName || inputTabs.find(t => t.id === b.tabId)?.name || '';
            const tabLabel = tabName ? `【${escapeHtml(tabName)}】` : '';
            const d = document.createElement('div');
            d.className = 'bookmark-item';
            d.innerHTML = `<input type="checkbox" class="bookmark-checkbox" data-index="${i}" style="margin-right:6px;"><span class="bookmark-text" onclick="jumpToBookmark(${b.pos}, ${b.tabId || activeTabId})">📍 ${tabLabel}${b.lineNum}行目: ${escapeHtml(b.preview)}</span><span class="bookmark-delete" onclick="deleteBookmark(${i})">✕</span>`;
            l.appendChild(d);
        });
    }

    // 設定エクスポート/インポート
    function collectAllSettings() {
        return {
            version: '3.5',
            input: { size: document.getElementById('st-in-size').value, line: document.getElementById('st-in-line').value, font: document.getElementById('st-in-font').value, vertical: document.getElementById('st-in-v').checked },
            preview: { size: document.getElementById('st-pv-size').value, line: document.getElementById('st-pv-line').value, font: document.getElementById('st-pv-font').value, vertical: document.getElementById('st-pv-v').checked },
            display: { showSpace: document.getElementById('st-show-space').checked, showHighlight: document.getElementById('st-show-highlight').checked, showInput: document.getElementById('check-show-input').checked, showPreview: document.getElementById('check-show-preview').checked, defaultPreviewHidden: document.getElementById('st-default-preview-hidden').checked },
            writing: { typewriter: document.getElementById('st-typewriter-mode').checked, tracker: document.getElementById('st-writing-tracker').checked },
            goal: { chars: document.getElementById('st-goal-chars').value, today: document.getElementById('st-today-goal').value, showReading: document.getElementById('st-show-reading-time').checked, celebrate: document.getElementById('st-celebrate-goal').checked },
            manuscript: { rows: document.getElementById('st-manuscript-rows').value, cols: document.getElementById('st-manuscript-cols').value, show: document.getElementById('st-show-manuscript').checked },
            open: { mode: document.querySelector('input[name="st-open-mode"]:checked')?.value || 'current' },
            autosave: { interval: document.getElementById('st-autosave-interval').value, enabled: document.getElementById('st-autosave-enabled').checked },
            theme: document.getElementById('st-theme-preset').value,
            textColor: document.getElementById('st-text-color-text').value,
            maxPinnedPanels: parseInt(document.getElementById('st-max-pinned-panels')?.value || '4', 10),
            panelSideMap: (settingsCache.panelSideMap || {}),
            divider: { width: document.getElementById('st-divider-width').value },
            paneWidths: {
                input: document.getElementById('st-pane-input-width').value,
                preview: document.getElementById('st-pane-preview-width').value,
                memo: document.getElementById('st-pane-memo-width').value,
                outline: document.getElementById('st-pane-outline-width').value,
                structure: document.getElementById('st-pane-structure-width').value,
                search: document.getElementById('st-pane-search-width').value
            },
            paneHeights: {
                input: document.getElementById('st-pane-input-height').value,
                preview: document.getElementById('st-pane-preview-height').value
            }
        };
    }
    function applyImportedSettings(s) {
        if (s.input) { document.getElementById('st-in-size').value = s.input.size || 17; document.getElementById('st-in-line').value = s.input.line || 1.7; document.getElementById('st-in-font').value = s.input.font || 'font-mincho'; document.getElementById('st-in-v').checked = s.input.vertical !== false; }
        if (s.preview) { document.getElementById('st-pv-size').value = s.preview.size || 17; document.getElementById('st-pv-line').value = s.preview.line || 1.7; document.getElementById('st-pv-font').value = s.preview.font || 'font-mincho'; document.getElementById('st-pv-v').checked = s.preview.vertical !== false; }
        if (s.display) {
            document.getElementById('st-show-space').checked = s.display.showSpace !== false;
            document.getElementById('st-show-highlight').checked = s.display.showHighlight !== false;
            document.getElementById('check-show-input').checked = s.display.showInput !== false;
            document.getElementById('check-show-preview').checked = s.display.showPreview !== false;
            document.getElementById('st-default-preview-hidden').checked = s.display.defaultPreviewHidden || false;
        }
        if (s.writing) { document.getElementById('st-typewriter-mode').checked = s.writing.typewriter || false; document.getElementById('st-writing-tracker').checked = s.writing.tracker !== false; }
        if (s.goal) { document.getElementById('st-goal-chars').value = s.goal.chars || 150000; document.getElementById('st-today-goal').value = s.goal.today || 2000; document.getElementById('st-show-reading-time').checked = s.goal.showReading !== false; document.getElementById('st-celebrate-goal').checked = s.goal.celebrate !== false; }
        if (s.manuscript) {
            document.getElementById('st-manuscript-rows').value = s.manuscript.rows || 34;
            document.getElementById('st-manuscript-cols').value = s.manuscript.cols || 42;
            document.getElementById('st-show-manuscript').checked = s.manuscript.show !== false;
        }
        if (s.open) {
            const openMode = s.open.mode || 'current';
            const openInput = document.querySelector(`input[name="st-open-mode"][value="${openMode}"]`);
            if (openInput) openInput.checked = true;
        }
        if (s.autosave) {
            const autosaveInterval = clampValue(parseInt(s.autosave.interval, 10) || 60, 5, 600);
            const autosaveEnabled = s.autosave.enabled === true;
            document.getElementById('st-autosave-interval').value = autosaveInterval;
            document.getElementById('st-autosave-enabled').checked = autosaveEnabled;
            settingsCache.autosaveInterval = autosaveInterval;
            settingsCache.autosaveEnabled = autosaveEnabled;
        }
        if (s.theme !== undefined) document.getElementById('st-theme-preset').value = s.theme;
        if (s.maxPinnedPanels !== undefined) { const el=document.getElementById('st-max-pinned-panels'); if (el) el.value = String(s.maxPinnedPanels); settingsCache.maxPinnedPanels = parseInt(el?.value || String(s.maxPinnedPanels) || '4',10) || 4; }
        if (s.panelSideMap !== undefined) {
            try {
                const map = (typeof s.panelSideMap === 'object' && s.panelSideMap) ? s.panelSideMap : {};
                settingsCache.panelSideMap = Object.assign({}, settingsCache.panelSideMap || {}, map);
            } catch(e) {}
        }
        if (s.textColor !== undefined) {
            const normalized = normalizeHexColor(s.textColor);
            const fallback = normalized || getDefaultTextColor();
            document.getElementById('st-text-color-text').value = normalized || '';
            document.getElementById('st-text-color').value = fallback;
        }
        if (s.divider) document.getElementById('st-divider-width').value = s.divider.width || 2;
        if (s.paneWidths) {
            document.getElementById('st-pane-input-width').value = s.paneWidths.input || 520;
            document.getElementById('st-pane-preview-width').value = s.paneWidths.preview || 520;
            document.getElementById('st-pane-memo-width').value = s.paneWidths.memo || 300;
            document.getElementById('st-pane-outline-width').value = s.paneWidths.outline || 300;
            document.getElementById('st-pane-structure-width').value = s.paneWidths.structure || 300;
            document.getElementById('st-pane-search-width').value = s.paneWidths.search || 300;
        }
        if (s.paneHeights) {
            document.getElementById('st-pane-input-height').value = s.paneHeights.input || 520;
            document.getElementById('st-pane-preview-height').value = s.paneHeights.preview || 520;
        }
        if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses();
        applyAllSettings();
    }
    function exportSettings() {
        const s = collectAllSettings(); const blob = new Blob([JSON.stringify(s, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `cc_editor_settings_${getTodayDateStr()}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }
    function importSettings(input) {
        const file = input.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = e => { try { const s = JSON.parse(e.target.result); applyImportedSettings(s); alert('設定をインポートしました。'); } catch (err) { alert('設定ファイルの読み込みに失敗しました。'); } input.value = ''; };
        reader.readAsText(file);
    }
    function saveSettingsToStorage() { localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectAllSettings())); }
    function loadSettingsFromStorage() { const s = localStorage.getItem(SETTINGS_KEY); if (s) { try { applyImportedSettings(JSON.parse(s)); } catch (e) {} } }

    const defaultText = `　ⓒエディタ（使い方） v0.99

■ はじめに（最短で使い始める）

1．左の「入力」に書く
2．📲 同期（Ctrl+Shift+S）で右の「プレビュー」を更新
3．必要なら 👁 閲覧 で全タブを結合表示して読み返す
4．💾 保存 で TXT / HTML を出力（現在タブ or 全タブ結合を選べます）

■ 0. タブ（原稿を章ごとに分ける）
・タブ名：ダブルクリックでリネーム
・並べ替え：タブをドラッグして順番変更
・右クリック：複製／リネーム／閉じる等のメニュー
・タブごとに本文を保持し、閲覧や全タブ保存で結合できます 

■ 1. 入力 → プレビュー（同期）
・📲 同期：入力内容をプレビューに反映（更新）し、カーソル行へ位置合わせ
・プレビューが閉じている時に同期すると、プレビューを開いてから同期
・ショートカット：Ctrl+Shift+S 

■ 2. 閲覧（全タブ一括表示）
・👁 閲覧：全タブを結合して全画面表示（区切り記号「◆」を表示）
・閲覧内検索：右上の検索欄で検索 → ヒットはハイライト表示
・しおり：＋しおり で位置を保存／プルダウンからジャンプ
・終了：Esc か「↩ 元の画面に戻る」 

■ 3. 検索（このタブ／全タブ）＋置換
・🔍 検索パネルで「このタブ／全タブ」を切り替え
・ヒット一覧：見つかった箇所を一覧表示。クリックでその場所へジャンプ
・置換：現在ヒットのみ／全置換（このタブ／全タブ） 

■ 4. 保存（TXT / HTML）
・💾 保存 を押すと「保存形式を選択」ダイアログが開きます
・範囲：
　- 現在のタブのみ
　- 全タブを結合（章区切り付き）
・形式：📄 テキスト / 🌐 HTML 

（補足）
・HTML は「プレビューと同じ見た目」で出力されるので、提出用／印刷前確認に便利です 

■ 5. 自動保存（オートセーブ）
・自動保存ON時、保存ボタン表示が「🔄 保存」に変わります（OFFは「💾 保存」）
・一定間隔で状態を保存し、保存成功時にトースト表示します 

■ 6. 集中モード（UIを隠して執筆に集中）
・🧘 集中モード：ヘッダー／各種パネルを隠して執筆に集中（解除は Esc）
・集中モード中の“確認だけ”ショートカット：
　- Ctrl+Shift+P：プレビューを一時表示
　- Ctrl+Shift+M：メモを一時表示
　- Ctrl+Shift+O：目次を一時表示
　※一時表示は Esc で閉じます 

■ 7. 目次（見出し抽出）・しおり（ブックマーク）
・📑 目次：見出し（例：■ □ ▲ など）を自動検出して一覧化
・🔖 しおり：任意の位置を保存して、クリックでジャンプ
・目次パネル上部に「目次／🔖しおり」タブがあります
・ジャンプ履歴（◀ / ▶）で移動できます 

（しおりを素早く追加）
・選択ポップアップから「🔖しおり」を追加できます（クイック挿入） 

■ 8. メモ（複数タブ）＋インポート/エクスポート
・📝 メモ：本文とは別にメモを保持（メモもタブで複数管理）
・メモタブ：＋で追加／×で削除／ドラッグで並べ替え
・📂 開く：メモJSONを読み込み（上書き／追加を選べます）
・💾 保存：メモJSONを書き出し
・📄 TXT：メモをテキストとして保存 

■ 9. 構成（章・話・シーンのカード管理）
・📋 構成：章／話／シーンのカードを作って整理
・「＋新しいカード」：選択範囲からカード作成
・更新／全展開／全折畳／選択削除／全削除
・📂 開く／💾 保存：構成JSONの入出力、📄 TXT でテキスト出力 

■ 10. 登場人物（キャラ管理）
・👤 登場人物：役割（主人公/ヒロイン/敵役/サブ/モブ）でカード管理
・選択からカード作成／更新／全展開／全折畳／削除
・📂 開く／💾 保存：登場人物JSONの入出力、📄 TXT で一覧出力 

■ 11. 世界観（設定管理）
・🌍 世界観：大カテゴリ／中カテゴリ／詳細項目のカード管理
・選択からカード作成／更新／全展開／全折畳／削除
・📂 開く／💾 保存：世界観JSONの入出力、📄 TXT で一覧出力 

■ 12. 📊 分析（文章チェック）
・文字種別（漢字/ひらがな/カタカナ/その他）比率
・文長分析（平均/最長/長すぎ注意）
・会話文比率（「」を会話文として集計）
・頻出語 TOP15
・ヒートマップ（段落長/漢字密度/文字頻度/文末表現/句読点密度） 

■ 13. プロジェクト保存（まとめてバックアップ）
・プロジェクト保存：本文タブ／メモ／構成／登場人物／世界観／しおり／設定などを“選んで”1ファイルに保存
・プロジェクト読込：読み込むと localStorage に展開してページを再読み込みします 

■ 14. ちょい便利（クイック挿入）
・選択ポップアップから
　- 🔤ルビ
　- ⚫傍点
　- 「」/『』/（）で囲む
　- 🔖しおり追加
がワンクリックでできます 

■ 15. データの保存場所（重要）
・基本データはブラウザ内（localStorage）に保存されます
・ブラウザの「サイトデータ削除」「プライベートモード」「端末変更」では消える可能性があるため、
　定期的に「💾保存」や「プロジェクト保存」で外部ファイルとしてバックアップ推奨

（このタブは初期化すると復元されます）
`;


    const sampleText = `奉教人の死
芥川龍之介

　たとひ三百歳の齢《よはひ》を保ち、楽しみ身に余ると云ふとも、未来永々の果しなき楽しみに比ぶれば、夢幻《ゆめまぼろし》の如し。
　―慶長訳 Guia do Pecador―

　善の道に立ち入りたらん人は、御教《みをしへ》にこもる不可思議の甘味を覚ゆべし。
　―慶長訳 Imitatione Christi―

　　　　　　　Ⅰ

　去《さ》んぬる頃、日本長崎の「さんた・るちや」と申す「えけれしや」（寺院）に、「ろおれんぞ」と申すこの国の少年がござつた。これは或年御降誕の祭の夜、その「えけれしや」の戸口に、餓ゑ疲れてうち伏して居つたを、参詣の奉教人衆《ほうけうにんしゆう》が介抱し、それより伴天連《ばてれん》の憐みにて、寺中に養はれる事となつたげでござるが、何故かその身の素性《すじやう》を問へば、故郷《ふるさと》は「はらいそ」（天国）父の名は「でうす」（天主）などと、何時も事もなげな笑に紛らいて、とんとまことは明した事もござない。なれど親の代から「ぜんちよ」（異教徒）の輩《ともがら》であらなんだ事だけは、手くびにかけた青玉《あをだま》の「こんたつ」（念珠）を見ても、知れたと申す。されば伴天連はじめ、多くの「いるまん」衆（法兄弟）も、よも怪しいものではござるまいとおぼされて、ねんごろに扶持して置かれたが、その信心の堅固なは、幼いにも似ず「すぺりおれす」（長老衆）が舌を捲くばかりであつたれば、一同も「ろおれんぞ」は天童の生れがはりであらうずなど申し、いづくの生れ、たれの子とも知れぬものを、無下《むげ》にめでいつくしんで居つたげでござる。
　して又この「ろおれんぞ」は、顔かたちが玉のやうに清らかであつたに、声ざまも女のやうに優しかつたれば、一《ひと》しほ人々のあはれみを惹《ひ》いたのでござらう。中でもこの国の「いるまん」に「しめおん」と申したは、「ろおれんぞ」を弟《おとと》のやうにもてなし、「えけれしや」の出入りにも、必《かならず》仲よう手を組み合せて居つた。この「しめおん」は、元さる大名に仕へた、槍一すぢの家がらなものぢや。されば身のたけも抜群なに、性得《しやうとく》の剛力であつたに由つて、伴天連が「ぜんちよ」ばらの石瓦にうたるるを、防いで進ぜた事も、一度二度の沙汰ではごさない。それが「ろおれんぞ」と睦《むつま》じうするさまは、とんと鳩になづむ荒鷲のやうであつたとも申さうか。或は「ればのん」山の檜《ひのき》に、葡萄《えび》かづらが纏《まと》ひついて、花咲いたやうであつたとも申さうず。
　さる程に三年あまりの年月は、流るるやうにすぎたに由つて、「ろおれんぞ」はやがて元服もすべき時節となつた。したがその頃怪しげな噂が伝はつたと申すは、「さんた・るちや」から遠からぬ町方の傘張の娘が、「ろおれんぞ」と親しうすると云ふ事ぢや。この傘張の翁《おきな》も天主の御教を奉ずる人故、娘ともども「えけれしや」へは参る慣《ならはし》であつたに、御祈の暇にも、娘は香炉をさげた「ろおれんぞ」の姿から、眼を離したと申す事がござない。まして「えけれしや」への出入りには、必《かならず》髪かたちを美しうして、「ろおれんぞ」のゐる方へ眼づかひをするが定《ぢやう》であつた。さればおのづと奉教人衆の人目にも止り、娘が行きずりに「ろおれんぞ」の足を踏んだと云ひ出すものもあれば、二人が艶書をとりかはすをしかと見とどけたと申すものも、出て来たげでござる。
　由つて伴天連にも、すて置かれず思《おぼ》されたのでござらう。或日「ろおれんぞ」を召されて、白ひげを噛みながら、「その方、傘張の娘と兎角の噂ある由を聞いたが、よもやまことではあるまい。どうぢや」ともの優しう尋ねられた。したが「ろおれんぞ」は、唯《ただ》憂はしげに頭を振つて、「そのやうな事は一向に存じよう筈もござらぬ」と、涙声に繰返すばかり故、伴天達もさすがに我《が》を折られて、年配と云ひ、日頃の信心と云ひ、かうまで申すものに偽はあるまいと思されたげでござる。
　さて一応伴天連の疑《うたがひ》は晴れてぢやが、「さんた・るちや」へ参る人々の間では、容易にとかうの沙汰が絶えさうもござない。されば兄弟同様にして居つた「しめおん」の気がかりは、又人一倍ぢや。始はかやうな淫《みだら》な事を、ものものしう詮議立てするが、おのれにも恥しうて、うちつけに尋ねようは元より、「ろおれんぞ」の顔さへまさかとは見られぬ程であつたが、或時「さんた・るちや」の後の庭で、「ろおれんぞ」へ宛てた娘の艶書を拾うたに由つて、人気《ひとけ》ない部屋にゐたを幸《さいはひ》、「ろおれんぞ」の前にその文をつきつけて、嚇《おど》しつ賺《すか》しつ、さまざまに問ひただいた。なれど「ろおれんぞ」は唯、美しい顔を赤らめて、「娘は私に心を寄せましたげでござれど、私は文を貰うたばかり、とんと口を利《き》いた事もござらぬ」と申す。なれど世間のそしりもある事でござれば、「しめおん」は猶《なほ》も押して問ひ詰《なじ》つたに、「ろおれんぞ」はわびしげな眼で、ぢつと相手を見つめたと思へば、「私はお主《ぬし》にさへ、嘘をつきさうな人間に見えるさうな」と、咎《とが》めるやうに云ひ放つて、とんと燕《つばくろ》か何ぞのやうに、その儘つと部屋を立つて行つてしまうた。かう云はれて見れば、「しめおん」も己の疑深かつたのが恥しうもなつたに由つて、悄々《すごすご》その場を去らうとしたに、いきなり駈けこんで来たは、少年の「ろおれんぞ」ぢや。それが飛びつくやうに「しめおん」の頸《うなじ》を抱くと、喘《あへ》ぐやうに「私が悪かつた。許して下されい」と囁《ささや》いて、こなたが一言《ひとこと》も答へぬ間に、涙に濡れた顔を隠さう為か、相手をつきのけるやうに身を開いて、一散に又元来た方へ、走つて往《い》んでしまうたと申す。さればその「私が悪かつた」と囁いたのも、娘と密通したのが悪かつたと云ふのやら、或は「しめおん」につれなうしたのが悪かつたと云ふのやら、一円合点《いちゑんがてん》の致さうやうがなかつたとの事でござる。
　するとその後間もなう起つたのは、その傘張の娘が孕《みごも》つたと云ふ騒ぎぢや。しかも腹の子の父親は、「さんた・るちや」の「ろおれんぞ」ぢやと、正《まさ》しう父の前で申したげでござる。されば傘張の翁は火のやうに憤《いきどほ》つて、即刻伴天連のもとへ委細を訴へに参つた。かうなる上は「ろおれんぞ」も、かつふつ云ひ訳の致しやうがござない。その日の中に伴天連を始め、「いるまん」衆一同の談合に由つて、破門を申し渡される事になつた。元より破門の沙汰がある上は、伴天連の手もとをも追ひ払はれる事でござれば、糊口のよすがに困るのも目前ぢや。したがかやうな罪人を、この儘「さんた・るちや」に止めて置いては、御主《おんあるじ》の「ぐろおりや」（栄光）にも関《かかは》る事ゆゑ、日頃親しう致いた人々も、涙をのんで「ろおれんぞ」を追ひ払つたと申す事でござる。
　その中でも哀れをとどめたは、兄弟のやうにして居つた「しめおん」の身の上ぢや。これは「ろおれんぞ」が追ひ出されると云ふ悲しさよりも、「ろおれんぞ」に欺かれたと云ふ腹立たしさが一倍故、あのいたいけな少年が、折からの凩《こがらし》が吹く中へ、しをしをと戸口を出かかつたに、傍から拳《こぶし》をふるうて、したたかその美しい顔を打つた。「ろおれんぞ」は剛力に打たれたに由つて、思はずそこへ倒れたが、やがて起きあがると、涙ぐんだ眼で、空を仰ぎながら、「御主も許させ給へ。『しめおん』は、己《おの》が仕業もわきまへぬものでござる」と、わななく声で祈つたと申す事ぢや。「しめおん」もこれには気が挫けたのでござらう。暫くは唯戸口に立つて、拳を空《くう》にふるうて居つたが、その外の「いるまん」衆も、いろいろととりないたれば、それを機会《しほ》に手を束《つか》ねて、嵐も吹き出でようず空の如く、凄《すさま》じく顔を曇らせながら、悄々《すごすご》「さんた・るちや」の門を出る「ろおれんぞ」の後姿を、貪るやうにきつと見送つて居つた。その時居合はせた奉教人衆の話を伝へ聞けば、時しも凩にゆらぐ日輪が、うなだれて歩む「ろおれんぞ」の頭のかなた、長崎の西の空に沈まうず景色であつたに由つて、あの少年のやさしい姿は、とんと一天の火焔の中に、立ちきはまつたやうに見えたと申す。
　その後の「ろおれんぞ」は、「さんた・るちや」の内陣に香炉をかざした昔とは打つて変つて、町はづれの非人小屋に起き伏しする、世にも哀れな乞食《こつじき》であつた。ましてその前身は、「ぜんちよ」の輩《ともがら》にはゑとりのやうにさげしまるる、天主の御教を奉ずるものぢや。されば町を行けば、心ない童部《わらべ》に嘲《あざけ》らるるは元より、刀杖瓦石《たうぢやうぐわせき》の難に遭《あ》うた事も、度々ござるげに聞き及んだ。いや、嘗《か》つては、長崎の町にはびこつた、恐しい熱病にとりつかれて、七日七夜の間、道ばたに伏しまろんでは、苦み悶《もだ》えたとも申す事でござる。したが、「でうす」無量無辺の御愛憐は、その都度「ろおれんぞ」が一命を救はせ給うたのみか、施物の米銭のない折々には、山の木の実、海の魚介など、その日の糧《かて》を恵ませ給ふのが常であつた。由つて「ろおれんぞ」も、朝夕の祈は「さんた・るちや」に在つた昔を忘れず、手くびにかけた「こんたつ」も、青玉の色を変へなかつたと申す事ぢや。なんの、それのみか、夜毎に更闌《かうた》けて人音も静まる頃となれば、この少年はひそかに町はづれの非人小屋を脱け出《いだ》いて、月を踏んでは住み馴れた「さんた・るちや」へ、御主「ぜす・きりしと」の御加護を祈りまゐらせに詣でて居つた。
　なれど同じ「えけれしや」に詣づる奉教人衆も、その頃はとんと「ろおれんぞ」を疎《うと》んじはてて、伴天連はじめ、誰一人憐みをかくるものもござらなんだ。ことわりかな、破門の折から所行無慚《しよぎやうむざん》の少年と思ひこんで居つたに由つて、何として夜毎に、独り「えけれしや」へ参る程の、信心ものぢやとは知られうぞ。これも「でうす」千万無量の御計らひの一つ故、よしない儀とは申しながら、「ろおれんぞ」が身にとつては、いみじくも亦哀れな事でござつた。
　さる程に、こなたはあの傘張の娘ぢや。「ろおれんぞ」が破門されると間もなく、月も満たず女の子を産み落いたが、さすがにかたくなしい父の翁も、初孫の顔は憎からず思うたのでござらう、娘ともども大切に介抱して、自ら抱きもしかかへもし、時にはもてあそびの人形などもとらせたと申す事でござる。翁は元よりさもあらうずなれど、ここに稀有《けう》なは「いるまん」の「しめおん」ぢや。あの「ぢやぼ」（悪魔）をも挫《ひし》がうず大男が、娘に子が産まれるや否や、暇ある毎に傘張の翁を訪れて、無骨な腕に幼子を抱き上げては、にがにがしげな顔に涙を浮べて、弟と愛《いつく》しんだ、あえかな「ろおれんぞ」の優姿を、思ひ慕つて居つたと申す。唯、娘のみは、「さんた・るちや」を出でてこの方、絶えて「ろおれんぞ」が姿を見せぬのを、怨めしう歎きわびた気色《けしき》であつたれば、「しめおん」の訪れるのさへ、何かと快からず思ふげに見えた。
　この国の諺《ことわざ》にも、光陰に関守《せきもり》なしと申す通り、とかうする程に、一年《ひととせ》あまりの年月は、瞬《またた》くひまに過ぎたと思召《おぼしめ》されい。ここに思ひもよらぬ大変が起つたと申すは、一夜の中に長崎の町の半ばを焼き払つた、あの大火事のあつた事ぢや。まことにその折の景色の凄じさは、末期《まつご》の御裁判《おんさばき》の喇叭《らつぱ》の音が、一天の火の光をつんざいて、鳴り渡つたかと思はれるばかり、世にも身の毛のよだつものでござつた。その時、あの傘張の翁の家は、運悪う風下にあつたに由つて、見る見る焔に包れたが、さて親子｜眷族《けんぞく》、慌てふためいて、逃げ出《いだ》いて見れば、娘が産んだ女の子の姿が見えぬと云ふ始末ぢや。一定《いちぢやう》、一間《ひとま》どころに寝かいて置いたを、忘れてここまで逃げのびたのであらうず。されば翁は足ずりをして罵りわめく。娘も亦、人に遮《さへぎ》られずば、火の中へも馳《は》せ入つて、助け出さう気色《けしき》に見えた。なれど風は益《ますます》加はつて、焔の舌は天上の星をも焦さうず吼《たけ》りやうぢや。それ故火を救ひに集つた町方の人々も、唯、あれよあれよと立ち騒いで、狂気のやうな娘をとり鎮めるより外に、せん方も亦あるまじい。所へひとり、多くの人を押しわけて、馳《か》けつけて参つたは、あの「いるまん」の「しめおん」でござる。これは矢玉の下もくぐつたげな、逞しい大丈夫でござれば、ありやうを見るより早く、勇んで焔の中へ向うたが、あまりの火勢に辟易《へきえき》致いたのでござらう。二三度煙をくぐつたと見る間に、背《そびら》をめぐらして、一散に逃げ出いた。して翁と娘とが佇《たたず》んだ前へ来て、「これも『でうす』万事にかなはせたまふ御計らひの一つぢや。詮ない事とあきらめられい」と申す。その時翁の傍から、誰とも知らず、高らかに「御主《おんあるじ》、助け給へ」と叫ぶものがござつた。声ざまに聞き覚えもござれば、「しめおん」が頭《かうべ》をめぐらして、その声の主をきつと見れば、いかな事、これは紛《まが》ひもない「ろおれんぞ」ぢや。清らかに痩せ細つた顔は、火の光に赤うかがやいて、風に乱れる黒髪も、肩に余るげに思はれたが、哀れにも美しい眉目《みめ》のかたちは、一目見てそれと知られた。その「ろおれんぞ」が、乞食の姿のまま、群《むらが》る人々の前に立つて、目もはなたず燃えさかる家を眺めて居る。と思うたのは、まことに瞬《またた》く間もない程ぢや。一しきり焔を煽《あふ》つて、恐しい風が吹き渡つたと見れば、「ろおれんぞ」の姿はまつしぐらに、早くも火の柱、火の壁、火の梁《うつばり》の中にはいつて居つた。「しめおん」は思はず遍身に汗を流いて、空高く「くるす」（十字）を描きながら、己も「御主、助け給へ」と叫んだが、何故かその時心の眼には、凩《こがらし》に揺るる日輪の光を浴びて、「さんた・るちや」の門に立ちきはまつた、美しく悲しげな、「ろおれんぞ」の姿が浮んだと申す。
　なれどあたりに居つた奉教人衆は、「ろおれんぞ」が健気《けなげ》な振舞に驚きながらも、破戒の昔を忘れかねたのでもござらう。忽《たちまち》兎角の批判は風に乗つて、人どよめきの上を渡つて参つた。と申すは、「さすが親子の情あひは争はれぬものと見えた。己が身の罪を恥ぢて、このあたりへは影も見せなんだ『ろおれんぞ』が、今こそ一人子の命を救はうとて、火の中へはいつたぞよ」と、誰ともなく罵りかはしたのでござる。これには翁《おきな》さへ同心と覚えて、「ろおれんぞ」の姿を眺めてからは、怪しい心の騒ぎを隠さうず為か、立ちつ居つ身を悶えて、何やら愚《おろか》しい事のみを、声高《こわだか》にひとりわめいて［＃「わめいて」は底本では「わめいつて」］居つた。なれど当の娘ばかりは、狂ほしく大地に跪《ひざまづ》いて、両の手で顔をうづめながら、一心不乱に祈誓を凝《こ》らいて、身動きをする気色さへもござない。その空には火の粉が雨のやうに降りかかる。煙も地を掃《はら》つて、面《おもて》を打つた。したが娘は黙然と頭を垂れて、身も世も忘れた祈り三昧《ざんまい》でござる。
　とかうする程に、再《ふたたび》火の前に群つた人々が、一度にどつとどよめくかと見れば、髪をふり乱いた「ろおれんぞ」が、もろ手に幼子をかい抱いて、乱れとぶ焔の中から、天《あま》くだるやうに姿を現《あらは》いた。なれどその時、燃え尽きた梁《うつばり》の一つが、俄《にはか》に半ばから折れたのでござらう。凄じい音と共に、一なだれの煙焔《えんえん》が半空《なかぞら》に迸《ほとばし》つたと思ふ間もなく、「ろおれんぞ」の姿ははたと見えずなつて、跡には唯火の柱が、珊瑚の如くそば立つたばかりでござる。
　あまりの凶事に心も消えて、「しめおん」をはじめ翁まで、居あはせた程の奉教人衆は、皆目の眩《くら》む思ひがござつた。中にも娘はけたたましう泣き叫んで、一度は脛《はぎ》もあらはに躍り立つたが、やがて雷《いかづち》に打たれた人のやうに、そのまま大地にひれふしたと申す。さもあらばあれ、ひれふした娘の手には、何時かあの幼い女の子が、生死不定《しやうじふぢやう》の姿ながら、ひしと抱かれて居つたをいかにしようぞ。ああ、広大無辺なる「でうす」の御知慧《おんちゑ》、御力は、何とたたへ奉る詞《ことば》だにござない。燃え崩れる梁に打たれながら、「ろおれんぞ」が必死の力をしぼつて、こなたへ投げた幼子は、折よく娘の足もとへ、怪我もなくまろび落ちたのでござる。
　されば娘が大地にひれ伏して、嬉し涙に咽《むせ》んだ声と共に、もろ手をさしあげて立つた翁の口からは、「でうす」の御慈悲をほめ奉る声が、自らおごそかに溢れて参つた。いや、まさに溢れようずけはひであつたとも申さうか。それより先に「しめおん」は、さかまく火の嵐の中へ、「ろおれんぞ」を救はうず一念から、真一文字に躍りこんだに由つて、翁の声は再《ふたたび》気づかはしげな、いたましい祈りの言《ことば》となつて、夜空に高くあがつたのでござる。これは元より翁のみではござない。親子を囲んだ奉教人衆は、皆一同に声を揃へて、「御主、助け給へ」と、泣く泣く祈りを捧げたのぢや。して「びるぜん・まりや」の御子《みこ》、なべての人の苦しみと悲しみとを己《おの》がものの如くに見そなはす、われらが御主「ぜす・きりしと」は、遂にこの祈りを聞き入れ給うた。見られい。むごたらしう焼けただれた「ろおれんぞ」は、「しめおん」が腕に抱かれて、早くも火と煙とのただ中から、救ひ出されて参つたではないか。
　なれどその夜の大変は、これのみではござなんだ。息も絶え絶えな「ろおれんぞ」が、とりあへず奉教人衆の手に舁《か》かれて、風上にあつたあの「えけれしや」の門へ横へられた時の事ぢや。それまで幼子を胸に抱きしめて、涙にくれてゐた傘張の娘は、折から門へ出でられた伴天連の足もとに跪《ひざまづ》くと、並み居る人々の目前で、「この女子《をなご》は『ろおれんぞ』様の種ではおぢやらぬ。まことは妾が家隣の『ぜんちよ』の子と密通して、まうけた娘でおぢやるわいの」と思ひもよらぬ「こひさん」（懴悔）を仕《つかま》つた。その思ひつめた声ざまの震へと申し、その泣きぬれた双の眼のかがやきと申し、この「こひさん」には、露ばかりの偽さへ、あらうとは思はれ申さぬ。道理《ことわり》かな、肩を並べた奉教人衆は、天を焦がす猛火も忘れて、息さへつかぬやうに声を呑んだ。
　娘が涙ををさめて、申し次いだは、「妾は日頃『ろおれんぞ』様を恋ひ慕うて居つたなれど、御信心の堅固さからあまりにつれなくもてなされる故、つい怨む心も出て、腹の子を『ろおれんぞ』様の種と申し偽り、妾につらかつた口惜しさを思ひ知らさうと致いたのでおぢやる。なれど『ろおれんぞ』様のお心の気高さは、妾が大罪をも憎ませ給はいで、今宵は御身の危さをもうち忘れ、『いんへるの』（地獄）にもまがふ火焔の中から、妾娘の一命を辱《かたじけな》くも救はせ給うた。その御憐み、御計らひ、まことに御主『ぜす・きりしと』の再来かともをがまれ申す。さるにても妾が重々の極悪を思へば、この五体は忽《たちまち》『ぢやぼ』の爪にかかつて、寸々に裂かれようとも、中々怨む所はおぢやるまい。」娘は「こひさん」を致いも果てず、大地に身を投げて泣き伏した。
　二重三重《ふたへみへ》に群つた奉教人衆の間から、「まるちり」（殉教）ぢや、「まるちり」ぢやと云ふ声が、波のやうに起つたのは、丁度この時の事でござる。殊勝にも「ろおれんぞ」は、罪人を憐む心から、御主「ぜす・きりしと」の御行跡を踏んで、乞食にまで身を落いた。して父と仰ぐ伴天連も、兄とたのむ「しめおん」も、皆その心を知らなんだ。これが「まるちり」でなうて、何でござらう。
　したが、当の「ろおれんぞ」は、娘の「こひさん」を聞きながらも、僅に二三度｜頷《うなづ》いて見せたばかり、髪は焼け肌は焦げて、手も足も動かぬ上に、口をきかう気色《けしき》さへも今は全く尽きたげでござる。娘の「こひさん」に胸を破つた翁と「しめおん」とは、その枕がみに蹲《うづくま》つて、何かと介抱を致いて居つたが、「ろおれんぞ」の息は、刻々に短うなつて、最期《さいご》ももはや遠くはあるまじい。唯、日頃と変らぬのは、遙に天上を仰いで居る、星のやうな瞳の色ばかりぢや。
　やがて娘の「こひさん」に耳をすまされた伴天連は、吹き荒《すさ》ぶ夜風に白ひげをなびかせながら、「さんた・るちや」の門を後にして、おごそかに申されたは、「悔い改むるものは、幸《さいはひ》ぢや。何しにその幸なものを、人間の手に罰しようぞ。これより益《ますます》、『でうす』の御戒《おんいましめ》を身にしめて、心静に末期《まつご》の御裁判《おんさばき》の日を待つたがよい。又『ろおれんぞ』がわが身の行儀を、御主『ぜす・きりしと』とひとしく奉らうず志は、この国の奉教人衆の中にあつても、類《たぐひ》稀なる徳行でござる。別して少年の身とは云ひ――」ああ、これは又何とした事でござらうぞ。ここまで申された伴天連は、俄《にはか》にはたと口を噤《つぐ》んで、あたかも「はらいそ」の光を望んだやうに、ぢつと足もとの「ろおれんぞ」の姿を見守られた。その恭《うやうや》しげな容子《ようす》はどうぢや。その両の手のふるへざまも、尋常《よのつね》の事ではござるまい。おう、伴天連のからびた頬の上には、とめどなく涙が溢れ流れるぞよ。
　見られい。「しめおん」。見られい。傘張の翁。御主「ぜす・きりしと」の御血潮よりも赤い、火の光を一身に浴びて、声もなく「さんた・るちや」の門に横はつた、いみじくも美しい少年の胸には、焦げ破れた衣《ころも》のひまから、清らかな二つの乳房が、玉のやうに露《あらは》れて居るではないか。今は焼けただれた面輪《おもわ》にも、自《おのづか》らなやさしさは、隠れようすべもあるまじい。おう、「ろおれんぞ」は女ぢや。「ろおれんぞ」は女ぢや。見られい。猛火を後にして、垣のやうに佇んでゐる奉教人衆、邪淫の戒を破つたに由つて「さんた・るちや」を逐《お》はれた「ろおれんぞ」は、傘張の娘と同じ、眼《ま》なざしのあでやかなこの国の女ぢや。
　まことにその刹那《せつな》の尊い恐しさは、あたかも「でうす」の御声が、星の光も見えぬ遠い空から、伝はつて来るやうであつたと申す。されば「さんた・るちや」の前に居並んだ奉教人衆は、風に吹かれる穂麦のやうに、誰からともなく頭を垂れて、悉《ことごとく》「ろおれんぞ」のまはりに跪《ひざまづ》いた。その中で聞えるものは、唯、空をどよもして燃えしきる、万丈の焔の響ばかりでござる。いや、誰やらの啜《すす》り泣く声も聞えたが、それは傘張の娘でござらうか。或は又自ら兄とも思うた、あの「いるまん」の「しめおん」でござらうか。やがてその寂寞《じやくまく》たるあたりをふるはせて、「ろおれんぞ」の上に高く手をかざしながら、伴天連の御経を誦《ず》せられる声が、おごそかに悲しく耳にはいつた。して御経の声がやんだ時、「ろおれんぞ」と呼ばれた、この国のうら若い女は、まだ暗い夜のあなたに、「はらいそ」の「ぐろおりや」を仰ぎ見て、安らかなほほ笑みを唇に止めたまま、静に息が絶えたのでござる。……
　その女の一生は、この外に何一つ、知られなんだげに聞き及んだ。なれどそれが、何事でござらうぞ。なべて人の世の尊さは、何ものにも換へ難い、刹那の感動に極るものぢや。暗夜の海にも譬《たと》へようず煩悩心《ぼんなうしん》の空に一波をあげて、未《いまだ》出ぬ月の光を、水沫《みなわ》の中に捕へてこそ、生きて甲斐ある命とも申さうず。されば「ろおれんぞ」が最期を知るものは、「ろおれんぞ」の一生を知るものではござるまいか。

　　　　　　　Ⅱ

　予が所蔵に関る、長崎耶蘇会出版の一書、題して「れげんだ・おうれあ」と云ふ。蓋《けだ》し、LEGENDA AUREA の意なり。されど内容は必しも、西欧の所謂《いはゆる》「黄金伝説」ならず。彼土《かのど》の使徒聖人が言行を録すると共に、併《あは》せて本邦西教徒が勇猛精進の事蹟をも採録し、以て福音伝道の一助たらしめんとせしものの如し。
　体裁は上下二巻、美濃紙摺《みのがみずり》草体交《さうたいまじ》り平仮名文にして、印刷甚しく鮮明を欠き、活字なりや否やを明にせず。上巻の扉には、羅甸《ラテン》字にて書名を横書し、その下に漢字にて「御出世以来千五百九十六年、慶長二年三月上旬｜鏤刻《るこく》也」の二行を縦書す。年代の左右には喇叭《らつぱ》を吹ける天使の画像あり。技巧｜頗《すこぶる》幼稚なれども、亦｜掬《きく》す可き趣致なしとせず。下巻も扉に「五月中旬鏤刻也」の句あるを除いては、全く上巻と異同なし。
　両巻とも紙数は約六十頁にして、載《の》する所の黄金伝説は、上巻八章、下巻十章を数ふ。その他各巻の巻首に著者不明の序文及｜羅甸《ラテン》字を加へたる目次あり。序文は文章｜雅馴《がじゆん》ならずして、間々《まま》欧文を直訳せる如き語法を交へ、一見その伴天連たる西人の手になりしやを疑はしむ。
　以上採録したる「奉教人の死」は、該《がい》「れげんだ・おうれあ」下巻第二章に依るものにして、恐らくは当時長崎の一西教寺院に起りし、事実の忠実なる記録ならんか。但、記事中の大火なるものは、「長崎港草」以下諸書に徴するも、その有無をすら明にせざるを以て、事実の正確なる年代に至つては、全くこれを決定するを得ず。
　予は「奉教人の死」に於て、発表の必要上、多少の文飾を敢《あへ》てしたり。もし原文の平易雅馴なる筆致にして、甚しく毀損《きそん》せらるる事なからんか、予の幸甚とする所なりと云爾《しかいふ》。
　　（大正七年八月）`;

    function confirmResetInput() {
        const first = confirm('入力を初期化しますが、よろしいですか？');
        if (!first) return;
        const second = confirm('本当に初期化します。全部消えますよ？');
        if (!second) return;
        resetInputToStartup();
    }

    // === 新規プロジェクト（コンテンツのみ初期化。見た目/レイアウト設定は維持） ===
    
    // === 新規プロジェクト（コンテンツのみ初期化。見た目/レイアウト設定は維持） ===
    // 新規開始時は、先にプロジェクト保存ダイアログを自動で開いて退避を促す
    let __ccNewProjectFlowActive = false;

    function __ccSetProjectSaveDialogMode(forNewProject) {
        const hint = document.getElementById('proj-save-newproject-hint');
        const bSave = document.getElementById('btn-proj-save');
        const bSaveNew = document.getElementById('btn-proj-save-and-new');
        const bSkipNew = document.getElementById('btn-proj-skip-and-new');
        if (hint) hint.style.display = forNewProject ? 'block' : 'none';
        if (bSave) bSave.style.display = forNewProject ? 'none' : 'inline-block';
        if (bSaveNew) bSaveNew.style.display = forNewProject ? 'inline-block' : 'none';
        if (bSkipNew) bSkipNew.style.display = forNewProject ? 'inline-block' : 'none';
    }

    function confirmStartNewProject() {
        __ccNewProjectFlowActive = true;
        __ccSetProjectSaveDialogMode(true);
        openProjectSaveDialog();
    }

    function executeProjectSaveAndContinueNewProject() {
        // 保存後に新規開始の確認へ進む
        try { executeProjectSave(); } catch (e) {}
        // ダウンロード開始後にダイアログが閉じるので、少し待ってから続行
        setTimeout(() => {
            __ccContinueNewProjectAfterPrompt();
        }, 50);
    }

    function skipProjectSaveAndContinueNewProject() {
        closeProjectSaveDialog();
        __ccContinueNewProjectAfterPrompt();
    }

    function __ccContinueNewProjectAfterPrompt() {
        // モード解除
        __ccNewProjectFlowActive = false;
        __ccSetProjectSaveDialogMode(false);

        const first = confirm('新規プロジェクトを開始しますか？（本文・メモ・構成/人物/世界観カード・ブックマーク等が消えます）');
        if (!first) return;
        const second = confirm('本当に新規プロジェクトを開始します。よろしいですか？');
        if (!second) return;
        startNewProject();
    }

    function startNewProject() {
        // --- コンテンツ系の保存データをクリア ---
        try { localStorage.removeItem(TABS_KEY); } catch(e){}
        try { localStorage.removeItem(MEMO_KEY); } catch(e){}
        try { localStorage.removeItem(BOOKMARKS_KEY); } catch(e){}
        try { localStorage.removeItem(NOVEL_TITLE_KEY); } catch(e){}
        try { localStorage.removeItem(TODAY_START_KEY); } catch(e){}
        try { localStorage.removeItem(WRITING_TIME_KEY); } catch(e){}
        try { localStorage.removeItem('cc_outline_rules_v1'); } catch(e){}
        try { localStorage.removeItem('cc_reader_bookmarks_v1'); } catch(e){}
        try { localStorage.removeItem('cc_reader_bookmarks_v2'); } catch(e){}

        // 構成/人物/世界観カード
        try { localStorage.removeItem('cc_structure_data');
        localStorage.removeItem('cc_character_data');
        localStorage.removeItem('cc_world_data');
        localStorage.removeItem('cc_terms_data'); } catch(e){}
        try { localStorage.removeItem('cc_character_data'); } catch(e){}
        try { localStorage.removeItem('cc_world_data');
        localStorage.removeItem('cc_terms_data'); } catch(e){}

        // --- 画面上の状態も初期化 ---
        inputTabs = [{ id: 1, name: '本文', content: '' }];
        window.inputTabs = inputTabs;
        activeTabId = 1;
        nextTabId = 2;
        previewTabId = null;
        previewShowAll = false;
        bookmarks = [];
        todayStartChars = 0;
        writingSeconds = 0;

        memoTabs = [{ id: 1, name: 'メモ1', content: '' }];
        window.memoTabs = memoTabs;
        activeMemoTabId = 1;
        nextMemoTabId = 2;

        if (inputArea) inputArea.value = '';
        if (memoArea) memoArea.value = '';
        setNovelTitle(DEFAULT_NOVEL_TITLE);

        // 再描画＆保存
        renderInputTabs();
        renderPreviewTabs();
        renderBookmarks();
        renderMemoTabs();
        updateInputStats();
        updateMemoCharCount();
        updatePreview();
        saveTabsToStorage();
        saveMemoTabs();
        saveWritingTime();

        // パネル側も空状態に
        if (typeof window.initStructureFromReset === 'function') window.initStructureFromReset();
        if (typeof window.initCharacterFromReset === 'function') window.initCharacterFromReset();
        if (typeof window.initWorldFromReset === 'function') window.initWorldFromReset();

        // 日次カウンタなどの初期化
        applyDefaultStartupLayoutAfterReset();
    }

    function resetInputToStartup() {
        // コンテンツのリセット
        inputTabs = [
            { id: 1, name: 'タブはリネームできます', content: defaultText },
            { id: 2, name: '見本', content: sampleText }
        ];
        window.inputTabs = inputTabs;
        activeTabId = 1;
        nextTabId = 3;
        inputArea.value = defaultText;
        previewTabId = null;
        previewShowAll = false;
        bookmarks = [];
        todayStartChars = 0;
        writingSeconds = 0;
        memoTabs = [{ id: 1, name: 'メモ1', content: '' }];
        window.memoTabs = memoTabs;
        activeMemoTabId = 1;
        nextMemoTabId = 2;
        memoArea.value = '';
        setNovelTitle(DEFAULT_NOVEL_TITLE);
        autoSaveTarget = { handle: null, type: null, scope: 'current' };
        settingsCache.autosaveInterval = 60;
        setAutoSaveEnabled(false);

        // 設定のリセット（すべての設定を初期値に）
        document.getElementById('st-in-size').value = 17;
        document.getElementById('st-in-line').value = 1.7;
        document.getElementById('st-in-font').value = 'font-gothic';
        document.getElementById('st-in-v').checked = true;
        document.getElementById('st-pv-size').value = 17;
        document.getElementById('st-pv-line').value = 1.7;
        document.getElementById('st-pv-font').value = 'font-gothic';
        document.getElementById('st-pv-v').checked = true;
        document.getElementById('check-show-input').checked = true;
        document.getElementById('check-show-preview').checked = true;
        document.getElementById('st-show-space').checked = true;
        document.getElementById('st-show-highlight').checked = true;
        document.getElementById('st-default-preview-hidden').checked = false;
        document.getElementById('st-typewriter-mode').checked = false;
        document.getElementById('st-writing-tracker').checked = true;
        document.getElementById('st-goal-chars').value = 150000;
        document.getElementById('st-today-goal').value = 2000;
        document.getElementById('st-celebrate-goal').checked = true;
        document.getElementById('st-show-reading-time').checked = true;
        document.getElementById('st-manuscript-rows').value = 34;
        document.getElementById('st-manuscript-cols').value = 42;
        document.getElementById('st-show-manuscript').checked = true;
        document.querySelector('input[name="st-open-mode"][value="current"]').checked = true;
        document.getElementById('st-autosave-interval').value = 60;
        document.getElementById('st-autosave-enabled').checked = false;
        document.getElementById('st-theme-preset').value = '';
        document.getElementById('st-text-color-text').value = '';
        document.getElementById('st-text-color').value = '#1f2937';
        const __mp = document.getElementById('st-max-pinned-panels'); if (__mp) __mp.value = '4';
        document.getElementById('st-pane-input-width').value = 520;
        document.getElementById('st-pane-preview-width').value = 520;
        document.getElementById('st-pane-memo-width').value = 260;
        document.getElementById('st-pane-outline-width').value = 260;
        document.getElementById('st-pane-structure-width').value = 300;
        document.getElementById('st-pane-search-width').value = 320;
        document.getElementById('st-divider-width').value = 2;
        const inputH = document.getElementById('st-pane-input-height');
        const previewH = document.getElementById('st-pane-preview-height');
        if (inputH) inputH.value = 520;
        if (previewH) previewH.value = 520;

        // localStorage をクリア
        localStorage.removeItem(TABS_KEY);
        localStorage.removeItem(AUTOSAVE_KEY);
        localStorage.removeItem(TODAY_START_KEY);
        localStorage.removeItem(BOOKMARKS_KEY);
        localStorage.removeItem(MEMO_KEY);
        localStorage.removeItem(NOVEL_TITLE_KEY);
        localStorage.removeItem(SETTINGS_KEY);
        localStorage.removeItem(DIVIDER_WIDTH_KEY);
        localStorage.removeItem('cc_outline_rules_v1');
        localStorage.removeItem('cc_active_tab_color');
        localStorage.removeItem('cc_reader_bookmarks_v1');
        localStorage.removeItem('cc_reader_bookmarks_v2');
        localStorage.removeItem('cc_structure_data');
        localStorage.removeItem('cc_character_data');
        localStorage.removeItem('cc_world_data');
        localStorage.removeItem('cc_pane_colors_v3');
        localStorage.removeItem(TEXT_COLOR_KEY);
        sessionStorage.removeItem('cc_editor_session_started');

        // テーマとカラーをリセット
        document.body.classList.remove('theme-dark', 'theme-sepia', 'theme-blue', 'theme-green');
        document.documentElement.style.setProperty('--active-tab-bg', '#fff59d');

        // ヘッダーカラーをリセット
        const headerVars = ['--pane-input-head', '--pane-preview-head', '--pane-memo-head', '--pane-outline-head', '--pane-structure-head', '--pane-search-head'];
        headerVars.forEach(v => {
            document.documentElement.style.removeProperty(v);
            try { localStorage.removeItem('cc_' + v.replace('--', '')); } catch(e){}
        });

        // 背景色をリセット
        const bgVars = ['--pane-input-bg', '--pane-preview-bg', '--pane-memo-bg', '--pane-outline-bg', '--pane-structure-bg', '--pane-search-bg'];
        bgVars.forEach(v => {
            document.documentElement.style.removeProperty(v);
            try { localStorage.removeItem('cc_' + v.replace('--', '')); } catch(e){}
        });

        // レイアウトをリセット
        layoutAxis = 'row';
        layoutReversed = false;
        applyLayoutState();
        saveLayoutSettings();
        applyAllSettings();

        resetPaneWidths();
        resetPaneHeights();
        setPaneSplitEqual();
        renderInputTabs();
        renderPreviewTabs();
        renderBookmarks();
        renderMemoTabs();
        updateInputStats();
        updateMemoCharCount();
        updatePreview();
        saveTabsToStorage();
        saveMemoTabs();
        saveWritingTime();
        if (typeof resetSearchPanel === 'function') resetSearchPanel();
        const searchInput = document.getElementById('search-input');
        const replaceInput = document.getElementById('replace-input');
        if (searchInput) searchInput.value = '';
        if (replaceInput) replaceInput.value = '';
        if (typeof closeSearchPanel === 'function') closeSearchPanel();
        if (typeof closeStructurePanel === 'function') closeStructurePanel(true);
        if (typeof window.initStructureFromReset === 'function') window.initStructureFromReset();
        if (typeof closeCharacterPanel === 'function') closeCharacterPanel(true);
        if (typeof window.initCharacterFromReset === 'function') window.initCharacterFromReset();
        if (typeof closeWorldPanel === 'function') closeWorldPanel(true);
        if (typeof window.initWorldFromReset === 'function') window.initWorldFromReset();
        applyDefaultStartupLayoutAfterReset();
        requestAnimationFrame(() => {
            if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
            if (typeof updateDockSplitState === 'function') updateDockSplitState();
            if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
            if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
        });
    }

    const AUTOSAVE_KEY = 'cc_editor_autosave';
    let autosaveTimerId = null;
    function persistLocalState() { saveTabsToStorage(); saveSettingsToStorage(); }
    function showAutoSaveToast() {
        const toast = document.getElementById('autosave-toast');
        if (!toast) return;
        toast.classList.add('show');
        clearTimeout(showAutoSaveToast._timer);
        showAutoSaveToast._timer = setTimeout(() => toast.classList.remove('show'), 1500);
    }
    function closeAutoSaveError() {
        const overlay = document.getElementById('autosave-error');
        if (overlay) overlay.classList.remove('show');
    }
    function showAutoSaveError() {
        const overlay = document.getElementById('autosave-error');
        if (overlay) overlay.classList.add('show');
    }
    function setAutoSaveEnabled(enabled) {
        settingsCache.autosaveEnabled = enabled;
        const checkbox = document.getElementById('st-autosave-enabled');
        if (checkbox) checkbox.checked = enabled;
        // Update save button icon based on autosave state
        const saveBtn = document.querySelector('.btn-save');
        if (saveBtn) {
            saveBtn.innerHTML = enabled ? '🔄 保存' : '💾 保存';
            saveBtn.title = enabled ? '自動保存オン' : '保存';
        }
        startAutoSaveTimer();
    }
    function buildHtmlExport(scope) {
        const v = document.getElementById('st-pv-v').checked;
        const fk = document.getElementById('st-pv-font').value;
        const fs = document.getElementById('st-pv-size').value;
        const lh = document.getElementById('st-pv-line').value;
        let htmlContent = '';
        if (scope === 'all') {
            const currentTab = inputTabs.find(t => t.id === activeTabId);
            if (currentTab) currentTab.content = inputArea.value;
            inputTabs.forEach((tab, idx) => {
                if (idx > 0) htmlContent += '<div style="page-break-before: always; margin-top: 40px;"></div>';
                htmlContent += `<h2 style="font-size: 1.5em; margin-bottom: 1em;">${escapeHtml(tab.name)}</h2>`;
                htmlContent += renderTextToHTML(tab.content);
            });
        } else {
            updatePreview();
            htmlContent = previewContent.innerHTML;
        }
        return `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><title>${escapeHtml(getNovelBaseName())}</title><link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho&family=Noto+Sans+JP&display=swap" rel="stylesheet"><style>body{margin:40px;background:#fdfcf0;font-family:${fontMap[fk]};font-size:${fs}px;line-height:${lh};${v?'writing-mode:vertical-rl;min-height:100vh;':''}}ruby{ruby-align:space-between;}rt{font-size:0.5em;color:#555;}.bouten-ruby rt{font-size:0.8em;font-weight:bold;}.underline-text{text-decoration:underline;text-decoration-color:#dc2626;}.highlight-text{background:linear-gradient(transparent 60%,#fef08a 60%);}</style></head><body>${htmlContent}
<script>
/* --- CC Hotfix v18: unify ribbon/panel toggle behavior + consistent default widths --- */
(function(){
  const PANEL_META = [
    { key:'structure', panelId:'structure-panel', checkboxId:'check-structure-dock', dockFn:'toggleStructureDock' },
    { key:'world', panelId:'world-panel', checkboxId:'check-world-dock', dockFn:'toggleWorldDock' },
    { key:'character', panelId:'character-panel', checkboxId:'check-character-dock', dockFn:'toggleCharacterDock' },
    { key:'memo', panelId:'memo-panel', checkboxId:'check-memo-dock', dockFn:'toggleMemoDock' },
    { key:'outline', panelId:'outline-panel', checkboxId:'check-outline-dock', dockFn:'toggleOutlineDock' },
    { key:'search', panelId:'search-panel', checkboxId:'check-search-dock', dockFn:'toggleSearchDock' },
  ];

  function getMeta(key){ return PANEL_META.find(p=>p.key===key); }
  function getEl(id){ return document.getElementById(id); }

  function anyFloatingOpen(){
    return PANEL_META.some(p=>{
      const panel = getEl(p.panelId);
      const cb = getEl(p.checkboxId);
      return panel && cb && panel.classList.contains('open') && !cb.checked;
    });
  }

  function collapseFloating(){
    if (typeof window.__ccCollapseFloatingPanels === 'function') {
      window.__ccCollapseFloatingPanels();
      return;
    }
    PANEL_META.forEach(p=>{
      const panel = getEl(p.panelId);
      const cb = getEl(p.checkboxId);
      if (panel && cb && panel.classList.contains('open') && !cb.checked) {
        panel.classList.remove('open');
        panel.style.zIndex = '';
      }
    });
  }

  function finalizeUi(){
    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
    try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}
  }

  function bringFront(panel, isDocked){
    try{
      if (typeof window.bringPanelToFront === 'function') window.bringPanelToFront(panel, !!isDocked);
    }catch(e){}
  }

  function requestDock(key, cb, panel){
    // Use maxPinnedPanels gate if available
    const before = !!cb.checked;
    if (typeof window.__ccRequestDockWithLimit === 'function') {
      window.__ccRequestDockWithLimit(key);
      // Request may complete after user interaction; re-sync soon.
      setTimeout(()=>{
        if (!!cb.checked && !before) {
          // Dock succeeded: close floating panels and keep this one open/front.
          collapseFloating();
          panel.classList.add('open');
          bringFront(panel, true);
        }
        finalizeUi();
      }, 0);
      return;
    }
    // Fallback: direct dock
    cb.checked = true;
    const meta = getMeta(key);
    if (meta && typeof window[meta.dockFn] === 'function') window[meta.dockFn]();
    panel.classList.add('open');
    collapseFloating();
    bringFront(panel, true);
    finalizeUi();
  }

  function undockAndClose(key, cb, panel){
    cb.checked = false;
    const meta = getMeta(key);
    if (meta && typeof window[meta.dockFn] === 'function') window[meta.dockFn]();
    panel.classList.remove('open');
    panel.style.zIndex = '';
    finalizeUi();
  }

  function toggleUnified(key){
    const meta = getMeta(key);
    if (!meta) return;
    const panel = getEl(meta.panelId);
    const cb = getEl(meta.checkboxId);
    if (!panel || !cb) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = !!cb.checked;

    if (!isOpen) {
      // open (keep current dock state)
      panel.classList.add('open');
      bringFront(panel, isDocked);
      finalizeUi();
      return;
    }

    if (isDocked) {
      // Docked ribbon click:
      // - If any floating panels exist, just collapse them (keep dock).
      // - Else, toggle off dock and close (so ribbon can "解除" the panel).
      if (anyFloatingOpen()) {
        collapseFloating();
        panel.classList.add('open');
        bringFront(panel, true);
        finalizeUi();
        return;
      }
      // No floating -> allow close/undock via ribbon
      undockAndClose(key, cb, panel);
      return;
    }

    // Floating & open
    const isFront = (typeof window.__ccIsPanelFront === 'function') ? window.__ccIsPanelFront(meta.panelId) : true;
    if (!isFront) {
      bringFront(panel, false);
      finalizeUi();
      return;
    }
    // Front-floating -> request dock
    requestDock(key, cb, panel);
  }

  // Override toggle functions to unify behavior (last definition wins)
  window.toggleStructurePanel = function(){ toggleUnified('structure'); };
  window.toggleWorldPanel = function(){ toggleUnified('world'); };
  window.toggleCharacterPanel = function(){ toggleUnified('character'); };
  window.toggleMemoPanel = function(){ toggleUnified('memo'); };
  window.toggleOutlinePanel = function(){ toggleUnified('outline'); };
  window.toggleSearchPanel = function(){ toggleUnified('search'); };

  // Also, if ribbon uses these names:
  window.toggleStructure = window.toggleStructurePanel;
  window.toggleWorld = window.toggleWorldPanel;
  window.toggleCharacter = window.toggleCharacterPanel;
  window.toggleMemo = window.toggleMemoPanel;
  window.toggleOutline = window.toggleOutlinePanel;
  window.toggleSearch = window.toggleSearchPanel;

  // Ensure buttons reflect current state after load
  const refresh = ()=>{ try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){} };
  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', refresh);
  else refresh();
})();
${'</scr'+'ipt>'}

</body></html>`;
    }
    function getAutoSavePayload() {
        if (!autoSaveTarget.handle || !autoSaveTarget.type) return null;
        const scope = autoSaveTarget.scope || 'current';
        if (autoSaveTarget.type === 'html') {
            return { blob: new Blob([buildHtmlExport(scope)], { type: 'text/html' }) };
        }
        return { blob: new Blob([scope === 'all' ? getAllTabsContent() : getCurrentTabContent()], { type: 'text/plain' }) };
    }
    async function autoSave() {
        if (!settingsCache.autosaveEnabled) return;
        persistLocalState();
        if (!autoSaveTarget.handle) {
            showAutoSaveError();
            setAutoSaveEnabled(false);
            return;
        }
        const payload = getAutoSavePayload();
        if (!payload) return;
        const handled = await saveWithHandle(autoSaveTarget.handle, payload.blob);
        if (handled) {
            showAutoSaveToast();
            return;
        }
        showAutoSaveError();
        setAutoSaveEnabled(false);
    }
    function startAutoSaveTimer() {
        if (autosaveTimerId) clearInterval(autosaveTimerId);
        if (!settingsCache.autosaveEnabled) return;
        const seconds = settingsCache.autosaveInterval || 60;
        autosaveTimerId = setInterval(autoSave, seconds * 1000);
    }
    function loadAutoSave() {
        // Try to load tabs first (new format)
        if (loadTabsFromStorage()) {
            renderInputTabs();
            return;
        }
        // Fallback: try old single-content format
        const s = localStorage.getItem(AUTOSAVE_KEY);
        if (s && s.length > 0 && s !== defaultText) {
            if (confirm('前回の自動保存データがあります。復元しますか？')) {
                inputTabs[0].content = s;
                inputArea.value = s;
            } else {
                inputArea.value = defaultText;
                inputTabs[0].content = defaultText;
            }
        } else {
            inputArea.value = defaultText;
            inputTabs[0].content = defaultText;
        }
        renderInputTabs();
    }
    startAutoSaveTimer();
    window.addEventListener('beforeunload', e => { persistLocalState(); saveWritingTime(); e.preventDefault(); e.returnValue = ''; });

    function undoInput() { inputArea.focus(); document.execCommand('undo'); }
    function redoInput() { inputArea.focus(); document.execCommand('redo'); }
    function getGoalColorClass(p) { if (p >= 100) return 'goal-100'; if (p >= 75) return 'goal-75-99'; if (p >= 50) return 'goal-50-74'; if (p >= 25) return 'goal-25-49'; return 'goal-0-24'; }

    // Celebration Functions
    function launchFireworks() {
        const overlay = document.getElementById('celebration-overlay');
        const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#1dd1a1'];
        const fireworkCount = 8;
        for (let f = 0; f < fireworkCount; f++) {
            setTimeout(() => {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight * 0.6 + window.innerHeight * 0.1;
                const color = colors[Math.floor(Math.random() * colors.length)];
                // Trail
                const trail = document.createElement('div');
                trail.className = 'firework-trail';
                trail.style.left = x + 'px';
                trail.style.bottom = '0';
                trail.style.background = color;
                trail.style.setProperty('--rise', `-${window.innerHeight - y}px`);
                overlay.appendChild(trail);
                setTimeout(() => trail.remove(), 800);
                // Burst
                setTimeout(() => {
                    const particleCount = 20;
                    for (let i = 0; i < particleCount; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'firework';
                        particle.style.left = x + 'px';
                        particle.style.top = y + 'px';
                        particle.style.background = color;
                        const angle = (i / particleCount) * Math.PI * 2;
                        const distance = 80 + Math.random() * 60;
                        const tx = Math.cos(angle) * distance;
                        const ty = Math.sin(angle) * distance;
                        particle.style.setProperty('--tx', tx + 'px');
                        particle.style.setProperty('--ty', ty + 'px');
                        overlay.appendChild(particle);
                        setTimeout(() => particle.remove(), 1500);
                    }
                }, 600);
            }, f * 200);
        }
    }

    function showCelebration(type) {
        if (!settingsCache.celebrateGoal) return;
        const msgEl = document.getElementById('celebration-message');
        const textEl = document.getElementById('celebration-text');
        const subEl = document.getElementById('celebration-sub');
        if (type === 'today') {
            textEl.textContent = 'やったね！今日の目標達成！';
            subEl.textContent = '今日も素晴らしい執筆でした！';
        } else if (type === 'total') {
            textEl.textContent = '🎊 おめでとう！全体目標達成！ 🎊';
            subEl.textContent = '大きな節目を達成しました！';
        }
        launchFireworks();
        msgEl.classList.add('show');
        setTimeout(() => msgEl.classList.remove('show'), 4000);
    }

    function checkGoalAchievement(todayWritten, todayGoal, totalWritten, totalGoal) {
        if (todayGoal > 0 && todayWritten >= todayGoal && !goalAchieved.today) {
            goalAchieved.today = true;
            setTimeout(() => showCelebration('today'), 300);
        }
        if (totalGoal > 0 && totalWritten >= totalGoal && !goalAchieved.total) {
            goalAchieved.total = true;
            setTimeout(() => showCelebration('total'), goalAchieved.today ? 4500 : 300);
        }
    }

    // Debounced preview update for performance
    function debouncedPreviewUpdate() {
        if (previewUpdateTimeout) clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(() => updatePreview(), 300);
    }

    function updateInputStats() {
        const t = inputArea.value, tl = t.replace(/[\n\r]/g, '').length, nl = t.replace(/[\n\s　]/g, '').length, ll = t.split('\n').length;
        charCountEl.innerText = `全体: ${tl}`; inputNetCountEl.innerText = `実質: ${nl}`; lineCountEl.innerText = `${ll} 行`;
        const g = settingsCache.goalChars;
        if (g > 0) { const p = Math.round((nl / g) * 100); inputGoalEl.innerText = `目標: ${nl}/${g} (${p}%)`; inputGoalEl.className = 'goal-display ' + getGoalColorClass(p); } else { inputGoalEl.innerText = ''; }
        const tg = settingsCache.todayGoal;
        let tw = 0;
        if (tg > 0) { tw = Math.max(0, nl - todayStartChars); const tp = Math.round((tw / tg) * 100); inputTodayGoalEl.innerText = `今日: ${tw}/${tg} (${tp}%)`; inputTodayGoalEl.className = tw >= tg ? 'today-goal achieved' : 'today-goal'; } else { inputTodayGoalEl.innerText = ''; }
        inputReadingEl.innerText = settingsCache.showReadingTime ? `約${Math.ceil(nl / 400)}分` : '';
        if (settingsCache.showManuscript) { const cpp = settingsCache.manuscriptRows * settingsCache.manuscriptCols; inputManuscriptEl.innerText = `原稿用紙: ${(nl / cpp).toFixed(1)}枚`; } else { inputManuscriptEl.innerText = ''; }
        updateCursorLineDisplay();
        // Check goal achievement
        checkGoalAchievement(tw, tg, nl, g);
        updateAllTabsStats();
    }
    function updateCursorLineDisplay() { const p = inputArea.selectionStart, c = (inputArea.value.substring(0, p).match(/\n/g) || []).length + 1; inputPosBar.innerText = `現在: ${c} 行目`; }

    function updateAllTabsStats() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;
        const allText = inputTabs.map(t => t.content || '').join('\n');
        const totalChars = allText.replace(/[\n\r]/g, '').length;
        const totalNet = allText.replace(/[\n\s　]/g, '').length;
        const totalLines = allText.split('\n').length;
        const display = `全タブ: ${totalChars}字 / ${totalLines}行`;
        const title = `全タブ: ${totalChars}字 / 実質 ${totalNet}字 / ${totalLines}行`;
        const inputTotal = document.getElementById('input-total-stats');
        const previewTotal = document.getElementById('preview-total-stats');
        if (inputTotal) {
            inputTotal.innerText = display;
            inputTotal.title = title;
        }
        if (previewTotal) {
            previewTotal.innerText = display;
            previewTotal.title = title;
        }
    }

    const quickInsertPopup = document.getElementById('quick-insert-popup');
    let lastSelectionRange = { start: 0, end: 0 };

    function showQuickInsertPopup() {
        const s = inputArea.selectionStart, e = inputArea.selectionEnd;
        if (s === e) { quickInsertPopup.classList.remove('show'); return; }
        lastSelectionRange = { start: s, end: e };
        const overlayRect = inputSelOverlay.getBoundingClientRect();
        const inputRect = inputArea.getBoundingClientRect();
const isVertical = inputArea.parentElement.classList.contains('vertical-mode');
const margin = 8;
const footerRect = document.querySelector('#pane-input .pane-footer')?.getBoundingClientRect();

        quickInsertPopup.classList.add('show');
        quickInsertPopup.style.visibility = 'hidden';
        const popupRect = quickInsertPopup.getBoundingClientRect();

let popupLeft;
let popupTop;

if (isVertical) {
    // 縦書き：選択範囲の左に出したいので、overlayRect.left を基準に左側へ
    popupLeft = overlayRect.left - popupRect.width - 12;
    // 位置は選択範囲の上端あたりに合わせる
    popupTop = overlayRect.top;
} else {
    // 横書き：選択範囲の上に中央寄せ（元のPR挙動）
    popupLeft = overlayRect.left + (overlayRect.width / 2) - (popupRect.width / 2);
    popupTop = overlayRect.top - popupRect.height - 8;
}

popupLeft = Math.min(Math.max(popupLeft, margin), window.innerWidth - popupRect.width - margin);
let maxTop = window.innerHeight - popupRect.height - margin;
if (footerRect) {
    maxTop = Math.min(maxTop, footerRect.top - popupRect.height - margin);
}
const minTop = inputRect.top + margin;
if (maxTop < minTop) maxTop = minTop;
popupTop = Math.min(Math.max(popupTop, minTop), maxTop);


        quickInsertPopup.style.top = `${popupTop}px`;
        quickInsertPopup.style.left = `${popupLeft}px`;
        quickInsertPopup.style.visibility = '';
    }

    function hideQuickInsertPopup() { quickInsertPopup.classList.remove('show'); }

    function quickInsertRuby() {
        const s = lastSelectionRange.start, e = lastSelectionRange.end;
        if (s === e) return;
        const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e);
        const rt = `｜${st}《》`;
        inputArea.value = b + rt + a;
        inputArea.setSelectionRange(s + st.length + 2, s + st.length + 2);
        inputArea.focus();
        updateInputStats();
        hideQuickInsertPopup();
    }

    function quickInsertBouten() {
        const s = lastSelectionRange.start, e = lastSelectionRange.end;
        if (s === e) return;
        const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e);
        const bt = `《《${st}》》`;
        inputArea.value = b + bt + a;
        inputArea.setSelectionRange(s + bt.length, s + bt.length);
        inputArea.focus();
        updateInputStats();
        hideQuickInsertPopup();
    }

    function quickAddBookmark() {
        const s = lastSelectionRange.start, e = lastSelectionRange.end;
        const pos = s;
        const text = inputArea.value;
        const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
        const lineEnd = text.indexOf('\n', pos);
        const lineText = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd).trim();
        const preview = lineText.substring(0, 30) + (lineText.length > 30 ? '...' : '');
        const lineNum = (text.substring(0, pos).match(/\n/g) || []).length + 1;
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        bookmarks.push({ pos, lineNum, preview, created: Date.now(), tabId: activeTabId, tabName: currentTab?.name || '' });
        saveBookmarks();
        renderBookmarks();
        hideQuickInsertPopup();
    }

    document.addEventListener('selectionchange', () => {
        const a = document.activeElement;
        if (a === inputArea) {
            const s = inputArea.selectionStart, e = inputArea.selectionEnd;
            if (s !== e) {
                const t = inputArea.value.substring(s, e), c = t.replace(/[\n\r]/g, '').length, l = (t.match(/\n/g) || []).length + 1;
                inputSelOverlay.textContent = `選択: ${c}字 / ${l}行`;
                inputSelOverlay.classList.add('show');
                showQuickInsertPopup();
            } else {
                inputSelOverlay.classList.remove('show');
                hideQuickInsertPopup();
            }
            previewSelOverlay.classList.remove('show');
        }
        else if (previewScroll.contains(window.getSelection()?.anchorNode)) {
            const t = window.getSelection().toString();
            if (t.length > 0) {
                const c = t.replace(/[\n\r]/g, '').length, l = (t.match(/\n/g) || []).length + 1;
                previewSelOverlay.textContent = `選択: ${c}字 / ${l}行`;
                previewSelOverlay.classList.add('show');
            } else {
                previewSelOverlay.classList.remove('show');
            }
            inputSelOverlay.classList.remove('show');
            hideQuickInsertPopup();
        }
        else {
            inputSelOverlay.classList.remove('show');
            previewSelOverlay.classList.remove('show');
            hideQuickInsertPopup();
        }
    });

    previewScroll.addEventListener('scroll', () => {
        const v = document.getElementById('st-pv-v').checked; let p;
        if (v) {
            const sl = previewScroll.scrollLeft;
            const sw = previewScroll.scrollWidth - previewScroll.clientWidth;
            p = sw > 0 ? Math.round(Math.abs(sl) / sw * 100) : 0;
            // 縦書きは「上（先頭）=100%」になっていたので、表示だけ逆算する：先頭=0% / 末尾=100%
            p = 100 - p;
        } else {
            const st = previewScroll.scrollTop;
            const sh = previewScroll.scrollHeight - previewScroll.clientHeight;
            p = sh > 0 ? Math.round((st / sh) * 100) : 0;
        }
        p = Math.max(0, Math.min(100, p));
        previewPosBar.innerText = `位置: ${p}%`;
    });

    let previewTabId = null; // null = follow input, or specific tab id
    let previewShowAll = false;

    function renderPreviewTabs() {
        const container = document.getElementById('preview-tabs-container');
        if (!container) return;
        container.innerHTML = '';

        // Individual tabs only (removed "全タブ")
        inputTabs.forEach(tab => {
            const tabEl = document.createElement('div');
            const isActive = previewTabId === tab.id || (previewTabId === null && tab.id === activeTabId);
            tabEl.className = 'preview-tab' + (isActive ? ' active' : '');
            tabEl.textContent = tab.name;
            tabEl.onclick = () => { previewTabId = tab.id; renderPreviewTabs(); updatePreview(); };
            container.appendChild(tabEl);
        });
        updateTabScrollButtonsFor('preview-tabs-container');
    }

    function getPreviewContent() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;

        const targetId = previewTabId !== null ? previewTabId : activeTabId;
        const tab = inputTabs.find(t => t.id === targetId);
        return tab ? tab.content : inputArea.value;
    }

    function updatePreviewTabOptions() {
        renderPreviewTabs();
    }

    function updatePreview() {
        renderPreviewTabs();
        const t = getPreviewContent(), ss = settingsCache.showSpace, sh = settingsCache.showHighlight;
        let s = escapeHtml(t); if (sh) previewContent.classList.add('highlight-active'); else previewContent.classList.remove('highlight-active');
        const MZ = '\uE001', MH = '\uE002'; if (ss) { s = s.replace(/　/g, MZ).replace(/ /g, MH); }
        if (sh) { s = s.replace(/「(.*?)」/g, '<span class="bracket-blue">「$1」</span>').replace(/『(.*?)』/g, '<span class="bracket-green">『$1』</span>'); }
        s = s.replace(/｜([^《]+?)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>').replace(/([一-龠々〆ヵヶ]+)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>');
        s = s.replace(/《《(.+?)》》/g, (m, p) => { let r = ''; for (let c of p) r += `<ruby class="bouten-ruby">${c}<rt>・</rt></ruby>`; return r; });
        s = s.replace(/__(.+?)__/g, '<span class="underline-text">$1</span>').replace(/==(.+?)==/g, '<span class="highlight-text">$1</span>');
        if (sh) s = s.replace(/([―─]{2,}|…{2,})/g, '<span class="symbol-hl">$1</span>');
        if (ss) { s = s.split(MZ).join('<span class="space-zen">□</span>').split(MH).join('<span class="space-han">･</span>'); }
        s = s.replace(/\n/g, '<br>'); previewContent.innerHTML = s;
        const tl = t.replace(/[\n\r]/g, '').length, nl = t.replace(/[\n\s　｜《》]/g, '').length, ll = t.split('\n').length;
        pvTotalCountEl.innerText = `全体: ${tl}`; pvNetCountEl.innerText = `実質: ${nl}`; pvLineCountEl.innerText = `${ll} 行`;
        const g = settingsCache.goalChars; if (g > 0) { const p = Math.round((nl / g) * 100); pvGoalEl.innerText = `目標: ${nl}/${g} (${p}%)`; pvGoalEl.className = 'goal-display ' + getGoalColorClass(p); } else { pvGoalEl.innerText = ''; }
        const tg = settingsCache.todayGoal; if (tg > 0) { const tw = Math.max(0, nl - todayStartChars), tp = Math.round((tw / tg) * 100); pvTodayGoalEl.innerText = `今日: ${tw}/${tg} (${tp}%)`; pvTodayGoalEl.className = tw >= tg ? 'today-goal achieved' : 'today-goal'; } else { pvTodayGoalEl.innerText = ''; }
        pvReadingEl.innerText = settingsCache.showReadingTime ? `約${Math.ceil(nl / 400)}分` : '';
        if (settingsCache.showManuscript) { const cpp = settingsCache.manuscriptRows * settingsCache.manuscriptCols; pvManuscriptEl.innerText = `原稿用紙: ${(nl / cpp).toFixed(1)}枚`; } else { pvManuscriptEl.innerText = ''; }
        pvTimeEl.innerText = `更新: ${new Date().toLocaleTimeString('ja-JP', { hour12: false })}`;
    }

function syncPreviewPosition() {
  const previewPane = document.getElementById('pane-preview');

  // プレビューが閉じている時は、開いてから同期する
  if (previewPane && previewPane.classList.contains('hidden')) {
    // これが updatePreview() も呼ぶ
    if (typeof updatePreviewAndShow === 'function') updatePreviewAndShow();
    // DOM反映後に位置合わせ（2フレーム待つと安定します）
    requestAnimationFrame(() => requestAnimationFrame(() => syncPreviewPositionCore()));
    return;
  }
  syncPreviewPositionCore();
}

function syncPreviewPositionCore() {
  // ★同期ボタンを押した時だけ「内容」を同期する
  // （入力タブ → プレビュータブを合わせる）
  if (typeof previewTabId !== 'undefined') previewTabId = activeTabId;
  if (typeof renderPreviewTabs === 'function') renderPreviewTabs();
  if (typeof updatePreview === 'function') updatePreview();

  // ★ここから下は「位置（スクロール）同期」
  const start = inputArea.selectionStart;
  const end = inputArea.selectionEnd;
  const targetPos = start === end ? start : Math.floor((start + end) / 2);
  const lineNum = (inputArea.value.substring(0, targetPos).match(/\n/g) || []).length;

  const brs = previewContent.querySelectorAll('br');
  if (brs.length > 0) {
    const targetBr = brs[Math.min(lineNum, brs.length - 1)];
    if (targetBr) {
      targetBr.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      setTimeout(() => showPreviewSyncIndicator(targetBr), 60);
    }
  } else {
    previewScroll.scrollTop = 0;
    previewScroll.scrollLeft = 0;
    const indicator = document.getElementById('preview-sync-indicator');
    if (indicator) indicator.style.display = 'none';
  }

  const indicatorRect = getPreviewLineStartRect(lineNum);
  if (indicatorRect) {
    setTimeout(() => showPreviewSyncIndicator(indicatorRect), 60);
  } else {
    const indicator = document.getElementById('preview-sync-indicator');
    if (indicator) indicator.style.display = 'none';
  }
}



    function updatePreviewAndShow() {
        updatePreview();
        renderPreviewTabs();
        const previewPane = document.getElementById('pane-preview');
        if (previewPane.classList.contains('hidden')) {
            previewPane.classList.remove('hidden');
            document.getElementById('check-show-preview').checked = true;
            setPaneSplitEqual();
        }
    }

    function toggleInputWritingMode() {
        const inputToggle = document.getElementById('st-in-v');
        inputToggle.checked = !inputToggle.checked;
        applyInputSettings();
        saveSettingsToStorage();
    }

    function togglePreviewWritingMode() {
        const previewToggle = document.getElementById('st-pv-v');
        previewToggle.checked = !previewToggle.checked;
        applyPreviewSettings();
        saveSettingsToStorage();
    }

    // 縦横ボタンの表記を『次に切り替わる方向』で表示
    function updateWritingModeButtonLabels() {
        const inBtn = document.getElementById('btn-input-writing-mode');
        const pvBtn = document.getElementById('btn-preview-writing-mode');
        const inV = document.getElementById('st-in-v')?.checked;
        const pvV = document.getElementById('st-pv-v')?.checked;

        if (inBtn) inBtn.textContent = inV ? '横書きへ' : '縦書きへ';
        if (pvBtn) pvBtn.textContent = pvV ? '横書きへ' : '縦書きへ';
    }

    // ===== 閲覧（全タブをまとめて全画面表示） =====
    let readerVertical = true;

    function updateReaderWritingModeButtonLabel() {
        const btn = document.getElementById('btn-reader-writing-mode');
        if (!btn) return;
        btn.textContent = readerVertical ? '横書きへ' : '縦書きへ';
    }

    function applyReaderWritingModeClass() {
        const scroll = document.getElementById('reader-scroll');
        if (!scroll) return;
        if (readerVertical) scroll.classList.add('vertical-mode');
        else scroll.classList.remove('vertical-mode');
    }

    function renderReaderContent() {
        const contentEl = document.getElementById('reader-content');
        const scroll = document.getElementById('reader-scroll');
        if (!contentEl || !scroll) return;

        // 現在タブの内容を退避
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;

        // ハイライト設定
        if (settingsCache.showHighlight) contentEl.classList.add('highlight-active');
        else contentEl.classList.remove('highlight-active');

        let html = '';
        inputTabs.forEach((tab, idx) => {
            const name = tab.name || `タブ${idx+1}`;
            const marker = `◆ ${name}`;
            const body = renderTextToHTML(tab.content || '');
            html += `<div class="reader-section">` +
                    `<div class="reader-marker">${escapeHtml(marker)}</div>` +
                    `<div class="reader-text">${body}</div>` +
                    `</div>`;
        });

        contentEl.innerHTML = html;
        applyReaderWritingModeClass();

        // 先頭へ
        scroll.scrollTop = 0;
        scroll.scrollLeft = 0;
    }

    function openReaderView() {
        const overlay = document.getElementById('reader-overlay');
        if (!overlay) return;

        // 既定はプレビューの縦横設定に合わせる（閲覧だけで独立切替可能）
        const pvV = document.getElementById('st-pv-v');
        readerVertical = pvV ? !!pvV.checked : true;

        renderReaderContent();
        updateReaderWritingModeButtonLabel();

        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
    }

    function closeReaderView() {
        const overlay = document.getElementById('reader-overlay');
        if (!overlay) return;
        overlay.classList.remove('show');
        overlay.setAttribute('aria-hidden', 'true');
    }

    function toggleReaderWritingMode() {
        readerVertical = !readerVertical;
        applyReaderWritingModeClass();
        updateReaderWritingModeButtonLabel();
    }

const fontMap = { 'font-gothic': '"Noto Sans JP", sans-serif', 'font-mincho': '"Shippori Mincho", serif', 'font-old': '"Zen Old Mincho", serif', 'font-round': '"M PLUS Rounded 1c", sans-serif', 'font-brush': '"Yuji Syuku", serif' };
    function applyInputSettings() {
    const s = document.getElementById('st-in-size').value + 'px';
    const l = document.getElementById('st-in-line').value;
    const f = fontMap[document.getElementById('st-in-font').value];
    const v = document.getElementById('st-in-v').checked;

    inputArea.style.fontSize = s;
    inputArea.style.lineHeight = l;
    inputArea.style.fontFamily = f;
    inputMirror.style.fontSize = s;
    inputMirror.style.lineHeight = l;
    inputMirror.style.fontFamily = f;

    if (v) inputArea.parentElement.classList.add('vertical-mode');
    else inputArea.parentElement.classList.remove('vertical-mode');

    updateWritingModeButtonLabels();
}

function applyPreviewSettings() {
    const s = document.getElementById('st-pv-size').value + 'px';
    const l = document.getElementById('st-pv-line').value;
    const f = fontMap[document.getElementById('st-pv-font').value];
    const v = document.getElementById('st-pv-v').checked;

    previewContent.style.fontSize = s;
    previewContent.style.lineHeight = l;
    previewContent.style.fontFamily = f;

    if (v) previewScroll.classList.add('vertical-mode');
    else previewScroll.classList.remove('vertical-mode');

    updateWritingModeButtonLabels();
    updatePreview();
}

function applyDisplaySettings() {
        settingsCache.showSpace = document.getElementById('st-show-space').checked;
        settingsCache.showHighlight = document.getElementById('st-show-highlight').checked;
        settingsCache.defaultPreviewHidden = document.getElementById('st-default-preview-hidden').checked;
        const si = document.getElementById('check-show-input').checked, sp = document.getElementById('check-show-preview').checked;
        if (si) document.getElementById('pane-input').classList.remove('hidden'); else document.getElementById('pane-input').classList.add('hidden');
        if (sp) document.getElementById('pane-preview').classList.remove('hidden'); else document.getElementById('pane-preview').classList.add('hidden');
        adjustPaneWidthsOnVisibility();
        updatePreview();
    }
    function applyWritingSettings() { settingsCache.typewriterMode = document.getElementById('st-typewriter-mode').checked; settingsCache.writingTracker = document.getElementById('st-writing-tracker').checked; updateWritingTimeDisplay(); }
    function applyGoalSettings() { settingsCache.goalChars = parseInt(document.getElementById('st-goal-chars').value) || 0; settingsCache.todayGoal = parseInt(document.getElementById('st-today-goal').value) || 0; settingsCache.showReadingTime = document.getElementById('st-show-reading-time').checked; settingsCache.celebrateGoal = document.getElementById('st-celebrate-goal').checked; goalAchieved = { today: false, total: false }; updateInputStats(); updatePreview(); }
    function applyManuscriptSettings() {
        settingsCache.manuscriptRows = parseInt(document.getElementById('st-manuscript-rows').value) || 34;
        settingsCache.manuscriptCols = parseInt(document.getElementById('st-manuscript-cols').value) || 42;
        settingsCache.showManuscript = document.getElementById('st-show-manuscript').checked;
        updateInputStats();
        updatePreview();
    }
    const TEXT_COLOR_KEY = 'cc_text_color_v1';

    function getDefaultTextColor() {
        return getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim() || '#1f2937';
    }

    function normalizeHexColor(v) {
        if (!v) return null;
        const trimmed = v.trim();
        if (!/^#?[0-9a-fA-F]{6}$/.test(trimmed)) return null;
        return trimmed.startsWith('#') ? trimmed : `#${trimmed}`;
    }

    function syncTextColorInputs(color) {
        const colorEl = document.getElementById('st-text-color');
        const textEl = document.getElementById('st-text-color-text');
        if (!colorEl || !textEl) return;
        const value = color || getDefaultTextColor();
        colorEl.value = value;
        textEl.value = value;
    }

    function applyTextColorSettings() {
        const colorEl = document.getElementById('st-text-color');
        const textEl = document.getElementById('st-text-color-text');
        if (!colorEl || !textEl) return;
        const chosen = normalizeHexColor(textEl.value || colorEl.value);
        document.documentElement.style.removeProperty('--text-color');
        const defaultColor = getDefaultTextColor();
        if (chosen && chosen !== defaultColor) {
            document.documentElement.style.setProperty('--text-color', chosen);
            localStorage.setItem(TEXT_COLOR_KEY, chosen);
            syncTextColorInputs(chosen);
            return;
        }
        localStorage.removeItem(TEXT_COLOR_KEY);
        syncTextColorInputs(defaultColor);
    }

    function initTextColorSettings() {
        const colorEl = document.getElementById('st-text-color');
        const textEl = document.getElementById('st-text-color-text');
        if (!colorEl || !textEl) return;
        const stored = normalizeHexColor(localStorage.getItem(TEXT_COLOR_KEY));
        syncTextColorInputs(stored);
        colorEl.addEventListener('input', () => { textEl.value = colorEl.value; });
        textEl.addEventListener('change', () => {
            const normalized = normalizeHexColor(textEl.value);
            if (normalized) {
                textEl.value = normalized;
                colorEl.value = normalized;
            }
        });
    }

    function applyThemeSettings() {
        const t = document.getElementById('st-theme-preset').value;
        document.body.className = document.body.className.replace(/theme-\w+/g, '').trim();
        if (t) document.body.classList.add(t);
        applyTextColorSettings();
    }
    function applyOpenSettings() { settingsCache.openMode = document.querySelector('input[name="st-open-mode"]:checked')?.value || 'current'; }
    function applyOpenSettingsAndSave() {
        applyOpenSettings();
        if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();
    }
    function applyDividerSettings() {
        const dividerWidthRaw = parseInt(document.getElementById('st-divider-width').value, 10);
        const dividerWidth = clampValue(dividerWidthRaw || 2, 1, 12);
        document.getElementById('st-divider-width').value = dividerWidth;
        document.documentElement.style.setProperty('--divider-size', `${dividerWidth}px`);
        document.documentElement.style.setProperty('--divider-hit-area', `${Math.max(10, dividerWidth + 8)}px`);
        localStorage.setItem(DIVIDER_WIDTH_KEY, String(dividerWidth));
    }
    function resetDividerWidth() {
        document.getElementById('st-divider-width').value = 2;
        applyDividerSettings();
    }
    function applyAutoSaveSettings(skipConfirm = false) {
        const input = document.getElementById('st-autosave-interval');
        const checkbox = document.getElementById('st-autosave-enabled');
        if (!input || !checkbox) return;
        const secondsRaw = parseInt(input.value, 10);
        const seconds = clampValue(secondsRaw || 60, 5, 600);
        input.value = seconds;
        settingsCache.autosaveInterval = seconds;
        const enableAutoSave = checkbox.checked;
        if (enableAutoSave && !settingsCache.autosaveEnabled && !skipConfirm) {
            const confirmed = confirm('自動保存をオンにすると、指定したフォルダーに保存が続きますがよろしいですか？');
            if (!confirmed) {
                checkbox.checked = false;
                settingsCache.autosaveEnabled = false;
                return;
            }
        }
        setAutoSaveEnabled(enableAutoSave);
    }
    function applyPaperSettings() { applyManuscriptSettings(); applyThemeSettings(); applyPinnedLimitSettings(); }
    // 固定パネル上限（2～7）: 入力/プレビュー + ドック固定パネル（メモ/目次/検索/構成/登場人物/世界観）
    window.__ccPinnableDefs = {
        input:    { key:'input',    label:'入力',    kind:'pane', checkboxId:'check-show-input',  paneId:'pane-input',  nonReplaceable:true },
        preview:  { key:'preview',  label:'プレビュー', kind:'pane', checkboxId:'check-show-preview', paneId:'pane-preview' },
        memo:     { key:'memo',     label:'メモ',    kind:'dock', checkboxId:'check-memo-dock',     panelId:'memo-panel',     dockFn:'toggleMemoDock' },
        outline:  { key:'outline',  label:'目次',    kind:'dock', checkboxId:'check-outline-dock',  panelId:'outline-panel',  dockFn:'toggleOutlineDock' },
        search:   { key:'search',   label:'検索',    kind:'dock', checkboxId:'check-search-dock',   panelId:'search-panel',   dockFn:'toggleSearchDock' },
        structure:{ key:'structure',label:'構成',    kind:'dock', checkboxId:'check-structure-dock',panelId:'structure-panel',dockFn:'toggleStructureDock' },
        character:{ key:'character',label:'登場人物', kind:'dock', checkboxId:'check-character-dock',panelId:'character-panel',dockFn:'toggleCharacterDock' },
        world:    { key:'world',    label:'世界観',  kind:'dock', checkboxId:'check-world-dock',    panelId:'world-panel',    dockFn:'toggleWorldDock' },
        terms:    { key:'terms',   label:'用語',    kind:'dock', checkboxId:'check-terms-dock',   panelId:'terms-panel',   dockFn:'toggleTermsDock' }
    };
    // ---- パネル左右（個別）＋並び順（同サイド内） ----
(function(){
  const PANEL_KEYS = ['memo','outline','world','character','structure','terms','search']; // 入力は対象外
  const DEFAULT_LEFT_ORDER = ['memo','outline','world','character','structure','terms','search'];
  const DEFAULT_RIGHT_ORDER = [];

  function ensureState(){
    if (!window.settingsCache) window.settingsCache = settingsCache;
    settingsCache = window.settingsCache;
    if (!settingsCache.panelSides || typeof settingsCache.panelSides !== 'object') settingsCache.panelSides = {};
    if (!Array.isArray(settingsCache.panelOrderLeft)) settingsCache.panelOrderLeft = DEFAULT_LEFT_ORDER.slice();
    if (!Array.isArray(settingsCache.panelOrderRight)) settingsCache.panelOrderRight = DEFAULT_RIGHT_ORDER.slice();

    // panelSides defaults: left
    PANEL_KEYS.forEach(k => { if (!settingsCache.panelSides[k]) settingsCache.panelSides[k] = 'left'; });

    // normalize order arrays: unique + all keys present in their side array
    const seen = new Set();
    const clean = (arr)=>arr.filter(k=>PANEL_KEYS.includes(k) && !seen.has(k) && (seen.add(k), true));
    const left = clean(settingsCache.panelOrderLeft.slice());
    const right = clean(settingsCache.panelOrderRight.slice());

    // ensure each key appears once in either left or right based on side
    PANEL_KEYS.forEach(k=>{
      const side = settingsCache.panelSides[k] === 'right' ? 'right' : 'left';
      const inLeft = left.includes(k);
      const inRight = right.includes(k);
      if (inLeft || inRight) {
        // if present in wrong side, move
        if (side === 'left' && inRight) { right.splice(right.indexOf(k),1); if(!left.includes(k)) left.push(k); }
        if (side === 'right' && inLeft) { left.splice(left.indexOf(k),1); if(!right.includes(k)) right.push(k); }
      } else {
        (side === 'right' ? right : left).push(k);
      }
    });

    settingsCache.panelOrderLeft = left;
    settingsCache.panelOrderRight = right;
  }

  function saveState(){
    try{ localStorage.setItem('cc_panel_sides', JSON.stringify(settingsCache.panelSides||{})); }catch(e){}
    try{ localStorage.setItem('cc_panel_order_left', JSON.stringify(settingsCache.panelOrderLeft||[])); }catch(e){}
    try{ localStorage.setItem('cc_panel_order_right', JSON.stringify(settingsCache.panelOrderRight||[])); }catch(e){}
  }

  function loadState(){
    try{
      const s = JSON.parse(localStorage.getItem('cc_panel_sides')||'{}');
      if (s && typeof s === 'object') settingsCache.panelSides = Object.assign({}, settingsCache.panelSides||{}, s);
    }catch(e){}
    try{
      const l = JSON.parse(localStorage.getItem('cc_panel_order_left')||'null');
      if (Array.isArray(l)) settingsCache.panelOrderLeft = l;
    }catch(e){}
    try{
      const r = JSON.parse(localStorage.getItem('cc_panel_order_right')||'null');
      if (Array.isArray(r)) settingsCache.panelOrderRight = r;
    }catch(e){}
  }

  function applyOrders(){
    const c = document.getElementById('main-container');
    if (!c) return;
    // pane-stack stays center
    const paneStack = document.getElementById('pane-stack');
    if (paneStack) paneStack.style.order = '0';

    const setOrder = (k, ord)=>{
      const el = document.getElementById(k+'-panel');
      if (el) el.style.order = String(ord);
      // also resizer elements if any (legacy) will be hidden via CSS
    };
    // left side: negative increasing
    (settingsCache.panelOrderLeft||[]).forEach((k,i)=>setOrder(k, -100 + i));
    // right side: positive increasing
    (settingsCache.panelOrderRight||[]).forEach((k,i)=>setOrder(k, 100 + i));
  }

  window.__ccGetPanelSide = function(key){
    ensureState();
    return (settingsCache.panelSides && settingsCache.panelSides[key]==='right') ? 'right' : 'left';
  };

  window.__ccSetPanelSide = function(key, side, save=true){
    ensureState();
    if (!PANEL_KEYS.includes(key)) return;
    settingsCache.panelSides[key] = (side === 'right') ? 'right' : 'left';
    // move to end of that side
    const left = settingsCache.panelOrderLeft||[];
    const right = settingsCache.panelOrderRight||[];
    const rm = (arr)=>{ const idx=arr.indexOf(key); if(idx>=0) arr.splice(idx,1); };
    rm(left); rm(right);
    (settingsCache.panelSides[key]==='right' ? right : left).push(key);
    settingsCache.panelOrderLeft = left; settingsCache.panelOrderRight = right;
    if (save) saveState();
    window.__ccApplyPanelSideClasses();
    if (typeof applyDockedPanelWidths === 'function') applyDockedPanelWidths();
    if (typeof updateDockSplitState === 'function') updateDockSplitState();
  };

  window.__ccTogglePanelSide = function(key){
    ensureState();
    if (!PANEL_KEYS.includes(key)) return;
    const cur = window.__ccGetPanelSide(key);
    const next = cur === 'right' ? 'left' : 'right';
    window.__ccSetPanelSide(key, next, true);
  };

  window.__ccApplyPanelSideClasses = function(){
    ensureState();
    const c = document.getElementById('main-container');
    if (!c) return;

    // reset classes
    ['memo','world','character','structure','outline','search','terms'].forEach(k=>{
      c.classList.remove(k+'-right');
      c.classList.remove(k+'-left');
    });

    // floating-left variants use *-left class; right is default (no class) for some
    PANEL_KEYS.forEach(k=>{
      const side = window.__ccGetPanelSide(k);
      if (side === 'right') c.classList.add(k+'-right');
      else c.classList.add(k+'-left');
    });

    // outline/search: existing CSS uses outline-left/search-left for left floating
    // (right floating is default), so ensure we keep *-left and avoid forcing right-only behavior
    applyOrders();
    if (typeof window.__ccUpdateDockResizers === 'function') window.__ccUpdateDockResizers();
  };

  window.__ccReorderWithinSide = function(key, beforeKey){
    ensureState();
    const side = window.__ccGetPanelSide(key);
    const arrName = (side === 'right') ? 'panelOrderRight' : 'panelOrderLeft';
    const arr = (settingsCache[arrName]||[]).slice().filter(k=>PANEL_KEYS.includes(k) && k!==key);
    const idx = arr.indexOf(beforeKey);
    if (idx >= 0) arr.splice(idx, 0, key);
    else arr.push(key);
    settingsCache[arrName] = arr;
    saveState();
    window.__ccApplyPanelSideClasses();
  };

  window.__ccInitPanelSideState = function(){
    if (!window.settingsCache) return;
    loadState();
    ensureState();
    saveState();
    window.__ccApplyPanelSideClasses();
  };
})();

window.__ccGetMaxPinnedPanels = function() {
        const el = document.getElementById('st-max-pinned-panels');
        const v = parseInt(el?.value || settingsCache.maxPinnedPanels || '4', 10);
        return Math.min(8, Math.max(2, isFinite(v) ? v : 4));
    };

    window.__ccIsPinnedKey = function(key) {
        const def = window.__ccPinnableDefs?.[key];
        if (!def) return false;
        const cb = document.getElementById(def.checkboxId);
        if (!cb) return false;
        if (def.kind === 'pane') {
            const pane = document.getElementById(def.paneId);
            const visible = cb.checked !== false && pane && !pane.classList.contains('hidden');
            return visible;
        }
        return cb.checked === true;
    };

    window.__ccGetPinnedKeys = function() {
        const defs = window.__ccPinnableDefs || {};
        return Object.keys(defs).filter(k => window.__ccIsPinnedKey(k));
    };

    window.__ccGetPinnedCount = function() {
        return window.__ccGetPinnedKeys().length;
    };

    window.__ccGetReplaceablePinnedKeys = function(excludeKey) {
        const keys = window.__ccGetPinnedKeys();
        return keys.filter(k => {
            const def = window.__ccPinnableDefs[k];
            if (!def) return false;
            if (def.nonReplaceable) return false; // 入力は外せない
            if (excludeKey && k === excludeKey) return false;
            return true;
        });
    };

    window.__ccCollapseFloatingPanels = function() {
        const mainContainer = document.getElementById('main-container');
        // 対象: ドック固定ではない open パネルを閉じる（前面の浮動だけ…の要望に対し、安全側で全部閉じる）
        const maybeClose = (panelId, dockCheckboxId, dockedClass) => {
            const p = document.getElementById(panelId);
            const cb = document.getElementById(dockCheckboxId);
            const docked = (cb && cb.checked) || (mainContainer && mainContainer.classList.contains(dockedClass));
            if (p && p.classList.contains('open') && !docked) p.classList.remove('open');
        };
        maybeClose('memo-panel','check-memo-dock','memo-docked');
        maybeClose('outline-panel','check-outline-dock','outline-docked');
        maybeClose('search-panel','check-search-dock','search-docked');
        maybeClose('structure-panel','check-structure-dock','structure-docked');
        maybeClose('character-panel','check-character-dock','character-docked');
        maybeClose('world-panel','check-world-dock','world-docked');

        // control-panel（設定など）
        document.querySelectorAll('.control-panel.open').forEach(p => {
            if (!pinnedPanels.has(p.id)) p.classList.remove('open');
        });

        if (window.__ccFrontPanelId) window.__ccFrontPanelId = null;
        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
        if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
        if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
    };

    window.__ccUnpinKey = function(key) {
        const def = window.__ccPinnableDefs?.[key];
        if (!def) return;
        if (def.kind === 'pane') {
            if (key === 'preview') {
                if (typeof hidePane === 'function') hidePane('preview');
                else {
                    const cb = document.getElementById(def.checkboxId);
                    const pane = document.getElementById(def.paneId);
                    if (cb) cb.checked = false;
                    if (pane) pane.classList.add('hidden');
                    if (typeof adjustPaneWidthsOnVisibility === 'function') adjustPaneWidthsOnVisibility();
                }
            }
            return;
        }
        const cb = document.getElementById(def.checkboxId);
        if (cb) cb.checked = false;
        const fn = window[def.dockFn];
        if (typeof fn === 'function') fn();
        const panel = document.getElementById(def.panelId);
        if (panel) panel.classList.remove('open');
        try { pinnedPanels.delete(def.panelId); } catch(e){}
    };

    window.__ccDockKey = function(key) {
        const def = window.__ccPinnableDefs?.[key];
        if (!def || def.kind !== 'dock') return;
        const cb = document.getElementById(def.checkboxId);
        if (cb) cb.checked = true;
        const fn = window[def.dockFn];
        if (typeof fn === 'function') fn();
        const panel = document.getElementById(def.panelId);
        if (panel) {
            panel.classList.add('open');
            if (window.bringPanelToFront) window.bringPanelToFront(panel, true);
        }
        try { pinnedPanels.add(def.panelId); } catch(e){}
    };

    // ---- 入れ替え/超過解消ダイアログ ----
    window.__ccPinnedDialogState = { mode:null, targetKey:null, prevMax:null };

    window.__ccShowPinnedDialog = function({mode, targetKey, prevMax}) {
        const overlay = document.getElementById('pinned-limit-overlay');
        const titleEl = document.getElementById('pinned-limit-title');
        const msgEl = document.getElementById('pinned-limit-message');
        const selectEl = document.getElementById('pinned-limit-select');
        const okBtn = document.getElementById('pinned-limit-ok');
        const cancelBtn = document.getElementById('pinned-limit-cancel');
        if (!overlay || !titleEl || !msgEl || !selectEl || !okBtn || !cancelBtn) return;

        window.__ccPinnedDialogState = { mode, targetKey: targetKey || null, prevMax: prevMax ?? null, snapshot: null };

        // スナップショット（キャンセル時に完全復帰させる）
        try {
            const snap = {
                pinnedKeys: (window.__ccGetPinnedKeys ? window.__ccGetPinnedKeys() : []),
                openStates: {},
                checkboxStates: {}
            };

            // checkbox states（ドック固定/プレビュー表示など）
            [
                'check-memo-dock','check-outline-dock','check-search-dock',
                'check-structure-dock','check-character-dock','check-world-dock',
                'check-show-preview','check-show-input'
            ].forEach(id => {
                const el = document.getElementById(id);
                if (el) snap.checkboxStates[id] = !!el.checked;
            });

            // open states（ドックパネル）
            const panelMap = {
                memo:'memo-panel', outline:'outline-panel', search:'search-panel',
                structure:'structure-panel', character:'character-panel', world:'world-panel'
            };
            Object.keys(panelMap).forEach(k => {
                const p = document.getElementById(panelMap[k]);
                if (p) snap.openStates[k] = p.classList.contains('open');
            });

            window.__ccPinnedDialogState.snapshot = snap;
        } catch(e) {}
        const max = window.__ccGetMaxPinnedPanels();
        const count = window.__ccGetPinnedCount();

        // populate options
        const replaceable = window.__ccGetReplaceablePinnedKeys(targetKey || null);
        selectEl.innerHTML = '';
        replaceable.forEach(k => {
            const opt = document.createElement('option');
            opt.value = k;
            opt.textContent = window.__ccPinnableDefs[k]?.label || k;
            selectEl.appendChild(opt);
        });

        if (mode === 'swap') {
            titleEl.textContent = '固定パネル上限に達しています';
            msgEl.textContent = `上限（${max}）に達しています。固定を入れ替える対象を選んでください。`;
            okBtn.textContent = '入れ替える';
            cancelBtn.textContent = 'キャンセル';
            okBtn.disabled = replaceable.length === 0;
            cancelBtn.style.display = '';
        } else {
            titleEl.textContent = '固定パネルが上限を超えています';
            msgEl.textContent = `固定数（${count}）が上限（${max}）を超えています。解除するパネルを選んでください。`;
            okBtn.textContent = '解除する';
            cancelBtn.textContent = 'キャンセル';
            okBtn.disabled = replaceable.length === 0;
            cancelBtn.style.display = '';
        }

        overlay.style.display = 'flex';
    };

    window.__ccHidePinnedDialog = function() {
        const overlay = document.getElementById('pinned-limit-overlay');
        if (overlay) overlay.style.display = 'none';
        window.__ccPinnedDialogState = { mode:null, targetKey:null, prevMax:null };
    };

    window.__ccHandlePinnedDialogOk = function() {
        const state = window.__ccPinnedDialogState || {};
        const selectEl = document.getElementById('pinned-limit-select');
        const chosen = selectEl?.value;
        if (!chosen) return;

        if (state.mode === 'swap') {
            // unpin chosen, dock target
            window.__ccUnpinKey(chosen);
            window.__ccDockKey(state.targetKey);
            if (typeof window.__ccCollapseFloatingPanels === 'function') window.__ccCollapseFloatingPanels();
            window.__ccHidePinnedDialog();
        } else {
            // reduce: unpin chosen, keep dialog until within limit
            window.__ccUnpinKey(chosen);
            const max = window.__ccGetMaxPinnedPanels();
            const count = window.__ccGetPinnedCount();
            if (count <= max) {
                window.__ccHidePinnedDialog();
            } else {
                window.__ccShowPinnedDialog({mode:'reduce', prevMax: state.prevMax});
            }
        }

        if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();
        if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    };

    window.__ccHandlePinnedDialogCancel = function() {
        const state = window.__ccPinnedDialogState || {};

        // swap のキャンセルは「完全に無変更」へ戻す（固定解除/折り畳み等を起こさない）
        if (state.mode === 'swap' && state.snapshot) {
            try {
                const snap = state.snapshot;
                // restore checkbox states
                Object.keys(snap.checkboxStates || {}).forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.checked = !!snap.checkboxStates[id];
                });

                // apply dock toggles to match checkbox states
                const applyDock = (key, toggleFnName) => {
                    const def = window.__ccPinnableDefs?.[key];
                    const cb = def ? document.getElementById(def.checkboxId) : null;
                    if (!cb) return;
                    // call the toggle function to apply layout (reads checkbox.checked)
                    const fn = window[toggleFnName];
                    if (typeof fn === 'function') fn();
                    // restore open state
                    const panel = def.panelId ? document.getElementById(def.panelId) : null;
                    if (panel && snap.openStates && (key in snap.openStates)) {
                        panel.classList.toggle('open', !!snap.openStates[key]);
                    }
                };

                applyDock('memo','toggleMemoDock');
                applyDock('outline','toggleOutlineDock');
                applyDock('search','toggleSearchDock');
                applyDock('structure','toggleStructureDock');
                applyDock('character','toggleCharacterDock');
                applyDock('world','toggleWorldDock');

                // restore preview visibility if present
                try { if (typeof applyPreviewDisplaySettings === 'function') applyPreviewDisplaySettings(); } catch(e) {}

                // side classes restored from settings (no override), but ensure applied
                try { if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses(); } catch(e) {}
            } catch(e) {}
        }

        if (state.mode === 'reduce' && state.prevMax != null) {
            // revert max
            const sel = document.getElementById('st-max-pinned-panels');
            if (sel) sel.value = String(state.prevMax);
            settingsCache.maxPinnedPanels = state.prevMax;
            if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();
        }
        window.__ccHidePinnedDialog();
    };;

    window.__ccRequestDockWithLimit = function(targetKey) {
        if (window.__ccIsPinnedKey(targetKey)) return true;
        const max = window.__ccGetMaxPinnedPanels();
        const count = window.__ccGetPinnedCount();
        if (count < max) {
            window.__ccDockKey(targetKey);
            if (typeof window.__ccCollapseFloatingPanels === 'function') window.__ccCollapseFloatingPanels();
            return true;
        }
        const replaceable = window.__ccGetReplaceablePinnedKeys(targetKey);
        if (replaceable.length === 0) {
            alert('固定パネル上限に達しています。上限を上げるか、プレビュー表示をオフにして枠を空けてください。');
            return false;
        }
        window.__ccShowPinnedDialog({mode:'swap', targetKey});
        return false;
    };


    // ---- Dock checkbox change handler with pinned-limit enforcement ----
    // Prevent bypassing maxPinnedPanels when users click the dock checkbox directly.
    window.onDockCheckboxChange = function(key) {
        try {
            const def = window.__ccPinnableDefs?.[key];
            if (!def || def.kind !== 'dock') return;
            const cb = document.getElementById(def.checkboxId);
            if (!cb) return;

            // If turning ON via checkbox, enforce limit through __ccRequestDockWithLimit
            if (cb.checked) {
                // revert immediately; __ccRequestDockWithLimit will re-check and apply if allowed
                cb.checked = false;
                if (typeof window.__ccRequestDockWithLimit === 'function') {
                    window.__ccRequestDockWithLimit(key);
                    return;
                }
                // fallback (no limit logic available)
                cb.checked = true;
                const fn = window[def.dockFn];
                if (typeof fn === 'function') fn();
                const panel = def.panelId ? document.getElementById(def.panelId) : null;
                if (panel) {
                    panel.classList.add('open');
                    if (window.bringPanelToFront) window.bringPanelToFront(panel, true);
                }
                return;
            }

            // Turning OFF via checkbox: undock but keep panel open as floating
            const fn = window[def.dockFn];
            if (typeof fn === 'function') fn();
            const panel = def.panelId ? document.getElementById(def.panelId) : null;
            if (panel) {
                panel.classList.add('open');
                if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
            }
            try { if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates(); } catch(e) {}
            try { if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage(); } catch(e) {}
        } catch(e) {}
    };


    function applyPinnedLimitSettings() {
        const sel = document.getElementById('st-max-pinned-panels');
        if (!sel) return;
        const prev = settingsCache.maxPinnedPanels || 4;
        const v = parseInt(sel.value || '4', 10);
        settingsCache.maxPinnedPanels = Math.min(8, Math.max(2, isFinite(v) ? v : 4));
        if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();

        const max = window.__ccGetMaxPinnedPanels();
        const count = window.__ccGetPinnedCount();
        if (count > max) {
            window.__ccShowPinnedDialog({mode:'reduce', prevMax: prev});
        }
    }

    function applyAllSettings() { applyInputSettings(); applyPreviewSettings(); applyDisplaySettings(); applyWritingSettings(); applyGoalSettings();
        updateWritingModeButtonLabels(); applyManuscriptSettings(); applyThemeSettings(); applyOpenSettings(); applyPaneWidthSettings(); applyPaneHeightSettings(); applyDividerSettings(); applyAutoSaveSettings(true); applyTextColorSettings(); applyPinnedLimitSettings(); }

    function resetAllSettings() {
        if (!confirm('全ての設定を初期状態に戻しますか？')) return;
        // Reset to defaults
        document.getElementById('st-in-size').value = 17;
        document.getElementById('st-in-line').value = 1.7;
        document.getElementById('st-in-font').value = 'font-gothic';
        document.getElementById('st-in-v').checked = true;
        document.getElementById('st-pv-size').value = 17;
        document.getElementById('st-pv-line').value = 1.7;
        document.getElementById('st-pv-font').value = 'font-gothic';
        document.getElementById('st-pv-v').checked = true;
        document.getElementById('check-show-input').checked = true;
        document.getElementById('check-show-preview').checked = true;
        document.getElementById('st-show-space').checked = true;
        document.getElementById('st-show-highlight').checked = true;
        document.getElementById('st-default-preview-hidden').checked = false;
        document.getElementById('st-typewriter-mode').checked = false;
        document.getElementById('st-writing-tracker').checked = true;
        document.getElementById('st-goal-chars').value = 150000;
        document.getElementById('st-today-goal').value = 2000;
        document.getElementById('st-celebrate-goal').checked = true;
        document.getElementById('st-show-reading-time').checked = true;
        document.getElementById('st-manuscript-rows').value = 34;
        document.getElementById('st-manuscript-cols').value = 42;
        document.getElementById('st-show-manuscript').checked = true;
        document.querySelector('input[name="st-open-mode"][value="current"]').checked = true;
        document.getElementById('st-autosave-interval').value = 60;
        document.getElementById('st-autosave-enabled').checked = false;
        document.getElementById('st-theme-preset').value = '';
        document.getElementById('st-text-color-text').value = '';
        document.getElementById('st-text-color').value = '#1f2937';
        document.getElementById('st-pane-input-width').value = 520;
        document.getElementById('st-pane-preview-width').value = 520;
        document.getElementById('st-pane-memo-width').value = 260;
        document.getElementById('st-pane-outline-width').value = 260;
        document.getElementById('st-pane-structure-width').value = 300;
        document.getElementById('st-pane-search-width').value = 320;
        document.getElementById('st-divider-width').value = 2;
        const inputH = document.getElementById('st-pane-input-height');
        const previewH = document.getElementById('st-pane-preview-height');
        if (inputH) inputH.value = 520;
        if (previewH) previewH.value = 520;

        // テーマとカラーをリセット
        document.body.classList.remove('theme-dark', 'theme-sepia', 'theme-blue', 'theme-green');
        document.documentElement.style.setProperty('--active-tab-bg', '#fff59d');
        localStorage.removeItem(TEXT_COLOR_KEY);

        applyAllSettings();
        autoSaveTarget = { handle: null, type: null, scope: 'current' };
        setAutoSaveEnabled(false);
        resetPaneWidths();
        resetPaneHeights();

        // localStorage をクリア（設定関連のみ）
        localStorage.removeItem(DIVIDER_WIDTH_KEY);
        localStorage.removeItem(SETTINGS_KEY);
        localStorage.removeItem('cc_outline_rules_v1');
        localStorage.removeItem('cc_active_tab_color');
        localStorage.removeItem('cc_pane_colors_v3');

        // 構成パネルを閉じてデータをクリア
        localStorage.removeItem('cc_structure_data');
        localStorage.removeItem('cc_character_data');
        localStorage.removeItem('cc_world_data');
        const structurePanel = document.getElementById('structure-panel');
        const structureCheckbox = document.getElementById('check-structure-dock');
        const mainContainer = document.getElementById('main-container');
        if (structurePanel) structurePanel.classList.remove('open');
        if (structureCheckbox) structureCheckbox.checked = false;
        if (mainContainer) {
            mainContainer.classList.remove('structure-docked');
            mainContainer.classList.remove('structure-right');
        }
        if (typeof window.initStructureFromReset === 'function') window.initStructureFromReset();
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
    }

    function clampValue(value, min, max) {
        if (Number.isNaN(value)) return min;
        return Math.max(min, Math.min(max, value));
    }

    function applyDockedPanelWidths(unifyAll=false) {
        const sideEl = document.getElementById('st-pane-side-width');
        const memoEl = document.getElementById('st-pane-memo-width');
        const outlineEl = document.getElementById('st-pane-outline-width');
        const structureEl = document.getElementById('st-pane-structure-width');
        const searchEl = document.getElementById('st-pane-search-width');
        const characterEl = document.getElementById('st-pane-character-width');
        const worldEl = document.getElementById('st-pane-world-width');
        const termsEl = document.getElementById('st-pane-terms-width');

        const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const readLS = (k, fallback) => {
            try {
                const v = parseInt(localStorage.getItem(k), 10);
                return Number.isFinite(v) ? v : fallback;
            } catch(e){ return fallback; }
        };

        // Read per-pane widths (do NOT overwrite by side width unless unifyAll=true)
        const sideWidth = clamp(parseInt(sideEl?.value, 10) || readLS(PANE_WIDTH_KEYS.side, 300), 160, 2000);
        const searchWidth = clamp(parseInt(searchEl?.value, 10) || readLS(PANE_WIDTH_KEYS.search, 320), 160, 2000);

        const memoW = clamp(parseInt(memoEl?.value, 10) || readLS(PANE_WIDTH_KEYS.memo, sideWidth), 160, 2000);
        const outlineW = clamp(parseInt(outlineEl?.value, 10) || readLS(PANE_WIDTH_KEYS.outline, sideWidth), 160, 2000);
        const structureW = clamp(parseInt(structureEl?.value, 10) || readLS(PANE_WIDTH_KEYS.structure, sideWidth), 160, 2000);
        const characterW = clamp(parseInt(characterEl?.value, 10) || readLS(PANE_WIDTH_KEYS.character, sideWidth), 160, 2000);
        const worldW = clamp(parseInt(worldEl?.value, 10) || readLS(PANE_WIDTH_KEYS.world, sideWidth), 160, 2000);
        const termsW = clamp(parseInt(termsEl?.value, 10) || readLS(PANE_WIDTH_KEYS.terms, sideWidth), 160, 2000);

        // When user explicitly applies "サイド幅", unify all docked panel widths to sideWidth.
        const finalMemo = unifyAll ? sideWidth : memoW;
        const finalOutline = unifyAll ? sideWidth : outlineW;
        const finalStructure = unifyAll ? sideWidth : structureW;
        const finalCharacter = unifyAll ? sideWidth : characterW;
        const finalWorld = unifyAll ? sideWidth : worldW;
        const finalTerms = unifyAll ? sideWidth : termsW;

        // Sync inputs (hidden compatibility inputs too)
        if (sideEl) sideEl.value = sideWidth;
        if (memoEl) memoEl.value = finalMemo;
        if (outlineEl) outlineEl.value = finalOutline;
        if (structureEl) structureEl.value = finalStructure;
        if (characterEl) characterEl.value = finalCharacter;
        if (worldEl) worldEl.value = finalWorld;
        if (termsEl) termsEl.value = finalTerms;
        if (searchEl) searchEl.value = searchWidth;

        const applyW = (id, w) => {
            const p = document.getElementById(id);
            if (!p) return;
            p.style.width = `${w}px`;
            p.style.flexBasis = `${w}px`;
        };

        applyW('memo-panel', finalMemo);
        applyW('outline-panel', finalOutline);
        applyW('structure-panel', finalStructure);
        applyW('character-panel', finalCharacter);
        applyW('world-panel', finalWorld);
        applyW('terms-panel', finalTerms);
        applyW('search-panel', searchWidth);

        try {
            // Persist per-pane widths so divider dragging stays effective.
            localStorage.setItem(PANE_WIDTH_KEYS.side, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.memo, finalMemo);
            localStorage.setItem(PANE_WIDTH_KEYS.outline, finalOutline);
            localStorage.setItem(PANE_WIDTH_KEYS.structure, finalStructure);
            localStorage.setItem(PANE_WIDTH_KEYS.character, finalCharacter);
            localStorage.setItem(PANE_WIDTH_KEYS.world, finalWorld);
            localStorage.setItem(PANE_WIDTH_KEYS.terms, finalTerms);
            localStorage.setItem(PANE_WIDTH_KEYS.search, searchWidth);
        } catch(e) {}

        // Update dock resizer overlay positions
        try { if (typeof window.__ccUpdateDockResizers === 'function') window.__ccUpdateDockResizers(); } catch(e){}
    }

    function applyPaneWidthSettings() {
        const inputWidthEl = document.getElementById('st-pane-input-width');
        const previewWidthEl = document.getElementById('st-pane-preview-width');

        if (!inputWidthEl || !previewWidthEl) return;

        const inputWidth = clampValue(parseInt(inputWidthEl.value, 10) || 520, 120, 3000);
        const previewWidth = clampValue(parseInt(previewWidthEl.value, 10) || 520, 120, 3000);

        inputWidthEl.value = inputWidth;
        previewWidthEl.value = previewWidth;

        localStorage.setItem(PANE_WIDTH_KEYS.input, inputWidth);
        localStorage.setItem(PANE_WIDTH_KEYS.preview, previewWidth);

        applyDockedPanelWidths(true);
        adjustPaneWidthsOnVisibility();
        updateDockSplitState();
    }

	function applyPaneHeightSettings() {
    const inputHeightEl = document.getElementById('st-pane-input-height');
    const previewHeightEl = document.getElementById('st-pane-preview-height');
    const inputPane = document.getElementById('pane-input');
    const previewPane = document.getElementById('pane-preview');

    // 必要な要素が無いなら何もしない（落ちないように）
    if (!inputHeightEl || !previewHeightEl || !inputPane || !previewPane) return;

    const inputHeightRaw = parseInt(inputHeightEl.value, 10);
    const previewHeightRaw = parseInt(previewHeightEl.value, 10);

    const inputHeight = clampValue(inputHeightRaw || 520, 160, 2000);
    const previewHeight = clampValue(previewHeightRaw || 520, 160, 2000);

    inputHeightEl.value = inputHeight;
    previewHeightEl.value = previewHeight;

    if (document.body.classList.contains('scroll-mode')) {
        inputPane.style.height = `${inputHeight}px`;
        previewPane.style.height = `${previewHeight}px`;
    } else {
        inputPane.style.height = '';
        previewPane.style.height = '';
    }

    localStorage.setItem(PANE_HEIGHT_KEYS.input, String(inputHeight));
    localStorage.setItem(PANE_HEIGHT_KEYS.preview, String(previewHeight));

    if (typeof adjustPaneHeightsOnVisibility === 'function') {
        adjustPaneHeightsOnVisibility();
    }
}

function resetPaneWidths() {
    document.getElementById('st-pane-input-width').value = 520;
    document.getElementById('st-pane-preview-width').value = 520;

    const sideEl = document.getElementById('st-pane-side-width');
    if (sideEl) sideEl.value = 300;

    // keep hidden per-panel inputs in sync
    const memoEl = document.getElementById('st-pane-memo-width');
    const outlineEl = document.getElementById('st-pane-outline-width');
    const structureEl = document.getElementById('st-pane-structure-width');
    const searchEl = document.getElementById('st-pane-search-width');
    const charEl = document.getElementById('st-pane-character-width');
    const worldEl = document.getElementById('st-pane-world-width');
    const termsEl = document.getElementById('st-pane-terms-width');

    if (memoEl) memoEl.value = 300;
    if (outlineEl) outlineEl.value = 300;
    if (structureEl) structureEl.value = 300;
    if (searchEl) searchEl.value = 320;
    if (charEl) charEl.value = 300;
    if (worldEl) worldEl.value = 300;
    if (termsEl) termsEl.value = 300;

    localStorage.removeItem(PANE_WIDTH_KEYS.input);
    localStorage.removeItem(PANE_WIDTH_KEYS.preview);
    localStorage.removeItem(PANE_WIDTH_KEYS.side);
    localStorage.removeItem(PANE_WIDTH_KEYS.memo);
    localStorage.removeItem(PANE_WIDTH_KEYS.outline);
    localStorage.removeItem(PANE_WIDTH_KEYS.structure);
    localStorage.removeItem(PANE_WIDTH_KEYS.search);
    localStorage.removeItem(PANE_WIDTH_KEYS.character);
    localStorage.removeItem(PANE_WIDTH_KEYS.world);
    localStorage.removeItem(PANE_WIDTH_KEYS.terms);
    localStorage.removeItem(PANE_WIDTH_KEYS.legacyInput);
    localStorage.removeItem(PANE_WIDTH_KEYS.legacyPreview);

    applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
}

function resetIndividualPaneWidth(paneName) {
    const defaults = { input: 520, preview: 520, memo: 300, outline: 300, structure: 300, search: 300, character: 300, world: 300 };
    const el = document.getElementById(`st-pane-${paneName}-width`);
    if (el && defaults[paneName]) {
        el.value = defaults[paneName];
        localStorage.removeItem(PANE_WIDTH_KEYS[paneName]);
        applyPaneWidthSettings();
    }
}

function resetPaneHeights() {
    const inputHeightEl = document.getElementById('st-pane-input-height');
    const previewHeightEl = document.getElementById('st-pane-preview-height');

    if (inputHeightEl) inputHeightEl.value = 520;
    if (previewHeightEl) previewHeightEl.value = 520;

    localStorage.removeItem(PANE_HEIGHT_KEYS.input);
    localStorage.removeItem(PANE_HEIGHT_KEYS.preview);

    if (typeof applyPaneHeightSettings === 'function') {
        applyPaneHeightSettings();
    }
}

function updateDockSplitState() {
    const c = document.getElementById('main-container');
    if (!c) return;
    const memoDocked = c.classList.contains('memo-docked');
    const outlineDocked = c.classList.contains('outline-docked');
    const memoRight = c.classList.contains('memo-right');
    const outlineLeft = c.classList.contains('outline-left');
    const splitRight = memoDocked && outlineDocked && memoRight && !outlineLeft;
    const splitLeft = memoDocked && outlineDocked && !memoRight && outlineLeft;
    c.classList.toggle('dock-split-right', splitRight);
    c.classList.toggle('dock-split-left', splitLeft);

    try{ if (typeof window.__ccUpdateDockResizers === 'function') window.__ccUpdateDockResizers(); }catch(e){}
}

    function loadPaneWidthSettings() {
        const mainContainer = document.getElementById('main-container');
        const containerWidth = mainContainer.getBoundingClientRect().width || 1000;
        const legacyInput = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.legacyInput), 10);
        const legacyPreview = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.legacyPreview), 10);
        const inputWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.input), 10);
        const previewWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.preview), 10);
        const memoWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.memo), 10);
        const outlineWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.outline), 10);
        const structureWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.structure), 10);
        const searchWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.search), 10);

        if (inputWidth || legacyInput) {
            const converted = inputWidth || Math.round(containerWidth * (legacyInput / 100));
            document.getElementById('st-pane-input-width').value = converted;
        }
        if (previewWidth || legacyPreview) {
            const converted = previewWidth || Math.round(containerWidth * (legacyPreview / 100));
            document.getElementById('st-pane-preview-width').value = converted;
        }
        if (memoWidth) {
            document.getElementById('st-pane-memo-width').value = memoWidth;
        }
        if (outlineWidth) {
            document.getElementById('st-pane-outline-width').value = outlineWidth;
        }
        if (structureWidth) {
            document.getElementById('st-pane-structure-width').value = structureWidth;
        }
        if (searchWidth) {
            document.getElementById('st-pane-search-width').value = searchWidth;
        }
    
        // fix5: unified side width (memo/outline/structure/character/world/terms)
        const characterWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.character), 10);
        const worldWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.world), 10);
        const termsWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.terms), 10);
        const sideWidthStored = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.side), 10);
        const sideWidth = Number.isFinite(sideWidthStored) ? sideWidthStored :
                          (Number.isFinite(termsWidth) ? termsWidth :
                           (Number.isFinite(worldWidth) ? worldWidth :
                            (Number.isFinite(characterWidth) ? characterWidth :
                             (Number.isFinite(structureWidth) ? structureWidth :
                              (Number.isFinite(memoWidth) ? memoWidth :
                               (Number.isFinite(outlineWidth) ? outlineWidth : 300))))));
        const sideEl = document.getElementById('st-pane-side-width');
        if (sideEl) sideEl.value = sideWidth;

        // sync hidden per-panel width inputs for backward compatibility
        const memoEl = document.getElementById('st-pane-memo-width');
        const outlineEl = document.getElementById('st-pane-outline-width');
        const structureEl = document.getElementById('st-pane-structure-width');
        const characterEl = document.getElementById('st-pane-character-width');
        const worldEl = document.getElementById('st-pane-world-width');
        const termsEl = document.getElementById('st-pane-terms-width');
        if (memoEl) memoEl.value = sideWidth;
        if (outlineEl) outlineEl.value = sideWidth;
        if (structureEl) structureEl.value = sideWidth;
        if (characterEl) characterEl.value = sideWidth;
        if (worldEl) worldEl.value = sideWidth;
        if (termsEl) termsEl.value = sideWidth;

        try {
            localStorage.setItem(PANE_WIDTH_KEYS.side, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.memo, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.outline, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.structure, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.character, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.world, sideWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.terms, sideWidth);
        } catch(e) {}
}

    function loadDividerSettings() {
        const dividerWidth = parseInt(localStorage.getItem(DIVIDER_WIDTH_KEY), 10);
        if (Number.isFinite(dividerWidth)) {
            document.getElementById('st-divider-width').value = dividerWidth;
        }
        applyDividerSettings();
    }

	function loadPaneHeightSettings() {
    const inputHeightEl = document.getElementById('st-pane-input-height');
    const previewHeightEl = document.getElementById('st-pane-preview-height');

    // UIが無いなら何もしない（落ちないように）
    if (!inputHeightEl || !previewHeightEl) return;

    const inputHeight = parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.input), 10);
    const previewHeight = parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.preview), 10);

    if (Number.isFinite(inputHeight)) inputHeightEl.value = inputHeight;
    if (Number.isFinite(previewHeight)) previewHeightEl.value = previewHeight;

    if (typeof applyPaneHeightSettings === 'function') {
        applyPaneHeightSettings();
    }
}

    const pinnedPanels = new Set();
    function updateControlPanelScrollState() {
        const hasOpen = document.querySelectorAll('.control-panel.open').length > 0;
        document.body.classList.toggle('allow-scroll', hasOpen);
        updateDockTopOffset();
    }
    function getPanelStateIcon(isOpen, isPinned) {
        if (isPinned) return '📌';
        if (isOpen) return '▾';
        return '▸';
    }
    function updateControlPanelButton(panelId, btnId) {
        const panel = document.getElementById(panelId);
        const btn = document.getElementById(btnId);
        if (!panel || !btn) return;

        const isOpen = panel.classList.contains('open');
        const isPinned = (typeof pinnedPanels !== 'undefined') ? pinnedPanels.has(panelId) : false;
        const isFront = (!isPinned && isOpen && window.__ccFrontPanelId === panelId);

        const iconEl = btn.querySelector('.panel-state-icon');
        if (iconEl) iconEl.textContent = getPanelStateIcon(isOpen, isPinned);

        btn.classList.toggle('is-open', isOpen);
        btn.classList.toggle('is-pinned', isPinned);
        btn.classList.toggle('is-front', isFront);
    }
    function updateDockPanelButton(panelId, btnId, dockCheckboxId) {
        const panel = document.getElementById(panelId);
        const btn = document.getElementById(btnId);
        const dockCheckbox = document.getElementById(dockCheckboxId);
        if (!panel || !btn || !dockCheckbox) return;

        const isOpen = panel.classList.contains('open');
        const isPinned = dockCheckbox.checked;
        const isFront = (!isPinned && isOpen && window.__ccFrontPanelId === panelId);

        const iconEl = btn.querySelector('.panel-state-icon');
        if (iconEl) iconEl.textContent = getPanelStateIcon(isOpen, isPinned);

        btn.classList.toggle('is-open', isOpen);
        btn.classList.toggle('is-pinned', isPinned);
        btn.classList.toggle('is-front', isFront);
    }
    function updatePanelButtonStates() {
        updateControlPanelButton('help-bar', 'btn-toggle-help');
        updateControlPanelButton('settings-bar', 'btn-toggle-settings');
        updateDockPanelButton('memo-panel', 'btn-toggle-memo', 'check-memo-dock');
        updateDockPanelButton('outline-panel', 'btn-toggle-outline', 'check-outline-dock');
        updateDockPanelButton('search-panel', 'btn-toggle-search', 'check-search-dock');
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
    }
    function togglePanel(id) {
        const p = document.getElementById(id);
        const btn = document.querySelector(`#${id} .panel-pin-btn`);
        if (p.classList.contains('open')) {
            if (pinnedPanels.has(id)) {
                // If pinned, unpin and close
                pinnedPanels.delete(id);
                if (btn) btn.classList.remove('pinned');
                p.classList.remove('open');
            } else {
                // If open but not pinned, pin it
                pinnedPanels.add(id);
                if (btn) btn.classList.add('pinned');
            }
        } else {
            // Close non-pinned panels
            document.querySelectorAll('.control-panel.open').forEach(x => {
                if (!pinnedPanels.has(x.id) && x.id !== id) x.classList.remove('open');
            });
            p.classList.add('open');
            if (window.bringPanelToFront) window.bringPanelToFront(p, false);
        }
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }
    function closeControlPanel(id) {
        const p = document.getElementById(id);
        const btn = document.querySelector(`#${id} .panel-pin-btn`);
        if (!p) return;
        p.classList.remove('open');
        pinnedPanels.delete(id);
        if (btn) btn.classList.remove('pinned');
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }
    function togglePanelPin(id) {
        const btn = document.querySelector(`#${id} .panel-pin-btn`);
        if (pinnedPanels.has(id)) {
            pinnedPanels.delete(id);
            btn.classList.remove('pinned');
        } else {
            pinnedPanels.add(id);
            btn.classList.add('pinned');
        }
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }
    function updateDockTopOffset() {
        const header = document.querySelector('header');
        const controls = document.querySelector('.controls-wrapper');
        const padding = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--layout-padding')) || 0;
        const headerHeight = header ? header.getBoundingClientRect().height : 0;
        const controlsHeight = controls ? controls.getBoundingClientRect().height : 0;
        const top = Math.round(headerHeight + controlsHeight + padding);
        document.documentElement.style.setProperty('--dock-top', `${top}px`);
    }
    function initAppContextMenu() {
        const icon = document.getElementById('app-icon');
        const menu = document.getElementById('app-context-menu');
        if (!icon || !menu) return;
        icon.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            menu.classList.add('show');
            const { innerWidth, innerHeight } = window;
            const rect = menu.getBoundingClientRect();
            const left = Math.min(event.clientX, innerWidth - rect.width - 8);
            const top = Math.min(event.clientY, innerHeight - rect.height - 8);
            menu.style.left = `${Math.max(8, left)}px`;
            menu.style.top = `${Math.max(8, top)}px`;
        });
        menu.addEventListener('click', (event) => {
            const item = event.target.closest('.context-menu-item');
            if (!item) return;
            const action = item.dataset.action;
            if (action === 'reset-all') {
                confirmResetInput();
            }
            menu.classList.remove('show');
        });
        document.addEventListener('click', (event) => {
            if (event.target.closest('#app-context-menu') || event.target.closest('#app-icon')) return;
            menu.classList.remove('show');
        });
        document.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') menu.classList.remove('show');
        });
    }
    // 上段メニューの「同じリボンを2回押したら折りたたむ」用
    let __activeRibbonSection = null;

    function setActiveRibbonSection(section) {
        const slot = document.getElementById('ribbon-inline-slot');
        const isSame = (__activeRibbonSection === section);
        const isUltra = document.body.classList.contains('ribbon-ultra-collapsed');
        const isCollapsed = document.body.classList.contains('ribbon-collapsed');

        // 既に同じセクションが開いている状態で再クリックされたら、入れ替え領域だけ折りたたむ
        if (isSame && !isUltra && !isCollapsed) {
            document.body.classList.add('ribbon-collapsed');
            // ボタン表示も畳んだ状態に合わせる
            const buttons = document.querySelectorAll('.ribbon-menu-btn[data-section-target]');
            buttons.forEach((btn) => btn.classList.remove('active'));
            __activeRibbonSection = null;
            updateRibbonToggleLabels();
            if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
            return;
        }

        const buttons = document.querySelectorAll('.ribbon-menu-btn[data-section-target]');
        buttons.forEach((btn) => btn.classList.remove('active'));
        const activeBtn = document.querySelector(`.ribbon-menu-btn[data-section-target="${section}"]`);
        activeBtn?.classList.add('active');

        // 超折りたたみ中でも、呼ばれたら展開して入れ替え領域を見せる
        if (document.body.classList.contains('ribbon-ultra-collapsed')) {
            document.body.classList.remove('ribbon-ultra-collapsed');
        }
        // パネル折りたたみ中なら展開
        if (document.body.classList.contains('ribbon-collapsed')) {
            document.body.classList.remove('ribbon-collapsed');
        }

        // ここからは「開く」動作（別セクション or 折りたたみから復帰）

        if (!slot) {
            // フォールバック：従来の is-active 表示
            const sections = document.querySelectorAll('.ribbon-section[data-section]');
            sections.forEach((el) => el.classList.remove('is-active'));
            const target = document.querySelector(`.ribbon-section[data-section="${section}"]`);
            target?.classList.add('is-active');
            __activeRibbonSection = section;
            updateRibbonToggleLabels();
            if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
            return;
        }

        // いまスロットにいる ribbon-group を元の section に戻す
        const currentGroup = slot.querySelector('.ribbon-group');
        if (currentGroup) {
            const backTo = currentGroup.dataset.sectionHome;
            const backHost = backTo ? document.querySelector(`.ribbon-section[data-section="${backTo}"]`) : null;
            backHost?.appendChild(currentGroup);
        }
        slot.innerHTML = '';

        const targetSection = document.querySelector(`.ribbon-section[data-section="${section}"]`);
        if (!targetSection) {
            updateRibbonToggleLabels();
            if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
            return;
        }

        // section 内に ribbon-group が無い（例：拡張）場合は1回だけ包む
        let targetGroup = targetSection.querySelector('.ribbon-group');
        if (!targetGroup) {
            targetGroup = document.createElement('div');
            targetGroup.className = 'ribbon-group';
            while (targetSection.firstChild) {
                targetGroup.appendChild(targetSection.firstChild);
            }
            targetSection.appendChild(targetGroup);
        }

        targetGroup.dataset.sectionHome = section;
        slot.appendChild(targetGroup);

        __activeRibbonSection = section;
        updateRibbonToggleLabels();
        if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
    }
    function updateRibbonToggleLabels() {
    const toggleBtn = document.getElementById('btn-ribbon-toggle');
    const homeToggleBtn = document.getElementById('btn-ribbon-home-toggle');
    const isCollapsed = document.body.classList.contains('ribbon-collapsed');
    const isUltra = document.body.classList.contains('ribbon-ultra-collapsed');

    // 上段ボタン：Insert右側の入れ替え領域（パネル）の表示/非表示
    if (toggleBtn) {
        toggleBtn.textContent = (isCollapsed || isUltra) ? '▾ パネルを展開' : '▴ パネルをたたむ';
    }

    // ホーム右端：リボン全体（上段メニュー + ホーム左/入れ替え領域）の表示/非表示
    if (homeToggleBtn) {
        homeToggleBtn.textContent = isUltra ? '▾ リボンを表示' : '▴ リボンをたたむ';
    }
}

// 上段（メニュー行）右端：展開部分だけ折りたたみ
function toggleRibbonContent() {
    // ultra の時は上段自体が消えるので基本押せないが、念のため無効化
    if (document.body.classList.contains('ribbon-ultra-collapsed')) return;

    document.body.classList.toggle('ribbon-collapsed');
    updateRibbonToggleLabels();
    if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
}

// ホーム行右端：リボン全体を一発で折りたたみ（ultra）
function toggleRibbonUltra() {
    const isUltra = document.body.classList.contains('ribbon-ultra-collapsed');

    if (isUltra) {
        // 展開に戻す（フル展開に戻す）
        document.body.classList.remove('ribbon-ultra-collapsed');
        document.body.classList.remove('ribbon-collapsed');
    } else {
        // 一発でリボン全体を折りたたむ
        document.body.classList.add('ribbon-ultra-collapsed');
        document.body.classList.remove('ribbon-collapsed');
    }

    updateRibbonToggleLabels();
    if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
}

// 既存コード互換（どこかで toggleRibbon() を呼んでても壊れないように）
function toggleRibbon() {
    toggleRibbonUltra();
}

window.toggleRibbonContent = toggleRibbonContent;
window.toggleRibbonUltra = toggleRibbonUltra;
window.toggleRibbon = toggleRibbon;

// 初期状態のラベル/表示を同期
document.addEventListener('DOMContentLoaded', () => {
    try { updateRibbonToggleLabels(); } catch(e) {}
    try { setActiveRibbonSection('file'); } catch(e) {}
});

    // Click-path helper: robust even if the UI re-renders during the click
    function eventPathHas(e, selector) {
        const path = (typeof e.composedPath === 'function') ? e.composedPath() : [];
        return path.some(node => node instanceof Element && node.matches(selector));
    }

    // Close non-pinned control panels on outside click (robust)
    document.addEventListener('click', e => {
        if (eventPathHas(e, '.control-panel, .btn, .dropdown')) return;
        document.querySelectorAll('.control-panel.open').forEach(p => {
            if (!pinnedPanels.has(p.id)) p.classList.remove('open');
        });
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }, true);

    // Close non-docked memo/outline/structure/character/world/search on outside click (robust)
    document.addEventListener('click', e => {
        // パネル操作中（タブクリック等）に誤って閉じないようにする
        if (window.memoInteracting || window.outlineInteracting || window.structureInteracting || window.characterInteracting || window.worldInteracting) return;

        // モーダルやダイアログ、コンテキストメニュー、色選択が開いている場合は閉じない
        if (eventPathHas(e, '.modal-overlay, .save-dialog-overlay, .import-dialog-overlay')) return;
        if (eventPathHas(e, '#structure-edit-modal, #character-edit-modal, #world-edit-modal')) return;
        if (eventPathHas(e, '#structure-context-menu, #character-context-menu, #world-context-menu')) return;
        if (eventPathHas(e, '#structure-color-popup, #character-color-popup, #world-color-popup')) return;
        if (eventPathHas(e, '.structure-link-popup, .tag-suggestions, .structure-tag-suggestions')) return;

        // パネル本体・トグルボタン・リサイズをクリックした場合は閉じない
        if (eventPathHas(e, '#memo-panel, #outline-panel, #structure-panel, #character-panel, #world-panel, #search-panel')) return;
        if (eventPathHas(e, '#btn-toggle-memo, #btn-toggle-outline, #btn-toggle-structure, #btn-toggle-character, #btn-toggle-world, #btn-toggle-search, #btn-toggle-terms')) return;
        if (eventPathHas(e, '#resizer-memo, #resizer-outline, #resizer-structure, #resizer-character, #resizer-world, #resizer-search, #resizer-terms')) return;

        const mainContainer = document.getElementById('main-container');
        if (!mainContainer.classList.contains('memo-docked')) {
            document.getElementById('memo-panel')?.classList.remove('open');
        }
        if (!mainContainer.classList.contains('outline-docked')) {
            document.getElementById('outline-panel')?.classList.remove('open');
        }
        if (!mainContainer.classList.contains('structure-docked')) {
            document.getElementById('structure-panel')?.classList.remove('open');
        }
        if (!mainContainer.classList.contains('character-docked')) {
            document.getElementById('character-panel')?.classList.remove('open');
        }
        if (!mainContainer.classList.contains('world-docked')) {
            document.getElementById('world-panel')?.classList.remove('open');
        }
        if (!mainContainer.classList.contains('search-docked')) {
            document.getElementById('search-panel')?.classList.remove('open');
        }

        updatePanelButtonStates();
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
        if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
        if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
    }, true);

    function hidePane(t) {
        if (t === 'input') {
            document.getElementById('check-show-input').checked = false;
            document.getElementById('pane-input').classList.add('hidden');
        } else if (t === 'preview') {
            document.getElementById('check-show-preview').checked = false;
            document.getElementById('pane-preview').classList.add('hidden');
        }
        adjustPaneWidthsOnVisibility();
    }

    function adjustPaneWidthsOnVisibility() {
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');
        if (document.body.classList.contains('scroll-mode')) {
            inputPane.style.flex = '1 1 auto';
            previewPane.style.flex = '1 1 auto';
            inputPane.style.width = '100%';
            previewPane.style.width = '100%';
if (typeof adjustPaneHeightsOnVisibility === 'function') {
    adjustPaneHeightsOnVisibility();
}

            return;
        }
        const inputHidden = inputPane.classList.contains('hidden');
        const previewHidden = previewPane.classList.contains('hidden');
        if (inputHidden && !previewHidden) {
            previewPane.style.flex = '1 1 auto';
            previewPane.style.width = '100%';
        } else if (!inputHidden && previewHidden) {
            inputPane.style.flex = '1 1 auto';
            inputPane.style.width = '100%';
        } else if (!inputHidden && !previewHidden) {
            const savedInput = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.input)) || parseInt(document.getElementById('st-pane-input-width').value) || 520;
            const savedPreview = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.preview)) || parseInt(document.getElementById('st-pane-preview-width').value) || 520;
            inputPane.style.flex = `1 1 ${savedInput}px`;
            previewPane.style.flex = `1 1 ${savedPreview}px`;
            inputPane.style.width = `${savedInput}px`;
            previewPane.style.width = `${savedPreview}px`;
        }
    }

    function adjustPaneHeightsOnVisibility() {
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');
        const inputHeightEl = document.getElementById('st-pane-input-height');
        const previewHeightEl = document.getElementById('st-pane-preview-height');

        // 必要な要素が無いなら何もしない（落ちないように）
        if (!inputPane || !previewPane || !inputHeightEl || !previewHeightEl) return;

        if (!document.body.classList.contains('scroll-mode')) {
            inputPane.style.height = '';
            previewPane.style.height = '';
            return;
        }

        const inputHidden = inputPane.classList.contains('hidden');
        const previewHidden = previewPane.classList.contains('hidden');

        const inputHeight =
            parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.input), 10) ||
            parseInt(inputHeightEl.value, 10) ||
            520;

        const previewHeight =
            parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.preview), 10) ||
            parseInt(previewHeightEl.value, 10) ||
            520;

        const combinedHeight = inputHeight + previewHeight;

        if (inputHidden && !previewHidden) {
            previewPane.style.height = `${combinedHeight}px`;
        } else if (!inputHidden && previewHidden) {
            inputPane.style.height = `${combinedHeight}px`;
        } else {
            inputPane.style.height = `${inputHeight}px`;
            previewPane.style.height = `${previewHeight}px`;
        }
    }
    function toggleDropdown(id) { document.getElementById(id).classList.toggle('show'); }
    document.addEventListener('click', e => { if (!e.target.closest('.dropdown')) document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); });

    let focusExitHintTimer = null;
    function toggleFocusMode() {
        document.body.classList.toggle('focus-mode');
        document.getElementById('btn-focus').classList.toggle('active');
        const hint = document.querySelector('.focus-exit-hint');
        if (document.body.classList.contains('focus-mode')) {
            inputArea.focus();
            // Show hint and fade out after 5 seconds
            if (hint) {
                hint.classList.remove('fade-out');
                if (focusExitHintTimer) clearTimeout(focusExitHintTimer);
                focusExitHintTimer = setTimeout(() => {
                    hint.classList.add('fade-out');
                }, 5000);
            }
        } else {
            // Clear timer and reset hint when exiting focus mode
            if (focusExitHintTimer) {
                clearTimeout(focusExitHintTimer);
                focusExitHintTimer = null;
            }
            if (hint) hint.classList.remove('fade-out');
        }
    }

    inputArea.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
            const p = inputArea.selectionStart, t = inputArea.value, ls = t.lastIndexOf('\n', p - 1) + 1, cl = t.substring(ls, p);
            if (cl.startsWith('　')) { e.preventDefault(); const b = t.substring(0, p), a = t.substring(inputArea.selectionEnd); inputArea.value = b + '\n　' + a; const np = p + 2; inputArea.setSelectionRange(np, np); updateInputStats(); if (settingsCache.typewriterMode) setTimeout(() => scrollToCursorPosition(np), 10); }
        }
    });
    inputArea.addEventListener('input', () => { lastInputTime = Date.now(); updateInputStats(); if (settingsCache.typewriterMode) scrollToCursorPosition(inputArea.selectionStart); });

    function insertText(t, o = 0) { const s = inputArea.selectionStart, e = inputArea.selectionEnd, b = inputArea.value.substring(0, s), a = inputArea.value.substring(e); inputArea.value = b + t + a; const np = s + t.length - o; inputArea.setSelectionRange(np, np); inputArea.focus(); updateInputStats(); document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); }
    function insertRubyToSelection() { const s = inputArea.selectionStart, e = inputArea.selectionEnd; if (s === e) { alert('ルビを付けたい文字を選択してください。'); return; } const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e), rt = `｜${st}《》`; inputArea.value = b + rt + a; inputArea.setSelectionRange(s + st.length + 2, s + st.length + 2); inputArea.focus(); updateInputStats(); document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); }
    function insertBoutenToSelection() { const s = inputArea.selectionStart, e = inputArea.selectionEnd; if (s === e) { alert('傍点を付けたい文字を選択してください。'); return; } const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e), bt = `《《${st}》》`; inputArea.value = b + bt + a; inputArea.setSelectionRange(s + bt.length, s + bt.length); inputArea.focus(); updateInputStats(); document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); }
    function quickWrapSelection(left, right) {
        const s = inputArea.selectionStart, e = inputArea.selectionEnd;
        if (s === e) { alert('範囲を選択してください。'); return; }
        const st = inputArea.value.substring(s, e);
        const b = inputArea.value.substring(0, s);
        const a = inputArea.value.substring(e);
        const wrapped = `${left}${st}${right}`;
        inputArea.value = b + wrapped + a;
        inputArea.setSelectionRange(s + wrapped.length, s + wrapped.length);
        inputArea.focus();
        updateInputStats();
        hideQuickInsertPopup();
    }

    function scrollToCursorPosition(idx) {
        const t = inputArea.value, v = document.getElementById('st-in-v').checked, cs = window.getComputedStyle(inputArea);
        inputMirror.style.fontSize = cs.fontSize; inputMirror.style.lineHeight = cs.lineHeight; inputMirror.style.fontFamily = cs.fontFamily; inputMirror.style.width = inputArea.clientWidth + 'px'; inputMirror.style.height = inputArea.clientHeight + 'px';
        const tc = t.substring(0, idx), m = document.createElement('span'); m.textContent = '|'; inputMirror.innerHTML = ''; inputMirror.appendChild(document.createTextNode(tc)); inputMirror.appendChild(m);
        const mr = m.getBoundingClientRect(), mir = inputMirror.getBoundingClientRect(), mot = mr.top - mir.top + inputMirror.scrollTop, mol = mr.left - mir.left + inputMirror.scrollLeft;
        if (v) inputArea.scrollLeft = mol - (inputArea.clientWidth / 2); else inputArea.scrollTop = mot - (inputArea.clientHeight / 2);
    }


    function getPreviewLineStartRect(lineNum) {
        const brs = previewContent.querySelectorAll('br');
        const range = document.createRange();
        if (lineNum <= 0) {
            if (previewContent.firstChild) {
                range.setStart(previewContent.firstChild, 0);
                range.setEnd(previewContent.firstChild, 0);
            } else {
                return previewContent.getBoundingClientRect();
            }
        } else {
            const br = brs[Math.min(lineNum - 1, brs.length - 1)];
            if (!br) return null;
            range.setStartAfter(br);
            range.setEndAfter(br);
        }
        const rect = range.getClientRects()[0];
        return rect || range.getBoundingClientRect();
    }
    function showPreviewSyncIndicator(targetRect) {
        const indicator = document.getElementById('preview-sync-indicator');
        if (!indicator || !targetRect) return;
        const scrollRect = previewScroll.getBoundingClientRect();
        const offsetTop = targetRect.top - scrollRect.top + previewScroll.scrollTop;
        const offsetLeft = targetRect.left - scrollRect.left + previewScroll.scrollLeft;
        const isVertical = previewScroll.classList.contains('vertical-mode');
        if (isVertical) {
            indicator.textContent = '←';
            indicator.style.left = `${Math.max(8, offsetLeft - 20)}px`;
            indicator.style.top = `${Math.max(8, offsetTop - 4)}px`;
        } else {
            indicator.textContent = '↓';
            indicator.style.left = `${Math.max(8, offsetLeft - 4)}px`;
            indicator.style.top = `${Math.max(8, offsetTop - 24)}px`;
        }
        indicator.style.display = 'block';
        clearTimeout(showPreviewSyncIndicator._timer);
        showPreviewSyncIndicator._timer = setTimeout(() => {
            indicator.style.display = 'none';
        }, 1400);
    }

    let searchMatches = [], currentMatchIndex = -1;
    let panelZIndexCounter = 210;
    window.__ccFrontPanelId = null;

    function __ccKnownFloatPanels(){
      // Panels that can overlap; used for frontmost recompute fallback
      return [
        'structure-panel','character-panel','world-panel',
        'memo-panel','outline-panel','search-panel',
        'help-bar','settings-bar'
      ];
    }

    function __ccRecomputeFrontPanelId(){
      let bestId = null;
      let bestZ = -Infinity;
      __ccKnownFloatPanels().forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        if (!el.classList.contains('open')) return;
        const zRaw = getComputedStyle(el).zIndex;
        const z = parseInt(zRaw || '0', 10);
        if (!Number.isFinite(z)) return;
        if (z > bestZ) { bestZ = z; bestId = id; }
      });
      window.__ccFrontPanelId = bestId;
      return bestId;
    }

    function __ccSetFrontPanelId(panelId){
      window.__ccFrontPanelId = panelId || null;
      if (typeof window.updatePanelButtonStates === 'function') {
        try { window.updatePanelButtonStates(); } catch(e) {}
      }
      if (typeof window.updateStructureButtonState === 'function') { try{ window.updateStructureButtonState(); }catch(e){} }
      if (typeof window.updateCharacterButtonState === 'function') { try{ window.updateCharacterButtonState(); }catch(e){} }
      if (typeof window.updateWorldButtonState === 'function') { try{ window.updateWorldButtonState(); }catch(e){} }
    }

    function bringPanelToFront(panel, isDocked) {
      if (!panel) return;
      if (isDocked) {
        panel.style.zIndex = '';
        // Docked panels are not treated as "front overlay"
        if (window.__ccFrontPanelId === panel.id) __ccSetFrontPanelId(null);
        return;
      }
      panel.style.zIndex = String(panelZIndexCounter++);
      __ccSetFrontPanelId(panel.id);
    }
    window.bringPanelToFront = bringPanelToFront;

    function __ccIsPanelFront(panelId){
      const el = document.getElementById(panelId);
      if (!el || !el.classList.contains('open')) return false;
      // If front id is stale, recompute once
      if (window.__ccFrontPanelId && window.__ccFrontPanelId !== panelId) {
        const frontEl = document.getElementById(window.__ccFrontPanelId);
        if (!frontEl || !frontEl.classList.contains('open')) __ccRecomputeFrontPanelId();
      } else if (!window.__ccFrontPanelId) {
        __ccRecomputeFrontPanelId();
      }
      return window.__ccFrontPanelId === panelId;
    }
    window.__ccIsPanelFront = __ccIsPanelFront;

    function bindPanelFrontTracking(){
      const dockMap = {
        'structure-panel':'check-structure-dock',
        'character-panel':'check-character-dock',
        'world-panel':'check-world-dock',
        'memo-panel':'check-memo-dock',
        'outline-panel':'check-outline-dock',
        'search-panel':'check-search-dock',
      };
      __ccKnownFloatPanels().forEach(id => {
        const el = document.getElementById(id);
        if (!el) return;
        if (el.__ccFrontBound) return;
        el.__ccFrontBound = true;
        el.addEventListener('pointerdown', () => {
          if (!el.classList.contains('open')) return;
          const chkId = dockMap[id];
          const chk = chkId ? document.getElementById(chkId) : null;
          const isDocked = !!(chk && chk.checked);
          if (window.bringPanelToFront) window.bringPanelToFront(el, isDocked);
        }, { passive:true });
      });
    }
    window.bindPanelFrontTracking = bindPanelFrontTracking;

    // Collapse ALL other panels when a panel gets pinned (📌)
    function __ccCollapseAllOtherPanels(exceptPanelId){
      // NOTE: 旧仕様では他のドック固定まで解除していましたが、
      // 最大固定数（maxPinnedPanels）を導入したため、
      // ここでは「未固定で開いているパネル」だけを閉じます（固定は維持）。
      const defs = [
        { panelId:'structure-panel', chkId:'check-structure-dock', closeDisplayNone:false },
        { panelId:'character-panel', chkId:'check-character-dock', closeDisplayNone:false },
        { panelId:'world-panel',     chkId:'check-world-dock',     closeDisplayNone:false },
        { panelId:'memo-panel',      chkId:'check-memo-dock',      closeDisplayNone:false },
        { panelId:'outline-panel',   chkId:'check-outline-dock',   closeDisplayNone:false },
        { panelId:'search-panel',    chkId:'check-search-dock',    closeDisplayNone:true  },
        // Control panels
        { panelId:'help-bar',        chkId:null,                  closeDisplayNone:false },
        { panelId:'settings-bar',    chkId:null,                  closeDisplayNone:false },
      ];
      defs.forEach(d => {
        if (d.panelId === exceptPanelId) return;
        const p = document.getElementById(d.panelId);
        if (!p) return;

        if (d.chkId) {
          const chk = document.getElementById(d.chkId);
          const docked = !!(chk && chk.checked);
          // 未固定（=ドックOFF）で開いているものだけ閉じる
          if (!docked) {
            p.classList.remove('open');
            p.style.zIndex = '';
            if (d.closeDisplayNone) p.style.display = 'none';
          }
          return;
        }

        // control panels: pinnedPanels なら閉じない
        if ((d.panelId === 'help-bar' || d.panelId === 'settings-bar') && typeof pinnedPanels !== 'undefined') {
          if (pinnedPanels.has(d.panelId)) return;
        }
        p.classList.remove('open');
        p.style.zIndex = '';
      });

      __ccSetFrontPanelId(exceptPanelId);

      try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
      try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}
      try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    }
    window.__ccCollapseAllOtherPanels = __ccCollapseAllOtherPanels;



    // --- Floating panel manager (構成/人物/世界観) ---
    // 仕様：固定(📌)でないパネルは、他パネルを開いたら入れ替え（1つだけ表示）
    //      ただし、背景に開いているパネルをクリックした場合は「前面化」し、
    //      その状態でもう一度クリックした時に「固定」にする。
    window.__ccFloatingPanelActiveId = null;
    function __ccSetActiveFloatingPanel(panelId){
      window.__ccFloatingPanelActiveId = panelId || null;
    }
    function __ccCloseOtherFloatingPanels(exceptPanelId){
      const defs = [
        { panelId: 'structure-panel', dockId: 'check-structure-dock', updateFn: 'updateStructureButtonState' },
        { panelId: 'character-panel', dockId: 'check-character-dock', updateFn: 'updateCharacterButtonState' },
        { panelId: 'world-panel',     dockId: 'check-world-dock',     updateFn: 'updateWorldButtonState' }
      ];
      defs.forEach(d => {
        if (d.panelId === exceptPanelId) return;
        const p = document.getElementById(d.panelId);
        const chk = document.getElementById(d.dockId);
        const isDocked = !!(chk && chk.checked);
        if (p && p.classList.contains('open') && !isDocked) {
          p.classList.remove('open');
          p.style.zIndex = '';
          if (window.__ccFloatingPanelActiveId === d.panelId) window.__ccFloatingPanelActiveId = null;
        }
        if (typeof window[d.updateFn] === 'function') {
          try { window[d.updateFn](); } catch(e) {}
        }
      });
      if (typeof window.updatePanelButtonStates === 'function') {
        try { window.updatePanelButtonStates(); } catch(e) {}
      }
    }
    window.__ccCloseOtherFloatingPanels = __ccCloseOtherFloatingPanels;
    window.__ccSetActiveFloatingPanel = __ccSetActiveFloatingPanel;
    const PANEL_BG_CONFIG = {
      structure: { panelId: 'structure-panel', storageKey: 'cc_panel_bg_structure' },
      character: { panelId: 'character-panel', storageKey: 'cc_panel_bg_character' },
      world: { panelId: 'world-panel', storageKey: 'cc_panel_bg_world' }
    };
    function normalizeColorToHex(color) {
      if (!color) return '#ffffff';
      if (color.startsWith('#')) return color;
      const match = color.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      if (!match) return '#ffffff';
      const toHex = (value) => {
        const hex = Number(value).toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      };
      return `#${toHex(match[1])}${toHex(match[2])}${toHex(match[3])}`;
    }
    function applyPanelBackground(panelType, color) {
      const config = PANEL_BG_CONFIG[panelType];
      if (!config) return;
      const panel = document.getElementById(config.panelId);
      if (!panel) return;
      panel.style.background = color;
      localStorage.setItem(config.storageKey, color);
    }
    function loadPanelBackground(panelType) {
      const config = PANEL_BG_CONFIG[panelType];
      if (!config) return;
      const panel = document.getElementById(config.panelId);
      if (!panel) return;
      const saved = localStorage.getItem(config.storageKey);
      if (saved) panel.style.background = saved;
    }
    function openPanelBackgroundColorPicker(panelType) {
      const config = PANEL_BG_CONFIG[panelType];
      if (!config) return;
      const panel = document.getElementById(config.panelId);
      if (!panel) return;
      let picker = document.getElementById('panel-bg-color-popup');
      if (!picker) {
        picker = document.createElement('div');
        picker.id = 'panel-bg-color-popup';
        picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
        document.body.appendChild(picker);
      }
      const current = normalizeColorToHex(panel.style.backgroundColor || getComputedStyle(panel).backgroundColor);
      picker.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
          <span style="font-weight:bold;">背景色</span>
          <button class="panel-bg-picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
        </div>
        <div style="display:flex; gap:8px; align-items:center; margin-bottom:12px;">
          <input type="color" id="panel-bg-color-input" value="#ffffff" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px; cursor:pointer;">
          <input type="text" id="panel-bg-color-text" value="#ffffff" style="width:90px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end;">
          <button class="btn" id="panel-bg-cancel">キャンセル</button>
          <button class="btn btn-save" id="panel-bg-apply">適用</button>
        </div>
      `;
      picker.style.left = '50%';
      picker.style.top = '50%';
      picker.style.transform = 'translate(-50%, -50%)';
      picker.style.display = 'block';

      const input = picker.querySelector('#panel-bg-color-input');
      const textInput = picker.querySelector('#panel-bg-color-text');
      if (input && textInput) {
        input.addEventListener('input', () => { textInput.value = input.value; });
        textInput.addEventListener('input', () => { if (textInput.value.startsWith('#')) input.value = textInput.value; });
      }
      picker.querySelector('#panel-bg-apply')?.addEventListener('click', () => {
        const value = textInput?.value || current;
        applyPanelBackground(panelType, value);
        picker.style.display = 'none';
      });
      picker.querySelector('#panel-bg-cancel')?.addEventListener('click', () => {
        picker.style.display = 'none';
      });
      picker.querySelector('.panel-bg-picker-close')?.addEventListener('click', () => {
        picker.style.display = 'none';
      });
    }
    window.applyPanelBackground = applyPanelBackground;
    window.loadPanelBackground = loadPanelBackground;
    window.openPanelBackgroundColorPicker = openPanelBackgroundColorPicker;
    function doSearch() { const q = document.getElementById('search-input').value, t = inputArea.value; searchMatches = []; currentMatchIndex = -1; if (!q) { updateSearchInfo(); return; } const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), rx = new RegExp(esc, 'g'); let m; while ((m = rx.exec(t)) !== null) searchMatches.push({ start: m.index, end: m.index + m[0].length }); if (searchMatches.length > 0) { currentMatchIndex = 0; jumpToMatch(); } updateSearchInfo(); }
    function updateSearchInfo() { const i = document.getElementById('search-match-info'); if (searchMatches.length === 0) { i.innerText = '0 / 0'; i.style.color = '#999'; } else { i.innerText = `${currentMatchIndex + 1} / ${searchMatches.length}`; i.style.color = '#15803d'; } }
    function findNext() { if (searchMatches.length === 0) doSearch(); else { currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length; jumpToMatch(); updateSearchInfo(); } }
    function findPrev() { if (searchMatches.length === 0) doSearch(); else { currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length; jumpToMatch(); updateSearchInfo(); } }
    function jumpToMatch() { const m = searchMatches[currentMatchIndex]; if (!m) return; inputArea.focus(); inputArea.setSelectionRange(m.start, m.end); scrollToCursorPosition(m.start); updateCursorLineDisplay(); }
    function replaceOne() { if (currentMatchIndex < 0) findNext(); if (currentMatchIndex < 0) return; const r = document.getElementById('replace-input').value, m = searchMatches[currentMatchIndex]; inputArea.setRangeText(r, m.start, m.end, 'select'); doSearch(); jumpToMatch(); }
    function replaceAll() { const q = document.getElementById('search-input').value, r = document.getElementById('replace-input').value; if (!q) return; inputArea.value = inputArea.value.split(q).join(r); updateInputStats(); }


    // Memo Pane with Tabs
    const MEMO_KEY = 'cc_editor_memo_tabs';
    const memoArea = document.getElementById('memo-area');
    const memoCharCount = document.getElementById('memo-char-count');
    let memoTabs = [{ id: 1, name: 'メモ1', content: '' }];
    let activeMemoTabId = 1;
    let nextMemoTabId = 2;
    let draggingMemoTabId = null;
    window.memoTabs = memoTabs;
    Object.defineProperty(window, 'activeMemoTabId', {
        get: () => activeMemoTabId,
        set: (value) => { activeMemoTabId = value; }
    });
    Object.defineProperty(window, 'nextMemoTabId', {
        get: () => nextMemoTabId,
        set: (value) => { nextMemoTabId = value; }
    });


function toggleMemoPanel() {
    const panel = document.getElementById('memo-panel');
    const checkbox = document.getElementById('check-memo-dock');
    if (!panel || !checkbox) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;
    const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('memo-panel'));

    if (!isOpen) {
      
      panel.classList.add('open');
      
      if (checkbox.checked) { checkbox.checked = false; toggleMemoDock(); }
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      
    } else if (!isDocked) {
      if (!isFront) {
        if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
        if (typeof window.updatePanelButtonStates === 'function') window.updatePanelButtonStates();
        return;
      }
      if (typeof window.__ccRequestDockWithLimit === 'function') { window.__ccRequestDockWithLimit('memo'); } else { checkbox.checked = true; toggleMemoDock(); panel.classList.add('open'); }
} else {
  // docked panel: 浮動がある時は固定維持で浮動だけ畳む。浮動が無い時はリボンで解除できる
  const __ccAnyFloatingOpen = () => {
    const META = [
      ['structure-panel','check-structure-dock'],
      ['world-panel','check-world-dock'],
      ['character-panel','check-character-dock'],
      ['memo-panel','check-memo-dock'],
      ['outline-panel','check-outline-dock'],
      ['search-panel','check-search-dock'],
      ['settings-panel', null],
      ['help-panel', null],
    ];
    return META.some(([pid,cid]) => {
      const p = document.getElementById(pid);
      const c = cid ? document.getElementById(cid) : null;
      const docked = c ? !!c.checked : false;
      return p && p.classList.contains('open') && !docked && pid !== 'memo-panel';
    });
  };
  const hadFloating = __ccAnyFloatingOpen();
  if (hadFloating) {
    if (typeof window.__ccCollapseFloatingPanels === 'function') window.__ccCollapseFloatingPanels();
    if (window.bringPanelToFront) window.bringPanelToFront(panel, true);
    return;
  }
  // 解除（固定OFF）して閉じる
  checkbox.checked = false;
  try { if (typeof window.toggleMemoDock === 'function') window.toggleMemoDock(); else if (typeof toggleMemoDock === 'function') toggleMemoDock(); } catch(e){}
  panel.classList.remove('open');
  panel.style.zIndex = '';
  if (typeof window.updatePanelButtonStates === 'function') window.updatePanelButtonStates();
  return;
}

    const isDockedNow = checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
    try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}
}

let memoFullscreenListenerAttached = false;
function setupMemoFullscreenListener() {
  if (memoFullscreenListenerAttached) return;
  memoFullscreenListenerAttached = true;
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && document.body.classList.contains('memo-fullscreen-mode')) {
      toggleMemoFullscreen();
    }
  });
}

function toggleMemoFullscreen() {
  const panel = document.getElementById('memo-panel');
  if (!panel) return;
  document.body.classList.remove('structure-fullscreen-mode', 'character-fullscreen-mode', 'world-fullscreen-mode');
  if (document.body.classList.contains('memo-fullscreen-mode')) {
    document.body.classList.remove('memo-fullscreen-mode');
    return;
  }
  panel.classList.add('open');
  document.body.classList.add('memo-fullscreen-mode');
}

setupMemoFullscreenListener();



function closeMemoPanel(force = false) {
  console.log('closeMemoPanel called', { force });
  console.trace(); // ←呼び出し元の履歴が出る
  const c = document.getElementById('main-container');
  if (!force && c && c.classList.contains('memo-docked')) return; // ドック中は閉じない

  if (!force && window.memoInteracting) return;

  const panel = document.getElementById('memo-panel');
  if (!panel) return;
  document.body.classList.remove('memo-fullscreen-mode');
  panel.classList.remove('open');

  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
}



function toggleMemoDock() {
  const checkbox = document.getElementById('check-memo-dock');
  const c = document.getElementById('main-container');
  const b = document.getElementById('btn-memo-swap');
  const pinBtn = document.getElementById('btn-memo-pin');
  const panel = document.getElementById('memo-panel');

  if (!checkbox) {
    console.error('check-memo-dock が見つかりません');
    return;
  }
  if (!c) {
    console.error('main-container が見つかりません');
    return;
  }

  const d = checkbox.checked;

  if (d) {
    c.classList.add('memo-docked');
    if (b) b.classList.add('is-active');
  } else {
    c.classList.remove('memo-docked');
    if (b) b.classList.remove('is-active');
    if (panel) panel.style.width = '260px';
  }

  if (pinBtn) pinBtn.classList.toggle('pinned', d);

  if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses();
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
}


    function toggleMemoDockPin() {
    const checkbox = document.getElementById('check-memo-dock');
    const panel = document.getElementById('memo-panel');
    if (!checkbox) return;

    // Pin request
    if (!checkbox.checked) {
      if (typeof window.__ccRequestDockWithLimit === 'function') {
        window.__ccRequestDockWithLimit('memo');
        return;
      }
      checkbox.checked = true;
      toggleMemoDock();
      if (panel) panel.classList.add('open');
      return;
    }

    // Unpin (keep panel open as floating)
    checkbox.checked = false;
    toggleMemoDock();
    if (panel) {
      panel.classList.add('open');
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    }
  }

  function swapMemoSide() {
    if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('memo');
  }


    function renderMemoTabs() {
        const container = document.getElementById('memo-tabs-container');
        if (!container) return;
        container.innerHTML = '';
        memoTabs.forEach(tab => {
            const tabEl = document.createElement('div');
            tabEl.className = 'memo-tab' + (tab.id === activeMemoTabId ? ' active' : '');
            tabEl.draggable = true;
            tabEl.dataset.tabId = tab.id;
            tabEl.innerHTML = `
                <span class="tab-name" ondblclick="startEditMemoTabName(${tab.id})">${escapeHtml(tab.name)}</span>
                ${memoTabs.length > 1 ? `<span class="tab-close" onclick="event.stopPropagation(); deleteMemoTab(${tab.id})">✕</span>` : ''}
            `;
            tabEl.addEventListener('click', ev => { ev.stopPropagation(); switchMemoTab(tab.id); });
            tabEl.addEventListener('dragstart', e => {
                draggingMemoTabId = tab.id;
                tabEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            tabEl.addEventListener('dragend', () => {
                draggingMemoTabId = null;
                tabEl.classList.remove('dragging');
            });
            tabEl.addEventListener('dragover', e => {
                if (draggingMemoTabId === null || draggingMemoTabId === tab.id) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            tabEl.addEventListener('drop', e => {
                e.preventDefault();
                if (draggingMemoTabId === null || draggingMemoTabId === tab.id) return;
                const fromIndex = memoTabs.findIndex(t => t.id === draggingMemoTabId);
                const toIndex = memoTabs.findIndex(t => t.id === tab.id);
                if (fromIndex === -1 || toIndex === -1) return;
                const [moved] = memoTabs.splice(fromIndex, 1);
                memoTabs.splice(toIndex, 0, moved);
                renderMemoTabs();
                saveMemoTabs();
            });
            container.appendChild(tabEl);
        });
        const addBtn = document.createElement('button');
        addBtn.className = 'memo-tab memo-tab-add';
        addBtn.textContent = '＋';
        addBtn.title = '新しいメモタブを追加';
        addBtn.onclick = ev => { if (ev) ev.stopPropagation(); addNewMemoTab(); };
        container.appendChild(addBtn);
        updateTabScrollButtonsFor('memo-tabs-container');
    }

    function switchMemoTab(id) {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        activeMemoTabId = id;
        const newTab = memoTabs.find(t => t.id === id);
        memoArea.value = newTab ? newTab.content : '';
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    }

    function addNewMemoTab() {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        memoTabs.push({ id: nextMemoTabId, name: `メモ${nextMemoTabId}`, content: '' });
        activeMemoTabId = nextMemoTabId;
        nextMemoTabId++;
        memoArea.value = '';
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    }

    function deleteMemoTab(id) {
        if (memoTabs.length <= 1) return;
        if (!confirm('このメモタブを削除しますか？')) return;
        const idx = memoTabs.findIndex(t => t.id === id);
        memoTabs.splice(idx, 1);
        if (activeMemoTabId === id) {
            activeMemoTabId = memoTabs[Math.max(0, idx - 1)].id;
            memoArea.value = memoTabs.find(t => t.id === activeMemoTabId).content;
        }
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    }

    function startEditMemoTabName(id) {
        const tab = memoTabs.find(t => t.id === id);
        const newName = prompt('タブ名を入力:', tab.name);
        if (newName && newName.trim()) {
            tab.name = newName.trim();
            renderMemoTabs();
            saveMemoTabs();
        }
    }

    function loadMemoTabs() {
        const saved = localStorage.getItem(MEMO_KEY);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.tabs && data.tabs.length > 0) {
                    memoTabs = data.tabs;
                    window.memoTabs = memoTabs;
                    activeMemoTabId = data.activeId || memoTabs[0].id;
                    nextMemoTabId = data.nextId || Math.max(...memoTabs.map(t => t.id)) + 1;
                    const activeTab = memoTabs.find(t => t.id === activeMemoTabId);
                    memoArea.value = activeTab ? activeTab.content : '';
                }
            } catch (e) { /* use defaults */ }
        }
        renderMemoTabs();
        updateMemoCharCount();
    }

    function saveMemoTabs() {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        localStorage.setItem(MEMO_KEY, JSON.stringify({
            tabs: memoTabs,
            activeId: activeMemoTabId,
            nextId: nextMemoTabId
        }));
    }

    function showMemoSaveDialog() {
        document.getElementById('memo-save-dialog').style.display = 'flex';
    }
    function closeMemoSaveDialog() {
        document.getElementById('memo-save-dialog').style.display = 'none';
    }
    async function executeMemoSave() {
        const scope = document.querySelector('input[name="memo-save-scope"]:checked')?.value || 'current';
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        let content;
        if (scope === 'all') {
            content = memoTabs.map(t => `◇ ${t.name}\n${t.content}`).join('\n\n');
        } else {
            content = currentTab ? currentTab.content : '';
        }
        const blob = new Blob([content], { type: 'text/plain' });
        const n = new Date();
        const name = `memo_${n.getFullYear()}${(n.getMonth()+1).toString().padStart(2,'0')}${n.getDate().toString().padStart(2,'0')}.txt`;
        const result = await saveBlobWithPicker(blob, name, [{ description: 'Text', accept: { 'text/plain': ['.txt'] } }], lastMemoSaveHandle);
        if (result.handle) lastMemoSaveHandle = result.handle;
        if (!result.handled) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        closeMemoSaveDialog();
    }

    function loadMemoFile(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            const content = e.target.result;
            const parsedTabs = parseStructuredTabs(content, '◇');
            if (parsedTabs.length > 0) {
                parsedTabs.forEach(tab => {
                    const name = tab.name || `メモ${nextMemoTabId}`;
                    memoTabs.push({ id: nextMemoTabId++, name, content: tab.content });
                });
                activeMemoTabId = memoTabs[memoTabs.length - parsedTabs.length].id;
                memoArea.value = memoTabs.find(t => t.id === activeMemoTabId)?.content || '';
            } else {
                const newId = nextMemoTabId++;
                memoTabs.push({ id: newId, name: `メモ${newId}`, content });
                activeMemoTabId = newId;
                memoArea.value = content;
            }
            renderMemoTabs();
            updateMemoCharCount();
            saveMemoTabs();
        };
        reader.readAsText(file);
        input.value = '';
    }

    memoArea.addEventListener('input', () => {
        updateMemoCharCount();
        saveMemoTabs();
    });

    // メモデータ取得・設定関数（インポート/エクスポート用）
    window.getMemoTabsData = function() {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        return memoTabs.slice();
    };

    window.setMemoTabsData = function(data) {
        memoTabs.length = 0;
        data.forEach(tab => memoTabs.push({
            id: tab.id,
            name: tab.name || tab.title || 'メモ',
            content: tab.content || ''
        }));
        window.memoTabs = memoTabs;
        if (memoTabs.length > 0) {
            activeMemoTabId = memoTabs[0].id;
            nextMemoTabId = Math.max(...memoTabs.map(t => typeof t.id === 'number' ? t.id : 0), 0) + 1;
            memoArea.value = memoTabs[0].content || '';
        }
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    };

    window.appendMemoTabsData = function(data) {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        data.forEach(tab => {
            const newId = nextMemoTabId++;
            memoTabs.push({
                id: newId,
                name: tab.name || tab.title || `メモ${newId}`,
                content: tab.content || ''
            });
        });
        window.memoTabs = memoTabs;
        renderMemoTabs();
        saveMemoTabs();
    };

    let outlineData = [];
function toggleOutlinePanel() {
    const panel = document.getElementById('outline-panel');
    const checkbox = document.getElementById('check-outline-dock');
    if (!panel || !checkbox) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;
    const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('outline-panel'));

    if (!isOpen) {
      try{ if (typeof generateOutline==='function') generateOutline(); }catch(e){}
      try{ if (typeof switchOutlineTabDirect==='function') switchOutlineTabDirect('outline'); }catch(e){}
      panel.classList.add('open');
      
      if (checkbox.checked) { checkbox.checked = false; toggleOutlineDock(); }
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      
    } else if (!isDocked) {
      if (!isFront) {
        if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
        if (typeof window.updatePanelButtonStates === 'function') window.updatePanelButtonStates();
        return;
      }
      if (typeof window.__ccRequestDockWithLimit === 'function') { window.__ccRequestDockWithLimit('outline'); } else { checkbox.checked = true; toggleOutlineDock(); panel.classList.add('open'); }
} else {
  // docked panel: 浮動がある時は固定維持で浮動だけ畳む。浮動が無い時はリボンで解除できる
  const __ccAnyFloatingOpen = () => {
    const META = [
      ['structure-panel','check-structure-dock'],
      ['world-panel','check-world-dock'],
      ['character-panel','check-character-dock'],
      ['memo-panel','check-memo-dock'],
      ['outline-panel','check-outline-dock'],
      ['search-panel','check-search-dock'],
      ['settings-panel', null],
      ['help-panel', null],
    ];
    return META.some(([pid,cid]) => {
      const p = document.getElementById(pid);
      const c = cid ? document.getElementById(cid) : null;
      const docked = c ? !!c.checked : false;
      return p && p.classList.contains('open') && !docked && pid !== 'outline-panel';
    });
  };
  const hadFloating = __ccAnyFloatingOpen();
  if (hadFloating) {
    if (typeof window.__ccCollapseFloatingPanels === 'function') window.__ccCollapseFloatingPanels();
    if (window.bringPanelToFront) window.bringPanelToFront(panel, true);
    return;
  }
  // 解除（固定OFF）して閉じる
  checkbox.checked = false;
  try { if (typeof window.toggleOutlineDock === 'function') window.toggleOutlineDock(); else if (typeof toggleOutlineDock === 'function') toggleOutlineDock(); } catch(e){}
  panel.classList.remove('open');
  panel.style.zIndex = '';
  if (typeof window.updatePanelButtonStates === 'function') window.updatePanelButtonStates();
  return;
}

    const isDockedNow = checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
    try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}
}

function closeOutlinePanel() {
    const panel = document.getElementById('outline-panel');
    panel.classList.remove('open');
    applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
    updatePanelButtonStates();
    updateDockSplitState();
}

    function toggleOutlineDock() {
        const d = document.getElementById('check-outline-dock').checked;
        const c = document.getElementById('main-container');
        const b = document.getElementById('btn-outline-swap');
        const pinBtn = document.getElementById('btn-outline-pin');
        if (d) {
            c.classList.add('outline-docked');
            b.classList.add('is-active');
        } else {
            c.classList.remove('outline-docked');
            b.classList.remove('is-active');
            document.getElementById('outline-panel').style.width = '260px';
        }
        if (pinBtn) pinBtn.classList.toggle('pinned', d);
        applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
        updatePanelButtonStates();
        updateDockSplitState();
    }

    function toggleOutlineDockPin() {
    const checkbox = document.getElementById('check-outline-dock');
    const panel = document.getElementById('outline-panel');
    if (!checkbox) return;

    if (!checkbox.checked) {
      if (typeof window.__ccRequestDockWithLimit === 'function') {
        window.__ccRequestDockWithLimit('outline');
        return;
      }
      checkbox.checked = true;
      toggleOutlineDock();
      if (panel) panel.classList.add('open');
      return;
    }

    checkbox.checked = false;
    toggleOutlineDock();
    if (panel) {
      panel.classList.add('open');
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    }
}

    function swapOutlineSide() {
        if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('outline');
        if (typeof updateDockSplitState === 'function') updateDockSplitState();
    }

    function switchOutlineTab(tab) {
        document.querySelectorAll('#outline-panel .outline-tabs-inner .memo-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.outline-tab-content').forEach(c => c.classList.remove('active'));
        const tabEl = document.querySelector(`#outline-panel .outline-tabs-inner .memo-tab[onclick*="${tab}"]`);
        if (tabEl) tabEl.classList.add('active');
        const content = document.getElementById(`outline-tab-${tab}`);
        if (content) content.classList.add('active');
    }
    
    function generateOutline() {
        const l = document.getElementById('outline-list');
        const sm = document.getElementById('outline-summary');
        l.innerHTML = '';
        outlineData = [];

        const rx = /^([#＃■□▲△▼▽◆◇○◎●§・※☆★]+|第[一二三四五六七八九十百千\d]+[章話節部編]|[①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳]+|[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+)/;
        let foundAny = false;

        function outlineItemsForTab(tab) {
            const t = (tab && typeof tab.content === 'string') ? tab.content : '';
            const tabName = (tab && typeof tab.name === 'string') ? tab.name.trim() : '';
            const tabId = tab ? tab.id : null;
            const ls = t.split('\n');

            const items = [];

            // Lv1: タブ名（タブ同士は同じレベル）
            if (tabName) {
                items.push({
                    text: tabName,
                    level: 1,
                    pos: 0,
                    length: 0,
                    collapsed: false,
                    index: 0,
                    directCharCount: 0,
                    charCount: 0,
                    tabId,
                    tabName,
                    isTabTitle: true
                });
            }

            let cl = 1; // Lv1はタブ名に予約
            const lm = new Map();
            let ca = 0;
            let hasHeading = false;

            ls.forEach(line => {
                const c = line.trim();
                const cp = ca;
                ca += line.length + 1;
                const m = c.match(rx);
                if (!m) return;

                hasHeading = true;
                let sk = m[1];
                if (sk.match(/^第.+[章話節部編]$/)) sk = '___CHAPTER___';
                else if (sk.match(/^[①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳]+$/)) sk = '___CIRCLED___';
                else if (sk.match(/^[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+$/)) sk = '___ROMAN___';

                if (!lm.has(sk)) {
                    cl++;
                    lm.set(sk, cl);
                }

                items.push({
                    text: c,
                    level: lm.get(sk),
                    pos: cp,
                    length: c.length,
                    collapsed: false,
                    index: items.length,
                    directCharCount: 0,
                    charCount: 0,
                    tabId
                });
            });

            if (tabName || hasHeading) foundAny = true;

            // directCharCount（同一タブ内）
            const tl = t.length;
            for (let i = 0; i < items.length; i++) {
                if (items[i].isTabTitle) continue;
                const sp = items[i].pos;
                const ep = (i + 1 < items.length) ? items[i + 1].pos : tl;
                items[i].directCharCount = t.substring(sp, ep).replace(/[\n\s　]/g, '').length;
            }

            const tabTitleItem = items.find(it => it.isTabTitle);
            if (tabTitleItem) {
                tabTitleItem.directCharCount = t.replace(/[\n\s　]/g, '').length;
            }

            // charCount（同一タブ内で集計）
            for (let i = items.length - 1; i >= 0; i--) {
                if (items[i].isTabTitle) {
                    items[i].charCount = items[i].directCharCount;
                    continue;
                }
                const clv = items[i].level;
                let tc = items[i].directCharCount;
                for (let j = i + 1; j < items.length; j++) {
                    if (items[j].level <= clv) break;
                    if (items[j].level === clv + 1) tc += items[j].charCount;
                    else {
                        let hp = false;
                        for (let k = j - 1; k > i; k--) {
                            if (items[k].level === items[j].level - 1) { hp = true; break; }
                            if (items[k].level <= clv) break;
                        }
                        if (!hp) tc += items[j].charCount;
                    }
                }
                items[i].charCount = tc;
            }

            return items;
        }

        // 全タブから目次生成（タブ名が最上位）
        inputTabs.forEach(tab => {
            outlineData.push(...outlineItemsForTab(tab));
        });

        // Lv別集計（全タブ合算）
        const lc = new Map();
        outlineData.forEach(it => {
            if (!lc.has(it.level)) lc.set(it.level, 0);
            lc.set(it.level, lc.get(it.level) + (it.directCharCount || 0));
        });

        if (foundAny) {
            let st = '文字数: ';
            Array.from(lc.keys()).sort((a, b) => a - b).forEach((lv, i, a) => {
                st += `Lv${lv}: ${lc.get(lv).toLocaleString()}`;
                if (i < a.length - 1) st += ' / ';
            });
            sm.innerHTML = st;
            sm.style.display = 'block';
        } else {
            sm.style.display = 'none';
        }

        renderOutline();
        if (!foundAny) l.innerHTML = '<div class="outline-empty">見出しが見つかりません。</div>';
    }

    function renderOutline() {
        const l = document.getElementById('outline-list'); l.innerHTML = '';
        outlineData.forEach((it, idx) => {
            const d = document.createElement('div'); d.className = `outline-item outline-level-${Math.min(it.level, 3)}`;
            const hc = outlineData.some((x, i) => i > idx && x.level > it.level && !outlineData.slice(idx + 1, i).some(m => m.level <= it.level));
            const tg = document.createElement('span'); tg.className = 'outline-toggle'; if (hc) { tg.textContent = it.collapsed ? '▶' : '▼'; tg.onclick = e => { e.stopPropagation(); toggleOutlineItem(idx); }; } d.appendChild(tg);
            const ts = document.createElement('span'); ts.className = 'outline-text'; ts.textContent = it.text; d.appendChild(ts);
            const cc = document.createElement('span'); cc.className = 'outline-char-count'; cc.textContent = it.charCount.toLocaleString(); d.appendChild(cc);
            let hd = false; for (let i = 0; i < idx; i++) { if (outlineData[i].collapsed && outlineData[i].level < it.level) { let ir = true; for (let j = i + 1; j < idx; j++) { if (outlineData[j].level <= outlineData[i].level) { ir = false; break; } } if (ir) { hd = true; break; } } } if (hd) d.classList.add('outline-hidden');
            d.onclick = e => { if (e.target.classList.contains('outline-toggle')) return; if (it.tabId && it.tabId !== activeTabId) switchTab(it.tabId); inputArea.focus(); inputArea.setSelectionRange(it.pos, it.pos + it.length); setTimeout(() => scrollToCursorPosition(it.pos), 100); updateCursorLineDisplay(); if (window.innerWidth < 768 && !document.getElementById('check-outline-dock').checked) closeOutlinePanel(); };
            l.appendChild(d);
        });
    }
    function toggleOutlineItem(i) { outlineData[i].collapsed = !outlineData[i].collapsed; renderOutline(); }
    function expandAllOutline() { outlineData.forEach(it => it.collapsed = false); renderOutline(); }
    function collapseAllOutline() { outlineData.forEach(it => it.collapsed = true); renderOutline(); }

    function toggleLayoutAxis() {
        if (layoutAxis === 'row') {
            layoutAxis = 'column';
        } else {
            layoutAxis = 'row';
        }
        layoutReversed = false;
        applyLayoutState();
        applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
if (typeof applyPaneHeightSettings === 'function') {
    applyPaneHeightSettings();
}
        saveLayoutSettings();
    }
    function toggleLayoutOrder() {
        layoutReversed = !layoutReversed;
        applyLayoutState();
        saveLayoutSettings();
    }

    function showJumpDialog() { document.getElementById('jump-dialog').classList.add('show'); document.getElementById('jump-line-input').value = ''; document.getElementById('jump-line-input').focus(); }
    function closeJumpDialog() { document.getElementById('jump-dialog').classList.remove('show'); }
    function executeJump() { const ln = parseInt(document.getElementById('jump-line-input').value); if (isNaN(ln) || ln < 1) { alert('有効な行番号を入力してください。'); return; } const ls = inputArea.value.split('\n'); if (ln > ls.length) { alert(`最大行数は ${ls.length} 行です。`); return; } let p = 0; for (let i = 0; i < ln - 1; i++) p += ls[i].length + 1; inputArea.focus(); inputArea.setSelectionRange(p, p); setTimeout(() => scrollToCursorPosition(p), 100); updateCursorLineDisplay(); closeJumpDialog(); }
    document.getElementById('jump-line-input').addEventListener('keydown', e => { if (e.key === 'Enter') executeJump(); if (e.key === 'Escape') closeJumpDialog(); });

    let currentHeatmapType = 'paragraph';
    function showAnalysis() {
        const t = inputArea.value, tc = t.replace(/[\n\s　]/g, '').length;
        const kc = (t.match(/[一-龠々〆ヵヶ]/g) || []).length, hc = (t.match(/[ぁ-ん]/g) || []).length, ktc = (t.match(/[ァ-ヴー]/g) || []).length, oc = tc - kc - hc - ktc;
        const kp = tc > 0 ? (kc / tc * 100).toFixed(1) : 0, hp = tc > 0 ? (hc / tc * 100).toFixed(1) : 0, ktp = tc > 0 ? (ktc / tc * 100).toFixed(1) : 0, op = tc > 0 ? (oc / tc * 100).toFixed(1) : 0;
        const ss = t.split(/。|！|？|\!|\?/).filter(s => s.trim().length > 0), sl = ss.map(s => s.replace(/[\n\s　]/g, '').length);
        const al = sl.length > 0 ? Math.round(sl.reduce((a, b) => a + b, 0) / sl.length) : 0, ml = sl.length > 0 ? Math.max(...sl) : 0, ls = sl.filter(l => l > 100).length;
        const dm = t.match(/「[^」]*」/g) || [], dc = dm.join('').replace(/[「」\n\s　]/g, '').length, dp = tc > 0 ? (dc / tc * 100).toFixed(1) : 0, np = (100 - parseFloat(dp)).toFixed(1);
        const ct = t.replace(/[\n\s　「」『』（）()、。！？\!\?…―─]/g, ''), fm = new Map();
        for (let len = 2; len <= 4; len++) { for (let i = 0; i <= ct.length - len; i++) { const w = ct.substring(i, i + len); if (!/^[ぁ-んァ-ヴー一-龠々〆ヵヶ]+$/.test(w)) continue; fm.set(w, (fm.get(w) || 0) + 1); } }
        const fw = Array.from(fm.entries()).filter(([w, c]) => c >= 3).sort((a, b) => b[1] - a[1]).slice(0, 15);
        document.getElementById('analysis-results').innerHTML = `
            <div class="analysis-section"><h4>📊 文字種別</h4>
                <div class="analysis-row"><span>漢字</span><span>${kc.toLocaleString()}字 (${kp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${kp}%; background:#dc2626;"></div></div>
                <div class="analysis-row"><span>ひらがな</span><span>${hc.toLocaleString()}字 (${hp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${hp}%; background:#2563eb;"></div></div>
                <div class="analysis-row"><span>カタカナ</span><span>${ktc.toLocaleString()}字 (${ktp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${ktp}%; background:#16a34a;"></div></div>
                <div class="analysis-row"><span>その他</span><span>${oc.toLocaleString()}字 (${op}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${op}%; background:#9ca3af;"></div></div>
            </div>
            <div class="analysis-section"><h4>📝 文長分析</h4>
                <div class="analysis-row"><span>文の数</span><span>${ss.length}文</span></div>
                <div class="analysis-row"><span>平均文長</span><span>${al}字</span></div>
                <div class="analysis-row"><span>最長文</span><span>${ml}字</span></div>
                ${ls > 0 ? `<div class="warning-text">⚠️ 100字超の長い文が ${ls} 箇所</div>` : '<div style="color:#16a34a;">✓ 極端に長い文はありません</div>'}
            </div>
            <div class="analysis-section"><h4>💬 会話文比率</h4>
                <div class="analysis-row"><span>会話文</span><span>${dc.toLocaleString()}字 (${dp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${dp}%; background:#f97316;"></div></div>
                <div class="analysis-row"><span>地の文</span><span>${(tc - dc).toLocaleString()}字 (${np}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${np}%; background:#8b5cf6;"></div></div>
            </div>
            <div class="analysis-section"><h4>🔤 頻出語 TOP15</h4>
                ${fw.length > 0 ? `<div class="freq-list">${fw.map(([w, c]) => `<span class="freq-item">${w} (${c})</span>`).join('')}</div>` : '<div class="outline-empty">十分なデータがありません</div>'}
            </div>
            <div class="analysis-section"><h4>🗺️ ヒートマップ分析</h4>
                <div class="heatmap-tabs">
                    <span class="heatmap-tab ${currentHeatmapType === 'paragraph' ? 'active' : ''}" onclick="switchHeatmap('paragraph')">段落長</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'kanji' ? 'active' : ''}" onclick="switchHeatmap('kanji')">漢字密度</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'char' ? 'active' : ''}" onclick="switchHeatmap('char')">文字頻度</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'ending' ? 'active' : ''}" onclick="switchHeatmap('ending')">文末表現</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'punct' ? 'active' : ''}" onclick="switchHeatmap('punct')">句読点密度</span>
                </div>
                <div id="heatmap-display"></div>
            </div>`;
        renderHeatmap();
        document.getElementById('analysis-modal').classList.add('show');
    }
    function switchHeatmap(type) { currentHeatmapType = type; document.querySelectorAll('.heatmap-tab').forEach(t => t.classList.remove('active')); document.querySelector(`.heatmap-tab[onclick*="${type}"]`).classList.add('active'); renderHeatmap(); }
    function getHeatColor(value, type) {
        const colors = { paragraph: ['#dcfce7','#86efac','#22c55e','#16a34a','#15803d'], kanji: ['#fef3c7','#fcd34d','#f59e0b','#d97706','#b45309'], char: ['#dbeafe','#93c5fd','#3b82f6','#2563eb','#1d4ed8'], ending: ['#fce7f3','#f9a8d4','#ec4899','#db2777','#be185d'], punct: ['#f3e8ff','#c4b5fd','#a78bfa','#8b5cf6','#7c3aed'] };
        const idx = Math.min(4, Math.floor(value * 5)); return colors[type][idx];
    }
    function renderHeatmap() {
        const t = inputArea.value, container = document.getElementById('heatmap-display');
        const paragraphs = t.split(/\n\n+/).filter(p => p.trim().length > 0);
        if (paragraphs.length === 0) { container.innerHTML = '<div class="outline-empty">データがありません</div>'; return; }
        let cells = [], legend = '';
        if (currentHeatmapType === 'paragraph') {
            legend = '短い → 長い';
            const lengths = paragraphs.map(p => p.replace(/[\n\s　]/g, '').length);
            const maxLen = Math.max(...lengths, 1);
            cells = lengths.map((len, i) => ({ value: len / maxLen, tooltip: `段落${i+1}: ${len}字` }));
        } else if (currentHeatmapType === 'kanji') {
            legend = '少ない → 多い';
            cells = paragraphs.map((p, i) => { const clean = p.replace(/[\n\s　]/g, ''); const kj = (p.match(/[一-龠々〆ヵヶ]/g) || []).length; const ratio = clean.length > 0 ? kj / clean.length : 0; return { value: ratio, tooltip: `段落${i+1}: ${(ratio*100).toFixed(1)}%` }; });
        } else if (currentHeatmapType === 'char') {
            legend = '低頻度 → 高頻度';
            const allChars = t.replace(/[\n\s　「」『』（）()、。！？\!\?…―─\r]/g, '');
            const charFreq = new Map(); for (const c of allChars) charFreq.set(c, (charFreq.get(c) || 0) + 1);
            const maxFreq = Math.max(...charFreq.values(), 1);
            const blockSize = 50;
            for (let i = 0; i < allChars.length; i += blockSize) {
                const block = allChars.substring(i, i + blockSize);
                let sum = 0; for (const c of block) sum += charFreq.get(c) || 0;
                const avg = sum / block.length / maxFreq;
                cells.push({ value: avg, tooltip: `${i+1}-${Math.min(i+blockSize, allChars.length)}字目` });
            }
        } else if (currentHeatmapType === 'ending') {
            legend = '。多 → 多様';
            const sentences = t.split(/(?<=[。！？\!\?])/).filter(s => s.trim().length > 0);
            const blockSize = 10;
            for (let i = 0; i < sentences.length; i += blockSize) {
                const block = sentences.slice(i, i + blockSize);
                const endings = block.map(s => { const m = s.match(/[。！？\!\?]/); return m ? m[0] : ''; });
                const unique = new Set(endings.filter(e => e)).size;
                const variety = unique / Math.min(block.length, 4);
                cells.push({ value: Math.min(1, variety), tooltip: `文${i+1}-${i+block.length}: ${unique}種類` });
            }
        } else if (currentHeatmapType === 'punct') {
            legend = '少ない → 多い';
            cells = paragraphs.map((p, i) => { const clean = p.replace(/[\n\s　]/g, ''); const puncts = (p.match(/[、。！？\!\?…―─「」『』（）()]/g) || []).length; const ratio = clean.length > 0 ? puncts / clean.length : 0; return { value: Math.min(1, ratio * 5), tooltip: `段落${i+1}: ${puncts}個` }; });
        }
        container.innerHTML = `<div class="heatmap-title"><span>${{paragraph:'段落長さ',kanji:'漢字密度',char:'文字頻度',ending:'文末表現',punct:'句読点密度'}[currentHeatmapType]}</span><span class="heatmap-legend">${legend}</span></div><div class="heatmap-grid">${cells.map(c => `<div class="heatmap-cell" style="background:${getHeatColor(c.value, currentHeatmapType)}" data-tooltip="${c.tooltip}"></div>`).join('')}</div>`;
    }
    function closeAnalysis() { document.getElementById('analysis-modal').classList.remove('show'); }

    function showSaveDialog() { document.getElementById('save-dialog-overlay').style.display = 'flex'; }
    function closeSaveDialog() { document.getElementById('save-dialog-overlay').style.display = 'none'; }

    // ヘッダーファイルドロップダウン
    function toggleTextFileDropdown() {
        const dropdown = document.getElementById('text-file-dropdown');
        const projectDropdown = document.getElementById('project-file-dropdown');
        projectDropdown.classList.remove('open');
        dropdown.classList.toggle('open');
    }

    function toggleProjectFileDropdown() {
        const dropdown = document.getElementById('project-file-dropdown');
        const textDropdown = document.getElementById('text-file-dropdown');
        textDropdown.classList.remove('open');
        dropdown.classList.toggle('open');
    }

    function closeAllFileDropdowns() {
        document.querySelectorAll('.header-file-dropdown').forEach(d => d.classList.remove('open'));
    }

    // ドロップダウン外クリックで閉じる
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.header-file-dropdown')) {
            closeAllFileDropdowns();
        }
    });

    function showTextSaveOptions() {
        showSaveDialog();
    }

    function openProjectFile() {
        document.getElementById('project-file-input').click();
    }

    function handleProjectFileLoad(input) {
        const file = input.files[0];
        if (!file) return;
        loadProjectFromFile(file);
        input.value = '';
    }

    async function loadProjectFromFile(file) {
        try {
            const text = await file.text();
            const project = JSON.parse(text);
            if (!project.version) throw new Error('Invalid project file');

            if (project.tabs) {
                const tabs = Array.isArray(project.tabs) ? project.tabs : (project.tabs.tabs || []);
                const activeTabId = project.currentTabId || project.activeTabId || project.tabs.activeTabId || (tabs[0]?.id ?? 1);
                const nextTabId = project.nextTabId || project.tabs.nextTabId || (Math.max(0, ...tabs.map(t => t.id||0)) + 1);
                localStorage.setItem(TABS_KEY, JSON.stringify({ tabs, activeTabId, nextTabId }));
            }
            if (project.memoTabs) {
                const tabs = Array.isArray(project.memoTabs) ? project.memoTabs : (project.memoTabs.tabs || []);
                const activeId = project.currentMemoTabId || project.activeMemoTabId || project.memoTabs.activeId || (tabs[0]?.id ?? 1);
                const nextId = project.nextMemoTabId || project.memoTabs.nextId || (Math.max(0, ...tabs.map(t => t.id||0)) + 1);
                localStorage.setItem(MEMO_KEY, JSON.stringify({ tabs, activeId, nextId }));
            }
            if (project.structure) {
                localStorage.setItem('cc_structure_data', JSON.stringify(project.structure));
            }
            if (project.character) {
                localStorage.setItem('cc_character_data', JSON.stringify(project.character));
            }
            if (project.world) {
                localStorage.setItem('cc_world_data', JSON.stringify(project.world));
            }
                        if (project.terms) {
                localStorage.setItem('cc_terms_data', JSON.stringify(project.terms));
            }
if (project.bookmarks) {
                localStorage.setItem(BOOKMARKS_KEY, JSON.stringify(project.bookmarks));
            }
            if (project.settings) {
                const s = project.settings;
                if (s.paneWidths) {
                    Object.entries(s.paneWidths).forEach(([k, v]) => {
                        if (v) localStorage.setItem(`cc_${k === 'input' ? 'pane_input' : k === 'preview' ? 'pane_preview' : k}_width_px`, v);
                    });
                }
                if (s.theme) localStorage.setItem('cc_theme', s.theme);
                if (s.autoSave !== undefined) localStorage.setItem('cc_autosave_enabled', s.autoSave);
                if (s.autoSaveInterval) localStorage.setItem('cc_autosave_interval', s.autoSaveInterval);
            }
            alert('プロジェクトを読み込みました。ページを再読み込みします。');
            location.reload();
        } catch (e) {
            alert('プロジェクトファイルの読み込みに失敗しました: ' + e.message);
        }
    }

    // プロジェクト保存機能
    function openProjectSaveDialog() {
        closeSaveDialog();
        // 通常起動の場合は通常モード
        try { if (!__ccNewProjectFlowActive) __ccSetProjectSaveDialogMode(false); } catch(e) {}
        document.getElementById('project-save-dialog').style.display = 'flex';
    }
    function closeProjectSaveDialog() {
        document.getElementById('project-save-dialog').style.display = 'none';
        try { __ccSetProjectSaveDialogMode(false); } catch(e) {}
        try { __ccNewProjectFlowActive = false; } catch(e) {}
    }

    function executeProjectSave() {
        const project = { version: 1, timestamp: Date.now() };

        if (document.getElementById('proj-save-text').checked) {
            // tabs は cc_editor_tabs に {tabs, activeTabId, nextTabId} で保存されている
            const tabState = JSON.parse(localStorage.getItem(TABS_KEY) || '{}');
            project.tabs = Array.isArray(tabState.tabs) ? tabState.tabs : [];
            project.currentTabId = tabState.activeTabId || (project.tabs[0]?.id ?? 1);
            project.nextTabId = tabState.nextTabId || (Math.max(0, ...project.tabs.map(t => t.id||0)) + 1);
        }
        if (document.getElementById('proj-save-memo').checked) {
            // memoTabs は cc_editor_memo_tabs に {tabs, activeId, nextId} で保存されている
            const memoState = JSON.parse(localStorage.getItem(MEMO_KEY) || '{}');
            project.memoTabs = Array.isArray(memoState.tabs) ? memoState.tabs : [];
            project.currentMemoTabId = memoState.activeId || (project.memoTabs[0]?.id ?? 1);
            project.nextMemoTabId = memoState.nextId || (Math.max(0, ...project.memoTabs.map(t => t.id||0)) + 1);
        }
        if (document.getElementById('proj-save-structure').checked) {
            project.structure = JSON.parse(localStorage.getItem('cc_structure_data') || '{"data":[],"nextId":1}');
        }
        if (document.getElementById('proj-save-character').checked) {
            project.character = JSON.parse(localStorage.getItem('cc_character_data') || '{"data":[],"nextId":1}');
        }        if (document.getElementById('proj-save-world').checked) {
            project.world = JSON.parse(localStorage.getItem('cc_world_data') || '{"data":[],"nextId":1}');
        }
        if (document.getElementById('proj-save-terms') && document.getElementById('proj-save-terms').checked) {
            project.terms = JSON.parse(localStorage.getItem('cc_terms_data') || '{"data":[],"nextId":1}');
        }

        if (document.getElementById('proj-save-bookmarks').checked) {
            project.bookmarks = JSON.parse(localStorage.getItem(BOOKMARKS_KEY) || '[]');
        }
        if (document.getElementById('proj-save-settings').checked) {
            project.settings = {
                paneWidths: {
                    input: localStorage.getItem('cc_pane_input_width_px'),
                    preview: localStorage.getItem('cc_pane_preview_width_px'),
                    memo: localStorage.getItem('cc_memo_width_px'),
                    outline: localStorage.getItem('cc_outline_width_px'),
                    structure: localStorage.getItem('cc_structure_width_px'),
                    search: localStorage.getItem('cc_search_width_px'),
                    character: localStorage.getItem('cc_character_width_px'),
                    world: localStorage.getItem('cc_world_width_px'),
                    terms: localStorage.getItem('cc_terms_width_px')
                },
                theme: localStorage.getItem('cc_theme'),
                autoSave: localStorage.getItem('cc_autosave_enabled'),
                autoSaveInterval: localStorage.getItem('cc_autosave_interval')
            };
        }

        const blob = new Blob([JSON.stringify(project, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `project_${new Date().toISOString().slice(0,10)}.ccproj`;
        a.click();
        closeProjectSaveDialog();
    }

    function loadProjectFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.ccproj,.json';
        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            try {
                const text = await file.text();
                const project = JSON.parse(text);
                if (!project.version) throw new Error('Invalid project file');

                if (project.tabs) {
                    const tabs = Array.isArray(project.tabs) ? project.tabs : (project.tabs.tabs || []);
                    const activeTabId = project.currentTabId || project.activeTabId || project.tabs.activeTabId || (tabs[0]?.id ?? 1);
                    const nextTabId = project.nextTabId || project.tabs.nextTabId || (Math.max(0, ...tabs.map(t => t.id||0)) + 1);
                    localStorage.setItem(TABS_KEY, JSON.stringify({ tabs, activeTabId, nextTabId }));
                    if (typeof loadTabsFromStorage === 'function') loadTabsFromStorage();
                }
                if (project.memoTabs) {
                    const tabs = Array.isArray(project.memoTabs) ? project.memoTabs : (project.memoTabs.tabs || []);
                    const activeId = project.currentMemoTabId || project.activeMemoTabId || project.memoTabs.activeId || (tabs[0]?.id ?? 1);
                    const nextId = project.nextMemoTabId || project.memoTabs.nextId || (Math.max(0, ...tabs.map(t => t.id||0)) + 1);
                    localStorage.setItem(MEMO_KEY, JSON.stringify({ tabs, activeId, nextId }));
                    if (typeof loadMemoTabs === 'function') loadMemoTabs();
                }
                if (project.structure) {
                    localStorage.setItem('cc_structure_data', JSON.stringify(project.structure));
                    if (typeof window.initStructure === 'function') window.initStructure();
                }
                if (project.character) {
                    localStorage.setItem('cc_character_data', JSON.stringify(project.character));
                    location.reload();
                }
                if (project.world) {
                    localStorage.setItem('cc_world_data', JSON.stringify(project.world));
                    location.reload();
                }
                if (project.bookmarks) {
                    localStorage.setItem(BOOKMARKS_KEY, JSON.stringify(project.bookmarks));
                    if (typeof renderBookmarks === 'function') renderBookmarks();
                }
                if (project.settings) {
                    const s = project.settings;
                    if (s.paneWidths) {
                        Object.entries(s.paneWidths).forEach(([k, v]) => {
                            if (v) localStorage.setItem(`cc_${k === 'input' || k === 'preview' ? 'pane_' + k : k}_width_px`, v);
                        });
                    }
                    if (s.theme) localStorage.setItem('cc_theme', s.theme);
                    if (s.autoSave) localStorage.setItem('cc_autosave_enabled', s.autoSave);
                    if (s.autoSaveInterval) localStorage.setItem('cc_autosave_interval', s.autoSaveInterval);
                }

                closeProjectSaveDialog();
                alert('プロジェクトを読み込みました。ページを再読み込みして完全に反映します。');
                location.reload();
            } catch (err) {
                alert('プロジェクトファイルの読み込みに失敗しました: ' + err.message);
            }
        };
        input.click();
    }

    async function saveWithHandle(handle, blob) {
        if (!handle) return false;
        try {
            const permission = await handle.queryPermission({ mode: 'readwrite' });
            if (permission !== 'granted') {
                const requested = await handle.requestPermission({ mode: 'readwrite' });
                if (requested !== 'granted') return false;
            }
            const writable = await handle.createWritable();
            await writable.write(blob);
            await writable.close();
            return true;
        } catch (err) {
            return false;
        }
    }
    async function saveBlobWithPicker(blob, suggestedName, types, existingHandle) {
        if (existingHandle) {
            const handled = await saveWithHandle(existingHandle, blob);
            if (handled) return { handled: true, handle: existingHandle };
        }
        if (!window.showSaveFilePicker) return { handled: false, handle: null };
        try {
            const handle = await window.showSaveFilePicker({ suggestedName, types });
            const handled = await saveWithHandle(handle, blob);
            return { handled, handle: handled ? handle : null };
        } catch (err) {
            if (err && err.name === 'AbortError') return { handled: true, handle: existingHandle || null };
            return { handled: false, handle: null };
        }
    }
    function getNovelBaseName() {
        const base = sanitizeFileName(novelTitle || DEFAULT_NOVEL_TITLE);
        return base || 'novel';
    }
    function getSaveScope() { return document.querySelector('input[name="save-scope"]:checked')?.value || 'current'; }
    function getContentToSave(scope = getSaveScope()) { return scope === 'all' ? getAllTabsContent() : getCurrentTabContent(); }
    function setAutoSaveTarget(handle, type, scope) {
        autoSaveTarget = { handle, type, scope };
    }
    function maybePromptEnableAutoSave() {
        if (settingsCache.autosaveEnabled) return;
        if (!autoSaveTarget.handle) return;
        const enable = confirm('自動保存をオンにすると、指定したフォルダーに保存が続きますがよろしいですか？');
        if (enable) {
            document.getElementById('st-autosave-enabled').checked = true;
            applyAutoSaveSettings(true);
        }
    }
    async function saveAsText() {
        const scope = getSaveScope();
        const content = getContentToSave(scope);
        const b = new Blob([content], { type: 'text/plain' });
        const name = `${getNovelBaseName()}.txt`;
        const result = await saveBlobWithPicker(b, name, [{ description: 'Text', accept: { 'text/plain': ['.txt'] } }], lastTextSaveHandle);
        if (result.handle) lastTextSaveHandle = result.handle;
        if (!result.handled) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(b);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        if (result.handle) {
            setAutoSaveTarget(result.handle, 'text', scope);
            maybePromptEnableAutoSave();
        }
        closeSaveDialog();
    }
    async function saveAsHTML() {
        const scope = getSaveScope();
        const h = buildHtmlExport(scope);
        const b = new Blob([h], { type: 'text/html' });
        const name = `${getNovelBaseName()}.html`;
        const result = await saveBlobWithPicker(b, name, [{ description: 'HTML', accept: { 'text/html': ['.html'] } }], lastHtmlSaveHandle);
        if (result.handle) lastHtmlSaveHandle = result.handle;
        if (!result.handled) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(b);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        if (result.handle) {
            setAutoSaveTarget(result.handle, 'html', scope);
            maybePromptEnableAutoSave();
        }
        closeSaveDialog();
    }
    function renderTextToHTML(text) {
        const ss = settingsCache.showSpace, sh = settingsCache.showHighlight;
        let s = escapeHtml(text);
        const MZ = '\uE001', MH = '\uE002'; if (ss) { s = s.replace(/　/g, MZ).replace(/ /g, MH); }
        if (sh) { s = s.replace(/「(.*?)」/g, '<span class="bracket-blue">「$1」</span>').replace(/『(.*?)』/g, '<span class="bracket-green">『$1』</span>'); }
        s = s.replace(/｜([^《]+?)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>').replace(/([一-龠々〆ヵヶ]+)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>');
        s = s.replace(/《《(.+?)》》/g, (m, p) => { let r = ''; for (let c of p) r += `<ruby class="bouten-ruby">${c}<rt>・</rt></ruby>`; return r; });
        s = s.replace(/__(.+?)__/g, '<span class="underline-text">$1</span>').replace(/==(.+?)==/g, '<span class="highlight-text">$1</span>');
        if (sh) s = s.replace(/([―─]{2,}|…{2,})/g, '<span class="symbol-hl">$1</span>');
        if (ss) { s = s.split(MZ).join('<span class="space-zen">□</span>').split(MH).join('<span class="space-han">･</span>'); }
        return s.replace(/\n/g, '<br>');
    }
    function parseStructuredTabs(text, marker) {
        const lines = text.split(/\r?\n/);
        const rx = new RegExp(`^\\${marker}\\s*(.*)$`);
        const tabs = [];
        let current = null;
        lines.forEach(line => {
            const m = line.match(rx);
            if (m) {
                if (current) tabs.push(current);
                current = { name: m[1].trim() || '', content: '' };
            } else if (current) {
                current.content += (current.content ? '\n' : '') + line;
            }
        });
        if (current) tabs.push(current);
        return tabs;
    }

    // -----------------------------
    // 📂 開く：その場で「現在タブ / 新規タブ」を選ぶ
    // -----------------------------
    function openFileWithChoice() {
        const modal = document.getElementById('open-choice-modal');
        if (!modal) {
            // 旧動作のフォールバック
            document.getElementById('file-input')?.click();
            return;
        }

        // 設定（既定）に応じてボタンの強調を変える
        const defaultMode = (settingsCache && settingsCache.openMode) ? settingsCache.openMode : 'current';
        const btnCur = document.getElementById('btn-open-choice-current');
        const btnNew = document.getElementById('btn-open-choice-new');
        if (btnCur && btnNew) {
            btnCur.classList.toggle('active', defaultMode === 'current');
            btnNew.classList.toggle('active', defaultMode === 'new');
        }

        modal.classList.add('show');
        modal.setAttribute('aria-hidden', 'false');
    }

    function closeOpenChoiceModal() {
        const modal = document.getElementById('open-choice-modal');
        if (!modal) return;
        modal.classList.remove('show');
        modal.setAttribute('aria-hidden', 'true');
        pendingOpenMode = null;
    }

    function chooseOpenModeAndPickFile(mode) {
        pendingOpenMode = mode;
        closeOpenChoiceModal();
        // 次の tick で file picker を開く（モーダルが閉じた後に）
        setTimeout(() => document.getElementById('file-input')?.click(), 0);
    }

    // モーダル外クリックで閉じる
    document.addEventListener('mousedown', (e) => {
        const modal = document.getElementById('open-choice-modal');
        if (!modal || !modal.classList.contains('show')) return;
        if (e.target === modal) closeOpenChoiceModal();
    });
    function loadFile(input) {
        const f = input.files[0]; if (!f) return;
        const r = new FileReader();
        r.onload = e => {
            const content = e.target.result;

            // まず現在タブの内容を保存
            const currentTab = inputTabs.find(t => t.id === activeTabId);
            if (currentTab) currentTab.content = inputArea.value;

            // 「📂 開く」の選択（その場選択）があれば最優先。なければ設定の既定を使う
            const openMode = pendingOpenMode || ((settingsCache && settingsCache.openMode) ? settingsCache.openMode : 'current');
            const parsedTabs = parseStructuredTabs(content, '◆');

            // 開くモード: current = 現在タブへ上書き / new = 新規タブへ追加
            if (openMode === 'current') {
                if (!currentTab) {
                    // 念のため（通常は必ずある）
                    inputTabs.push({ id: nextTabId++, name: `タブ${inputTabs.length + 1}`, content: '' });
                    activeTabId = inputTabs[inputTabs.length - 1].id;
                }

                const targetTab = inputTabs.find(t => t.id === activeTabId);
                if (parsedTabs.length > 0) {
                    // 1つ目は現在タブへ、残りは新規タブへ
                    const first = parsedTabs[0];
                    targetTab.name = (first.name || targetTab.name || `タブ${activeTabId}`);
                    targetTab.content = first.content;
                } else {
                    targetTab.content = content;
                }

                // 残りタブ追加（for文をPython風に書いてしまう事故を避けるため、下でJSとして追記する）
                if (parsedTabs.length > 1) {
                    for (let i = 1; i < parsedTabs.length; i++) {
                        const tab = parsedTabs[i];
                        const name = tab.name || `タブ${inputTabs.length + 1}`;
                        inputTabs.push({ id: nextTabId++, name, content: tab.content });
                    }
                    // 最後に追加したタブへ移動するかどうかは好みが分かれるので、現在タブのままにします
                }

                inputArea.value = inputTabs.find(t => t.id === activeTabId)?.content || '';

            } else {
                // new: 既存仕様（読み込んだ内容を新規タブとして追加）
                if (parsedTabs.length > 0) {
                    parsedTabs.forEach(tab => {
                        const name = tab.name || `タブ${inputTabs.length + 1}`;
                        inputTabs.push({ id: nextTabId++, name, content: tab.content });
                    });
                    activeTabId = inputTabs[inputTabs.length - parsedTabs.length].id;
                    inputArea.value = inputTabs.find(t => t.id === activeTabId)?.content || '';
                } else {
                    const name = `タブ${inputTabs.length + 1}`;
                    inputTabs.push({ id: nextTabId++, name, content });
                    activeTabId = inputTabs[inputTabs.length - 1].id;
                    inputArea.value = content;
                }
            }

            renderInputTabs();
            updateInputStats();
            updatePreview();
            saveTabsToStorage();
            input.value = '';
            pendingOpenMode = null;
        };
        r.readAsText(f);
    }

    document.addEventListener('keydown', e => {
        if (document.getElementById('reader-overlay')?.classList.contains('show')) {
            if (e.key === 'Escape') { e.preventDefault(); closeReaderView(); return; }
        }

        if (e.key === 'Escape') { if (document.body.classList.contains('focus-mode')) toggleFocusMode(); closeJumpDialog(); closeAnalysis(); closeMemoSaveDialog(); }
        if (e.key === 'F11') { e.preventDefault(); toggleFocusMode(); }
        if (e.ctrlKey && e.key === 'g') { e.preventDefault(); showJumpDialog(); }
        if (e.ctrlKey && e.key === 'f') { e.preventDefault(); toggleSearchPanel(); }
        if (e.ctrlKey && e.key === 's') { e.preventDefault(); showSaveDialog(); }
        if (e.ctrlKey && !e.shiftKey && e.key === 't') { e.preventDefault(); addNewTab(); }
        if (e.ctrlKey && e.shiftKey && e.key === 'T') { e.preventDefault(); addNewMemoTab(); }
        // Ctrl+Alt+Enter: 同期（更新＋位置合わせを一発）
        if (e.ctrlKey && e.altKey && e.key === 'Enter') {
            e.preventDefault();
            try { updatePreview(); } catch (err) {}
            try { syncPreviewPosition(); } catch (err) {}
        }
    });
    inputArea.addEventListener('keyup', updateCursorLineDisplay);
    inputArea.addEventListener('click', updateCursorLineDisplay);

    // Pane Resizer
    (function initResizer() {
        const resizer = document.getElementById('resizer-input-preview');
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');
        let isResizing = false;

        resizer.addEventListener('mousedown', e => {
            isResizing = true;
            resizer.classList.add('resizing');
            document.body.style.cursor = document.body.classList.contains('scroll-mode') ? 'row-resize' : 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', e => {
            if (!isResizing) return;
            if (document.body.classList.contains('scroll-mode')) {
                const minPaneHeight = 160;
                const inputRect = inputPane.getBoundingClientRect();
                const previewRect = previewPane.getBoundingClientRect();
                const totalHeight = inputRect.height + previewRect.height;
                if (totalHeight <= minPaneHeight * 2) return;
                const stackRect = paneStack.getBoundingClientRect();
                const topPane = paneStack.classList.contains('reverse-col') ? previewPane : inputPane;
                const bottomPane = paneStack.classList.contains('reverse-col') ? inputPane : previewPane;
                const newTopHeight = clampValue(e.clientY - stackRect.top, minPaneHeight, totalHeight - minPaneHeight);
                const newBottomHeight = totalHeight - newTopHeight;
                topPane.style.height = `${newTopHeight}px`;
                bottomPane.style.height = `${newBottomHeight}px`;
            } else {
                const minPaneWidth = 120;
                const inputRect = inputPane.getBoundingClientRect();
                const previewRect = previewPane.getBoundingClientRect();
                const totalWidth = inputRect.width + previewRect.width;
                if (totalWidth <= minPaneWidth * 2) return;

                if (paneStack.classList.contains('reverse-row')) {
                    const newPreviewWidth = clampValue(e.clientX - previewRect.left, minPaneWidth, totalWidth - minPaneWidth);
                    const newInputWidth = totalWidth - newPreviewWidth;
                    previewPane.style.flex = `1 1 ${newPreviewWidth}px`;
                    inputPane.style.flex = `1 1 ${newInputWidth}px`;
                    previewPane.style.width = `${newPreviewWidth}px`;
                    inputPane.style.width = `${newInputWidth}px`;
                } else {
                    const newInputWidth = clampValue(e.clientX - inputRect.left, minPaneWidth, totalWidth - minPaneWidth);
                    const newPreviewWidth = totalWidth - newInputWidth;
                    inputPane.style.flex = `1 1 ${newInputWidth}px`;
                    previewPane.style.flex = `1 1 ${newPreviewWidth}px`;
                    inputPane.style.width = `${newInputWidth}px`;
                    previewPane.style.width = `${newPreviewWidth}px`;
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                lockedOtherWidth = null;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                if (document.body.classList.contains('scroll-mode')) {
                    const inputRect = inputPane.getBoundingClientRect();
                    const previewRect = previewPane.getBoundingClientRect();
                    const inputHeight = Math.round(inputRect.height);
                    const previewHeight = Math.round(previewRect.height);
                    document.getElementById('st-pane-input-height').value = inputHeight;
                    document.getElementById('st-pane-preview-height').value = previewHeight;
                    localStorage.setItem(PANE_HEIGHT_KEYS.input, String(inputHeight));
                    localStorage.setItem(PANE_HEIGHT_KEYS.preview, String(previewHeight));
                } else {
                    const inputRect = inputPane.getBoundingClientRect();
                    const previewRect = previewPane.getBoundingClientRect();
                    const inputWidth = Math.round(inputRect.width);
                    const previewWidth = Math.round(previewRect.width);
                    document.getElementById('st-pane-input-width').value = inputWidth;
                    document.getElementById('st-pane-preview-width').value = previewWidth;
                    localStorage.setItem(PANE_WIDTH_KEYS.input, inputWidth);
                    localStorage.setItem(PANE_WIDTH_KEYS.preview, previewWidth);
                }
            }
        });
    })();

    (function initDockResizers() {
        const mainContainer = document.getElementById('main-container');
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');

        function setupDockResizer(resizerId, panelId, widthInputId, storageKey, getSide) {
            const resizer = document.getElementById(resizerId);
            const panel = document.getElementById(panelId);
            const otherPanel = panelId === 'memo-panel' ? document.getElementById('outline-panel') : document.getElementById('memo-panel');
            const otherWidthInputId = panelId === 'memo-panel' ? 'st-pane-outline-width' : 'st-pane-memo-width';
            const otherIsDocked = () => (panelId === 'memo-panel' ? mainContainer.classList.contains('outline-docked') : mainContainer.classList.contains('memo-docked'));
            let isResizing = false;
            let lockedOtherWidth = null;

            resizer.addEventListener('mousedown', e => {
                if (!panel.classList.contains('open')) return;
                isResizing = true;
                // もう片方のドック（目次/メモ）が開いている場合は、現在幅をロックして動かさない
                lockedOtherWidth = null;
                if (otherPanel && otherIsDocked() && otherPanel.classList.contains('open')) {
                    lockedOtherWidth = Math.round(otherPanel.getBoundingClientRect().width);
                    if (lockedOtherWidth > 0) {
                        otherPanel.style.width = `${lockedOtherWidth}px`;
                        otherPanel.style.flexBasis = `${lockedOtherWidth}px`;
                    }
                }
                resizer.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!isResizing) return;
                const containerRect = mainContainer.getBoundingClientRect();
                const panelRect = panel.getBoundingClientRect();
                const minDockWidth = 160;
                const minPaneWidth = 120;
                const inputHidden = inputPane.classList.contains('hidden');
                const previewHidden = previewPane.classList.contains('hidden');
                let minCenter = 0;
                if (!inputHidden) minCenter += minPaneWidth;
                if (!previewHidden) minCenter += minPaneWidth;
                if (!inputHidden && !previewHidden) minCenter += 2;
                let otherDockWidth = 0;
                if (lockedOtherWidth !== null) {
                    otherDockWidth = lockedOtherWidth;
                } else if (panelId === 'memo-panel' && otherIsDocked()) {
                    const outlinePanel = document.getElementById('outline-panel');
                    if (mainContainer.classList.contains('outline-docked') && outlinePanel.classList.contains('open')) {
                        otherDockWidth = outlinePanel.getBoundingClientRect().width;
                    }
                } else if (panelId !== 'memo-panel' && otherIsDocked()) {
                    const memoPanel = document.getElementById('memo-panel');
                    if (memoPanel.classList.contains('open')) {
                        otherDockWidth = memoPanel.getBoundingClientRect().width;
                    }
                }

                const maxDockWidth = Math.max(minDockWidth, containerRect.width - otherDockWidth - minCenter);
                const side = getSide();
                const rawWidth = side === 'left' ? e.clientX - panelRect.left : panelRect.right - e.clientX;
                const newWidth = clampValue(rawWidth, minDockWidth, maxDockWidth);
                panel.style.width = `${newWidth}px`;
                panel.style.flexBasis = `${newWidth}px`;
                // otherPanelの幅を毎フレーム固定して、広がりを防止
                if (lockedOtherWidth !== null && otherPanel) {
                    otherPanel.style.width = `${lockedOtherWidth}px`;
                    otherPanel.style.flexBasis = `${lockedOtherWidth}px`;
                    otherPanel.style.flexGrow = '0';
                    otherPanel.style.flexShrink = '0';
                }
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                lockedOtherWidth = null;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                const panelRect = panel.getBoundingClientRect();
                const widthValue = Math.round(panelRect.width);
                document.getElementById(widthInputId).value = widthValue;
                localStorage.setItem(storageKey, widthValue);
                applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
            });
        }

        setupDockResizer(
            'resizer-memo',
            'memo-panel',
            'st-pane-memo-width',
            PANE_WIDTH_KEYS.memo,
            () => (mainContainer.classList.contains('memo-right') ? 'right' : 'left')
        );
        setupDockResizer(
            'resizer-outline',
            'outline-panel',
            'st-pane-outline-width',
            PANE_WIDTH_KEYS.outline,
            () => (mainContainer.classList.contains('outline-left') ? 'left' : 'right')
        );

        (function setupStructureDockResizer() {
            const resizer = document.getElementById('resizer-structure');
            const panel = document.getElementById('structure-panel');
            if (!resizer || !panel || !mainContainer) return;
            let isResizing = false;

            resizer.addEventListener('mousedown', e => {
                if (!panel.classList.contains('open')) return;
                isResizing = true;
                resizer.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!isResizing) return;
                const containerRect = mainContainer.getBoundingClientRect();
                const panelRect = panel.getBoundingClientRect();
                const minDockWidth = 160;
                const minPaneWidth = 120;
                const inputHidden = inputPane.classList.contains('hidden');
                const previewHidden = previewPane.classList.contains('hidden');
                let minCenter = 0;
                if (!inputHidden) minCenter += minPaneWidth;
                if (!previewHidden) minCenter += minPaneWidth;
                if (!inputHidden && !previewHidden) minCenter += 2;
                let otherDockWidth = 0;
                const memoPanel = document.getElementById('memo-panel');
                const outlinePanel = document.getElementById('outline-panel');
                const searchPanel = document.getElementById('search-panel');
                if (mainContainer.classList.contains('memo-docked') && memoPanel?.classList.contains('open')) {
                    otherDockWidth += memoPanel.getBoundingClientRect().width;
                }
                if (mainContainer.classList.contains('outline-docked') && outlinePanel?.classList.contains('open')) {
                    otherDockWidth += outlinePanel.getBoundingClientRect().width;
                }
                if (mainContainer.classList.contains('search-docked') && searchPanel?.classList.contains('open')) {
                    otherDockWidth += searchPanel.getBoundingClientRect().width;
                }
                const maxDockWidth = Math.max(minDockWidth, containerRect.width - otherDockWidth - minCenter);
                const side = mainContainer.classList.contains('structure-right') ? 'right' : 'left';
                const rawWidth = side === 'left' ? e.clientX - panelRect.left : panelRect.right - e.clientX;
                const newWidth = clampValue(rawWidth, minDockWidth, maxDockWidth);
                panel.style.width = `${newWidth}px`;
                panel.style.flexBasis = `${newWidth}px`;
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                const widthValue = Math.round(panel.getBoundingClientRect().width);
                document.getElementById('st-pane-structure-width').value = widthValue;
                localStorage.setItem(PANE_WIDTH_KEYS.structure, widthValue);
                applyPaneWidthSettings();
                try { updateDockSplitState(); } catch (e) {}
            });
        })();

        (function setupSearchDockResizer() {
            const resizer = document.getElementById('resizer-search');
            const panel = document.getElementById('search-panel');
            if (!resizer || !panel || !mainContainer) return;
            let isResizing = false;

            resizer.addEventListener('mousedown', e => {
                if (!panel.classList.contains('open')) return;
                isResizing = true;
                resizer.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!isResizing) return;
                const containerRect = mainContainer.getBoundingClientRect();
                const panelRect = panel.getBoundingClientRect();
                const minDockWidth = 160;
                const minPaneWidth = 120;
                const inputHidden = inputPane.classList.contains('hidden');
                const previewHidden = previewPane.classList.contains('hidden');
                let minCenter = 0;
                if (!inputHidden) minCenter += minPaneWidth;
                if (!previewHidden) minCenter += minPaneWidth;
                if (!inputHidden && !previewHidden) minCenter += 2;
                let otherDockWidth = 0;
                const memoPanel = document.getElementById('memo-panel');
                const outlinePanel = document.getElementById('outline-panel');
                if (mainContainer.classList.contains('memo-docked') && memoPanel?.classList.contains('open')) {
                    otherDockWidth += memoPanel.getBoundingClientRect().width;
                }
                if (mainContainer.classList.contains('outline-docked') && outlinePanel?.classList.contains('open')) {
                    otherDockWidth += outlinePanel.getBoundingClientRect().width;
                }
                const maxDockWidth = Math.max(minDockWidth, containerRect.width - otherDockWidth - minCenter);
                const side = mainContainer.classList.contains('search-left') ? 'left' : 'right';
                const rawWidth = side === 'left' ? e.clientX - panelRect.left : panelRect.right - e.clientX;
                const newWidth = clampValue(rawWidth, minDockWidth, maxDockWidth);
                panel.style.width = `${newWidth}px`;
                panel.style.flexBasis = `${newWidth}px`;
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                const widthValue = Math.round(panel.getBoundingClientRect().width);
                document.getElementById('st-pane-search-width').value = widthValue;
                localStorage.setItem(PANE_WIDTH_KEYS.search, widthValue);
                applyPaneWidthSettings();
                try { updateDockSplitState(); } catch (e) {}
            });
        })();
    })();

    (function setupMemoOutlineSplitResizer() {
        const resizer = document.getElementById('resizer-memo-outline');
        const memoPanel = document.getElementById('memo-panel');
        const outlinePanel = document.getElementById('outline-panel');
        if (!resizer || !memoPanel || !outlinePanel) return;
        let isResizing = false;

        const onMouseMove = e => {
            if (!isResizing) return;
            const memoRect = memoPanel.getBoundingClientRect();
            const outlineRect = outlinePanel.getBoundingClientRect();
            const totalWidth = memoRect.width + outlineRect.width;
            const minWidth = 160;
            const rawWidth = e.clientX - memoRect.left;
            const memoWidth = clampValue(Math.round(rawWidth), minWidth, totalWidth - minWidth);
            const outlineWidth = Math.max(minWidth, totalWidth - memoWidth);
            memoPanel.style.width = `${memoWidth}px`;
            memoPanel.style.flexBasis = `${memoWidth}px`;
            outlinePanel.style.width = `${outlineWidth}px`;
            outlinePanel.style.flexBasis = `${outlineWidth}px`;
            document.getElementById('st-pane-memo-width').value = memoWidth;
            document.getElementById('st-pane-outline-width').value = outlineWidth;
            localStorage.setItem(PANE_WIDTH_KEYS.memo, memoWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.outline, outlineWidth);
        };

        const onMouseUp = () => {
            if (!isResizing) return;
            isResizing = false;
            resizer.classList.remove('resizing');
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };

        resizer.addEventListener('mousedown', e => {
            const mc = document.getElementById('main-container');
        if (!mc) return;
        if (!mc.classList.contains('dock-split-right') && !mc.classList.contains('dock-split-left')) {
            return;
        }
        // 右境界（メモ｜目次）のドラッグは誤操作が起きやすいので、Altキー押下時だけ有効にする
        if (!e.altKey) return;
            isResizing = true;
            resizer.classList.add('resizing');
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    })();

    

function applyDockedPaneWidths() {
  if (typeof applyDockedPanelWidths === 'function') return applyDockedPanelWidths();
}

function applyDefaultStartupPrefsOnce() {
  // 1回だけ（初回起動だけ）適用したい場合
  if (localStorage.getItem('cc_default_startup_prefs_applied') === '1') return;

  // 縦書きON（入力＋プレビュー）
  const inV = document.getElementById('st-in-v');
  const pvV = document.getElementById('st-pv-v');
  if (inV) inV.checked = true;
  if (pvV) pvV.checked = true;

  if (typeof applyInputSettings === 'function') applyInputSettings();
  if (typeof applyPreviewSettings === 'function') applyPreviewSettings();

  // レイアウト既定：横に並べる（入力=左、プレビュー=右）
  layoutAxis = 'row';
  layoutReversed = false;
  if (typeof applyLayoutState === 'function') applyLayoutState();
  if (typeof saveLayoutSettings === 'function') saveLayoutSettings();

  // 設定として保存（次回以降も縦書き維持）
  if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();

  localStorage.setItem('cc_default_startup_prefs_applied', '1');
}

function applyDefaultStartupLayoutAfterReset() {
  // ✅初期化後の既定レイアウト：横に並べる（入力=左 / プレビュー=右）
  try {
    layoutAxis = 'row';
    layoutReversed = false;
    applyLayoutState();
    saveLayoutSettings();
  } catch (e) {}

  // 💀初期化後は「初回扱い」に戻す
  localStorage.removeItem('cc_default_layout_applied');
  localStorage.removeItem('cc_default_startup_prefs_applied');
  sessionStorage.removeItem('cc_editor_session_started');

  // もう一度「初回起動時の既定」を適用
  if (typeof applyDefaultStartupPrefsOnce === 'function') applyDefaultStartupPrefsOnce();
  if (typeof applyDefaultDockLayoutOnce === 'function') applyDefaultDockLayoutOnce();

  // 初回はプレビュー必ず表示
  const cb = document.getElementById('check-show-preview');
  const pane = document.getElementById('pane-preview');
  if (cb) cb.checked = true;
  if (pane) pane.classList.remove('hidden');

  // レイアウト再計算
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
  if (typeof updateDockTopOffset === 'function') updateDockTopOffset();

  // プレビュー同期（即時＋次tickでもう一回）
  if (typeof updatePreview === 'function') updatePreview();
  setTimeout(() => {
    if (typeof updatePreview === 'function') updatePreview();
  }, 0);
}


	
function applyDefaultDockLayoutOnce() {
  if (localStorage.getItem('cc_default_layout_applied') === '1') return;

  const c = document.getElementById('main-container');
  const memo = document.getElementById('memo-panel');
  const outline = document.getElementById('outline-panel');
  const structure = document.getElementById('structure-panel');
  const search = document.getElementById('search-panel');
  const memoDock = document.getElementById('check-memo-dock');
  const outlineDock = document.getElementById('check-outline-dock');
  const structureDock = document.getElementById('check-structure-dock');
  const searchDock = document.getElementById('check-search-dock');

  if (!c || !memo || !outline || !memoDock || !outlineDock) return;

  // 左メモ（ドック＆開く）
  memoDock.checked = true;
  c.classList.add('memo-docked');
memo.classList.add('open');

  // 右目次（ドック＆開く）
  outlineDock.checked = true;
  c.classList.add('outline-docked');
outline.classList.add('open');

  // 構成・検索は閉じる
  if (structureDock) structureDock.checked = false;
  if (structure) structure.classList.remove('open');
  c.classList.remove('structure-docked');

  if (searchDock) searchDock.checked = false;
  if (search) search.classList.remove('open');
  c.classList.remove('search-docked');

  // 余計な分割状態が残ってたらリセット
  c.classList.remove('dock-split-left', 'dock-split-right');

  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
  if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
  localStorage.setItem('cc_default_layout_applied', '1');
}
	
// エラー回避：未実装でも落ちないようにする
function updateActiveTabTitle() {}

// 初期化
    loadAutoSave();
    loadTodayStart();
    loadWritingTime();
    loadBookmarks();
    loadMemoTabs();
    loadLayoutSettings();
        if (typeof updateWritingModeButtonLabels === 'function') updateWritingModeButtonLabels();
    loadSettingsFromStorage();
    initTextColorSettings();
	applyDefaultStartupPrefsOnce();
    loadPaneWidthSettings();
    loadPaneHeightSettings();
    loadDividerSettings();
    loadNovelTitle();
    startWritingTimer();
    applyAllSettings();
	applyDefaultDockLayoutOnce();
    updateDockTopOffset();
    updateDockSplitState();
	if (typeof setupMemoInteractionGuard === 'function') setupMemoInteractionGuard();

    // Apply default preview hidden setting on first load
// 初回（スーパーリロード・初起動）はプレビューを必ず表示
if (!localStorage.getItem('cc_editor_session_started')) {
  const cb = document.getElementById('check-show-preview');
  const pane = document.getElementById('pane-preview');
  if (cb) cb.checked = true;
  if (pane) pane.classList.remove('hidden');
} else {
  // 2回目以降は既存設定に従う（必要なら残す）
  if (settingsCache.defaultPreviewHidden) {
    const cb = document.getElementById('check-show-preview');
    const pane = document.getElementById('pane-preview');
    if (cb) cb.checked = false;
    if (pane) pane.classList.add('hidden');
  }
}

    sessionStorage.setItem('cc_editor_session_started', 'true');
    updateInputStats();
    renderPreviewTabs();
    updatePreview();

	// 起動直後にもう一度だけプレビューを同期（初回/スーパーリロード時の取りこぼし対策）
setTimeout(() => {
  if (typeof updatePreview === 'function') updatePreview();
}, 0);

	
    updatePanelButtonStates();
    updateWritingTimeDisplay();
window.addEventListener('resize', () => {
        updateDockTopOffset();
    });
    </script>

<style>
    /* メモタブのデザイン */
    .memo-tab {
        padding: 4px 12px;
        font-size: 0.85rem;
        cursor: pointer;
        background: #e5e7eb;
        border-radius: 4px 4px 0 0;
        border: 1px solid transparent;
        color: #6b7280;
        user-select: none;
        display: flex; align-items: center; gap: 6px;
        white-space: nowrap;
    }
    .memo-tab.active {
        background: #ffffff;
        color: #1f2937;
        font-weight: bold;
        border-top: 2px solid #2563eb;
        border-bottom: 1px solid #ffffff; /* 下線を消して一体化 */
        margin-bottom: -1px; /* 微調整 */
    }
    .memo-tab-close {
        font-size: 0.7rem; border-radius: 50%; width: 16px; height: 16px;
        display: inline-flex; align-items: center; justify-content: center;
        color: #9ca3af;
    }
    .memo-tab-close:hover { background: #fee2e2; color: #ef4444; }
    .memo-tab-add {
        padding: 4px 8px; cursor: pointer; color: #6b7280; font-weight: bold;
        display: flex; align-items: center;
    }
    .memo-tab-add:hover { color: #2563eb; background: #dbeafe; border-radius: 4px; }
</style>

	<!--
<script>
// メモ操作中フラグ（浮動メモが勝手に閉じないようにする）
window.memoInteracting = false;

function setupMemoInteractionGuard() {
  const memo = document.getElementById('memo-panel');
  if (!memo) return;

  memo.addEventListener('pointerenter', () => window.memoInteracting = true);
  memo.addEventListener('pointerleave', () => window.memoInteracting = false);
  memo.addEventListener('focusin', () => window.memoInteracting = true);
  memo.addEventListener('focusout', () => window.memoInteracting = false);
}
	
    // メモのタブ管理データ
    let memoTabs = [];
    try {
        memoTabs = JSON.parse(localStorage.getItem('cc_memo_tabs')) || [];
    } catch(e) {}

    // データがない場合の初期化
    if (!Array.isArray(memoTabs) || memoTabs.length === 0) {
        memoTabs = [{ id: 'm1', title: 'メモ1', content: '' }];
    }
    
    let currentMemoId = localStorage.getItem('cc_memo_current_id') || memoTabs[0].id;

    // タブを描画する機能
    function renderMemoTabs() {
        const container = document.getElementById('memo-tabs-container');
        if (!container) return; // コンテナがない場合は何もしない
        
        let html = '';
        memoTabs.forEach(tab => {
            const isActive = tab.id === currentMemoId ? 'active' : '';
            html += `
                <div class="memo-tab ${isActive}" onclick="switchMemoTab('${tab.id}')">
                    <span>${tab.title}</span>
                    <span class="memo-tab-close" onclick="deleteMemoTab(event, '${tab.id}')">✕</span>
                </div>
            `;
        });
        // プラスボタン
        html += `<div class="memo-tab-add" onclick="addMemoTab()">＋</div>`;
        container.innerHTML = html;

        // 現在のメモの内容をエリアに表示
        const currentTab = memoTabs.find(t => t.id === currentMemoId);
        const memoArea = document.getElementById('memo-area');
        if (currentTab && memoArea) {
            // 値が違う場合のみ更新（カーソル位置飛び防止）
            if (memoArea.value !== currentTab.content) {
                memoArea.value = currentTab.content;
            }
            updateMemoCharCount();
        }
    }

    // タブを切り替える
    function switchMemoTab(id) {
        saveMemoTabs(); // 切り替え前に保存
        currentMemoId = id;
        localStorage.setItem('cc_memo_current_id', id);
        renderMemoTabs();
    }

    // 新しいタブを追加する
    function addMemoTab() {
        saveMemoTabs();
        const newId = 'm' + Date.now();
        const newNum = memoTabs.length + 1;
        memoTabs.push({ id: newId, title: `メモ${newNum}`, content: '' });
        switchMemoTab(newId);
    }

    // タブを削除する
    function deleteMemoTab(e, id) {
        e.stopPropagation(); 
        if (memoTabs.length <= 1) {
            alert("最後の1つは削除できません");
            return;
        }
        if(!confirm("このメモを削除しますか？")) return;

        memoTabs = memoTabs.filter(t => t.id !== id);
        if (currentMemoId === id) {
            currentMemoId = memoTabs[0].id;
        }
        saveMemoTabs();
        renderMemoTabs();
    }

    // 内容を保存する
    function saveMemoTabs() {
        const currentTab = memoTabs.find(t => t.id === currentMemoId);
        const memoArea = document.getElementById('memo-area');
        if (currentTab && memoArea) {
            currentTab.content = memoArea.value;
        }
        localStorage.setItem('cc_memo_tabs', JSON.stringify(memoTabs));
        localStorage.setItem('cc_memo_current_id', currentMemoId);
    }

/*
    // 文字数カウント
    function updateMemoCharCount() {
        const memoArea = document.getElementById('memo-area');
        const countEl = document.getElementById('memo-char-count');
        if (memoArea && countEl) {
            countEl.innerText = memoArea.value.length + '字';
        }
    }
*/
	
    // 起動時に実行
    setTimeout(renderMemoTabs, 500);
	function updateActiveTabTitle() {
  // TODO: 後で実装。とりあえずエラー回避用
}
</script>
	-->

<script>
// ===== v0.97 integrated patch (2026-01-17) =====
(function(){
  'use strict';

  // -----------------------------
  // 0) Small helpers
  // -----------------------------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const lsGet = (k, d=null) => { try{ const v=localStorage.getItem(k); return v==null?d:JSON.parse(v);}catch(e){ return d; } };
  const lsSet = (k, v) => { try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} };
  const escapeHtml = window.escapeHtml || ((s)=>String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])));

  // -----------------------------
  // 1) Disable focus-mode overlay shortcuts (user request)
  // -----------------------------
  try {
    // If function exists globally, make it no-op to avoid shortcut-triggered overlay.
    if (typeof window.openFocusOverlay === 'function') {
      window.openFocusOverlay = function(){ /* disabled */ };
    }
  } catch(e){}

  // -----------------------------
  // 2) "Open" behavior: remove dependency on Settings > Open
  //    - Always ask in modal
  //    - Checkbox "set as default" stores a local default
  // -----------------------------
  const OPEN_DEFAULT_KEY = 'cc_open_default_mode_v2';
  let pendingOpenModeV2 = null;

  function getOpenDefaultMode(){
    const v = localStorage.getItem(OPEN_DEFAULT_KEY);
    return (v === 'new' || v === 'current') ? v : 'current';
  }
  function setOpenDefaultMode(v){
    if (v === 'new' || v === 'current') localStorage.setItem(OPEN_DEFAULT_KEY, v);
  }

  // override openFileWithChoice
  const _openFileWithChoice = window.openFileWithChoice;
  window.openFileWithChoice = function(){
    const modal = document.getElementById('open-choice-modal');
    if (!modal) {
      if (typeof _openFileWithChoice === 'function') return _openFileWithChoice();
      document.getElementById('file-input')?.click();
      return;
    }
    const defaultMode = getOpenDefaultMode();
    const btnCur = document.getElementById('btn-open-choice-current');
    const btnNew = document.getElementById('btn-open-choice-new');
    if (btnCur && btnNew) {
      btnCur.classList.toggle('active', defaultMode === 'current');
      btnNew.classList.toggle('active', defaultMode === 'new');
    }
    const chk = document.getElementById('check-open-set-default');
    if (chk) chk.checked = false;
    modal.classList.add('show');
    modal.setAttribute('aria-hidden', 'false');
  };

  window.closeOpenChoiceModal = function(){
    const modal = document.getElementById('open-choice-modal');
    if (!modal) return;
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden', 'true');
    // do NOT clear pending mode here; only cancel should clear
  };

  window.chooseOpenModeAndPickFile = function(mode){
    pendingOpenModeV2 = mode;
    const chk = document.getElementById('check-open-set-default');
    if (chk && chk.checked) setOpenDefaultMode(mode);
    // close without clearing pending
    const modal = document.getElementById('open-choice-modal');
    if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
    setTimeout(()=>document.getElementById('file-input')?.click(),0);
  };

  // Patch loadFile to use pendingOpenModeV2 and OPEN_DEFAULT_KEY only
  const _loadFile = window.loadFile;
  window.loadFile = function(input){
    if (!input || !input.files || !input.files[0]) return;
    // Monkey patch: temporarily set a global used by original loadFile if it relies on pendingOpenMode
    try { window.pendingOpenMode = pendingOpenModeV2; } catch(e){}
    // Call original, but ensure it doesn't fall back to settingsCache.openMode
    // We'll wrap FileReader ourselves to fully control.
    const f = input.files[0];
    const r = new FileReader();
    r.onload = (e)=>{
      const content = e.target.result;

      // Save current tab content
      try{
        if (Array.isArray(window.inputTabs) && window.inputArea && window.activeTabId!=null){
          const currentTab = window.inputTabs.find(t=>t.id===window.activeTabId);
          if (currentTab) currentTab.content = window.inputArea.value;
        }
      }catch(err){}

      const openMode = pendingOpenModeV2 || getOpenDefaultMode();
      pendingOpenModeV2 = null;

      // parse structured tabs (reuse if exists)
      const parseStructuredTabs = window.parseStructuredTabs || function(text, marker){
        const lines = String(text).split(/\r?\n/);
        const rx = new RegExp(`^\${marker}\s*(.*)$`);
        const tabs=[];
        let cur=null;
        for(const line of lines){
          const m=line.match(rx);
          if(m){
            if(cur) tabs.push(cur);
            cur={name:(m[1]||'').trim(), content:''};
          } else if(cur){
            cur.content += (cur.content?"\n":"") + line;
          }
        }
        if(cur) tabs.push(cur);
        return tabs;
      };
      const parsedTabs = parseStructuredTabs(content,'◆');

      if (!Array.isArray(window.inputTabs)) window.inputTabs = [];
      if (typeof window.nextTabId !== 'number') window.nextTabId = (window.inputTabs.reduce((m,t)=>Math.max(m, t.id||0),0) + 1) || 2;
      if (window.inputTabs.length===0){
        window.inputTabs.push({id: window.nextTabId++, name:'タブ1', content:''});
        window.activeTabId = window.inputTabs[0].id;
      }

      const currentTab = window.inputTabs.find(t=>t.id===window.activeTabId) || window.inputTabs[0];

      if (openMode==='current'){
        if (parsedTabs.length>0){
          const first=parsedTabs[0];
          currentTab.name = first.name || currentTab.name || `タブ${currentTab.id}`;
          currentTab.content = first.content;
          for(let i=1;i<parsedTabs.length;i++){
            const tab=parsedTabs[i];
            window.inputTabs.push({id: window.nextTabId++, name: tab.name || `タブ${window.inputTabs.length+1}`, content: tab.content});
          }
        } else {
          currentTab.content = String(content);
        }
        if (window.inputArea) window.inputArea.value = currentTab.content || '';
        if (typeof window.renderInputTabs==='function') window.renderInputTabs();
        if (typeof window.updateInputStats==='function') window.updateInputStats();
      } else {
        // new tab
        if (parsedTabs.length>0){
          for(const tab of parsedTabs){
            window.inputTabs.push({id: window.nextTabId++, name: tab.name || `タブ${window.inputTabs.length+1}`, content: tab.content});
          }
          const last = window.inputTabs[window.inputTabs.length-1];
          window.activeTabId = last.id;
          if (typeof window.switchTab==='function') window.switchTab(last.id);
          else if (window.inputArea) window.inputArea.value = last.content || '';
        } else {
          const name = f.name ? f.name.replace(/\.[^.]+$/,'') : `タブ${window.inputTabs.length+1}`;
          const newTab={id: window.nextTabId++, name, content: String(content)};
          window.inputTabs.push(newTab);
          window.activeTabId = newTab.id;
          if (typeof window.switchTab==='function') window.switchTab(newTab.id);
          else if (window.inputArea) window.inputArea.value = newTab.content;
        }
        if (typeof window.renderInputTabs==='function') window.renderInputTabs();
        if (typeof window.updateInputStats==='function') window.updateInputStats();
      }

      // clear file input so same file can be opened again
      try{ input.value=''; }catch(err){}

      // update outline/preview if available
      try{ if (typeof window.updateOutline==='function') window.updateOutline(); }catch(err){}
      try{ if (typeof window.updatePreview==='function') window.updatePreview(); }catch(err){}
    };
    r.readAsText(f);
  };

  // Hide "Settings > Open" section and neutralize applyOpenSettingsAndSave
  function hideOpenSettings(){
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;
    // Find setting-title that includes "開く" and remove its block
    const titles = $$('.setting-title', settingsBar);
    for (const t of titles){
      if (t.textContent && t.textContent.trim().startsWith('開く')){
        const block = t.closest('.setting-block') || t.parentElement;
        if (block) block.style.display='none';
      }
    }
  }
  window.applyOpenSettingsAndSave = function(){ /* removed */ };

  // -----------------------------
  // 3) Pane colors: per pane background + header, custom priority
  // -----------------------------
  const PANE_COLOR_KEY = 'cc_pane_colors_v3';
  const DEFAULT_PANE_COLORS = {
    input: { bg: null, head: null },
    preview: { bg: null, head: null },
    memo: { bg: null, head: null },
    outline: { bg: null, head: null },
    structure: { bg: null, head: null },
    character: { bg: null, head: null },
    world: { bg: null, head: null },
    terms: { bg: null, head: null },
  };

  function getDefaultComputedColors(){
    // Use computed styles from existing theme as defaults
    const cs = getComputedStyle(document.documentElement);
    const panelBg = cs.getPropertyValue('--panel-bg').trim() || '#ffffff';
    const headerBg = cs.getPropertyValue('--pane-header-bg').trim() || '#f9fafb';
    // preview uses --preview-bg-color for body
    const previewBg = cs.getPropertyValue('--preview-bg-color').trim() || panelBg;
    return {
      input: { bg: panelBg, head: headerBg },
      preview: { bg: previewBg, head: headerBg },
      memo: { bg: panelBg, head: headerBg },
      outline: { bg: panelBg, head: headerBg },
      structure: { bg: panelBg, head: headerBg },
      character: { bg: '#fce7f3', head: '#fce7f3' },
      world: { bg: '#ecfdf5', head: '#d1fae5' },
      terms: { bg: panelBg, head: headerBg },
    };
  }

  function loadPaneColors(){
    const saved = lsGet(PANE_COLOR_KEY, null);
    if (!saved) return null;
    const out = JSON.parse(JSON.stringify(DEFAULT_PANE_COLORS));
    for (const k of ['input','preview','memo','outline','structure','character','world','terms']){
      if (saved[k]){
        out[k].bg = saved[k].bg || null;
        out[k].head = saved[k].head || null;
      }
    }
    return out;
  }

  function applyPaneColors(colors){
    const defaults = getDefaultComputedColors();
    const root = document.documentElement.style;
    const map = {
      input: ['--pane-input-bg','--pane-input-head'],
      preview: ['--pane-preview-bg','--pane-preview-head'],
      memo: ['--pane-memo-bg','--pane-memo-head'],
      outline: ['--pane-outline-bg','--pane-outline-head'],
      structure: ['--pane-structure-bg','--pane-structure-head'],
      character: ['--pane-character-bg','--pane-character-head'],
      world: ['--pane-world-bg','--pane-world-head'],
      terms: ['--pane-terms-bg','--pane-terms-head'],
    };
    for (const k of Object.keys(map)){
      const [bgVar, headVar] = map[k];
      const bg = (colors && colors[k] && colors[k].bg) ? colors[k].bg : defaults[k].bg;
      const head = (colors && colors[k] && colors[k].head) ? colors[k].head : defaults[k].head;
      root.setProperty(bgVar, bg);
      root.setProperty(headVar, head);
    }
  }

  function injectPaneColorCSS(){
    if (document.getElementById('cc-pane-color-style')) return;
    const st = document.createElement('style');
    st.id='cc-pane-color-style';
    st.textContent = `
      /* per-pane colors (custom priority) */
      #pane-input { background: var(--pane-input-bg, var(--panel-bg)); }
      #pane-input .pane-header, #pane-input .pane-subheader, #pane-input .tabs-scroll-wrap { background: var(--pane-input-head, var(--pane-header-bg)); }

      #pane-preview { background: var(--pane-preview-bg, var(--panel-bg)); }
      #pane-preview .pane-header, #pane-preview .pane-subheader, #pane-preview .tabs-scroll-wrap { background: var(--pane-preview-head, var(--pane-header-bg)); }
      #pane-preview .pane-body { background-color: var(--pane-preview-bg, var(--preview-bg-color)); }

      #memo-panel { background: var(--pane-memo-bg, var(--panel-bg)); }
      #memo-panel .memo-header, #memo-panel .memo-toolbar { background: var(--pane-memo-head, var(--pane-header-bg)); }

      #outline-panel { background: var(--pane-outline-bg, var(--panel-bg)); }
      #outline-panel .outline-toolbar, #outline-panel .outline-header { background: var(--pane-outline-head, var(--pane-header-bg)); }

      #structure-panel { background: var(--pane-structure-bg, #f0f4ff); }
      #structure-panel .structure-header, #structure-panel .structure-toolbar { background: var(--pane-structure-head, #e0e7ff); }

      #character-panel { background: var(--pane-character-bg, #fce7f3); }
      #character-panel .character-header, #character-panel .character-toolbar, #character-panel .character-footer { background: var(--pane-character-head, #fce7f3); }

      #world-panel { background: var(--pane-world-bg, #ecfdf5); }

      #terms-panel { background: var(--pane-terms-bg, var(--panel-bg)); }
      #terms-panel .terms-header, #terms-panel .terms-toolbar { background: var(--pane-terms-head, var(--pane-header-bg)); }

      #world-panel .world-header, #world-panel .world-toolbar, #world-panel .world-footer { background: var(--pane-world-head, #d1fae5); }

      /* Bookmark marker highlight in reader */
      .cc-reader-bm-mark { display:inline-block; margin-right:6px; font-size:0.9em; opacity:0.9; }
      .cc-reader-bm-hit { outline: 2px solid rgba(245, 158, 11, 0.65); outline-offset: 2px; border-radius: 6px; }

      /* Proofread modal */

      /* Replace preview */
      .replace-preview-row { padding: 8px 10px; border-bottom: 1px solid var(--border-color); display:flex; gap:10px; align-items:flex-start; }
      .replace-preview-row:hover { background: rgba(59,130,246,.06); }
      .rp-snippet { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 0.85em; white-space: pre-wrap; word-break: break-word; }
      .rp-after { opacity: 0.9; }
    `;
    document.head.appendChild(st);
  }

  function buildPaneColorSettingsUI(){
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;
    if (document.getElementById('cc-pane-colors-block')) return;

    const block = document.createElement('div');
    block.className='setting-block';
    block.id='cc-pane-colors-block';
    block.innerHTML = `
      <div class="setting-title">ペイン色（背景/ヘッダー）
        <button class="btn btn-apply" id="cc-pane-colors-apply">適用</button>
        <button class="btn" id="cc-pane-colors-reset">リセット</button>
      </div>
      <div class="setting-row" style="flex-direction:column; gap:10px; align-items:stretch;">
        ${['input','preview','memo','outline','structure','character','world','terms'].map(k=>{
          const label = ({input:'入力',preview:'プレビュー',memo:'メモ',outline:'目次',structure:'構成',character:'登場人物',world:'世界観',terms:'用語'})[k];
          return `
          <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
            <div style="min-width:64px; font-weight:700;">${label}</div>
            <label style="display:flex; align-items:center; gap:6px;">背景 <input type="color" id="cc-pane-${k}-bg" style="width:44px; height:28px;">
              <input type="text" id="cc-pane-${k}-bg-t" placeholder="#RRGGBB" style="width:96px;">
            </label>
            <label style="display:flex; align-items:center; gap:6px;">ヘッダー <input type="color" id="cc-pane-${k}-head" style="width:44px; height:28px;">
              <input type="text" id="cc-pane-${k}-head-t" placeholder="#RRGGBB" style="width:96px;">
            </label>
          </div>`;
        }).join('')}
        <div style="font-size:0.85rem; color:var(--text-muted); line-height:1.5;">
          ※「ヘッダー」は <b>ペイン上部 + 位置バー + タブバー</b> も含めてまとめて変更します。
          設定した色はテーマ変更より優先（カスタム優先）です。
        </div>
      </div>
    `;
    // Insert near top of settings (after basic theme?)
    const firstBlock = settingsBar.querySelector('.setting-block');
    if (firstBlock && firstBlock.parentElement) firstBlock.parentElement.insertBefore(block, firstBlock.nextSibling);
    else settingsBar.appendChild(block);

    const syncPair = (colorEl, textEl) => {
      if (!colorEl || !textEl) return;
      colorEl.addEventListener('input', ()=>{ textEl.value = colorEl.value; });
      textEl.addEventListener('change', ()=>{
        const v = textEl.value.trim();
        if (/^#?[0-9a-fA-F]{6}$/.test(v)) {
          const vv = v.startsWith('#')?v:'#'+v;
          colorEl.value = vv;
          textEl.value = vv;
        }
      });
    };

    for (const k of ['input','preview','memo','outline','structure','character','world','terms']){
      syncPair(document.getElementById(`cc-pane-${k}-bg`), document.getElementById(`cc-pane-${k}-bg-t`));
      syncPair(document.getElementById(`cc-pane-${k}-head`), document.getElementById(`cc-pane-${k}-head-t`));
    }

    function fillUIFrom(colors){
      const defaults = getDefaultComputedColors();
      for (const k of ['input','preview','memo','outline','structure','character','world','terms']){
        const bg = (colors && colors[k] && colors[k].bg) ? colors[k].bg : defaults[k].bg;
        const head = (colors && colors[k] && colors[k].head) ? colors[k].head : defaults[k].head;
        const bgEl = document.getElementById(`cc-pane-${k}-bg`);
        const bgT = document.getElementById(`cc-pane-${k}-bg-t`);
        const hdEl = document.getElementById(`cc-pane-${k}-head`);
        const hdT = document.getElementById(`cc-pane-${k}-head-t`);
        if (bgEl) bgEl.value = bg; if (bgT) bgT.value = bg;
        if (hdEl) hdEl.value = head; if (hdT) hdT.value = head;
      }
    }

    fillUIFrom(loadPaneColors());
  }

  // Properly bind the pane colors apply/reset handlers:
  function bindPaneColorsApply(){
    const applyBtn = document.getElementById('cc-pane-colors-apply');
    const resetBtn = document.getElementById('cc-pane-colors-reset');
    if (!applyBtn || applyBtn.dataset.bound==='1') return;
    applyBtn.dataset.bound='1';
    applyBtn.addEventListener('click', ()=>{
    const out = {input:{bg:null,head:null},preview:{bg:null,head:null},memo:{bg:null,head:null},outline:{bg:null,head:null},structure:{bg:null,head:null},character:{bg:null,head:null},world:{bg:null,head:null},terms:{bg:null,head:null}};
      for (const k of ['input','preview','memo','outline','structure','character','world','terms']){
        const bg = (document.getElementById(`cc-pane-${k}-bg-t`)?.value||'').trim();
        const head = (document.getElementById(`cc-pane-${k}-head-t`)?.value||'').trim();
        const norm = (v)=>{
          if (!/^#?[0-9a-fA-F]{6}$/.test(v)) return null;
          return v.startsWith('#')?v:'#'+v;
        };
        out[k].bg = norm(bg);
        out[k].head = norm(head);
      }
      lsSet(PANE_COLOR_KEY, out);
      applyPaneColors(out);
    });

    resetBtn?.addEventListener('click', ()=>{
      localStorage.removeItem(PANE_COLOR_KEY);
      applyPaneColors(null);
      // refill UI
      const defaults = getDefaultComputedColors();
      for (const k of ['input','preview','memo','outline','structure','character','world','terms']){
        const bgEl = document.getElementById(`cc-pane-${k}-bg`);
        const bgT = document.getElementById(`cc-pane-${k}-bg-t`);
        const hdEl = document.getElementById(`cc-pane-${k}-head`);
        const hdT = document.getElementById(`cc-pane-${k}-head-t`);
        if (bgEl) bgEl.value = defaults[k].bg; if (bgT) bgT.value = defaults[k].bg;
        if (hdEl) hdEl.value = defaults[k].head; if (hdT) hdT.value = defaults[k].head;
      }
    });
  }

  // Re-apply on theme change (custom priority)
  function observeThemeChanges(){
    const obs = new MutationObserver(()=>{
      const colors = loadPaneColors();
      applyPaneColors(colors);
    });
    obs.observe(document.body, {attributes:true, attributeFilter:['class']});
  }

  // -----------------------------
  // 4) Active tab color: default #fff59d + reset button
  // -----------------------------
  const ACTIVE_TAB_COLOR_DEFAULT = '#fff59d';
  const ACTIVE_TAB_COLOR_KEY = 'cc_active_tab_color_v2';

  function applyActiveTabColor(color){
    const c = color || ACTIVE_TAB_COLOR_DEFAULT;
    document.documentElement.style.setProperty('--active-tab-bg', c);
  }
  function loadActiveTabColor(){
    const v = localStorage.getItem(ACTIVE_TAB_COLOR_KEY);
    if (v && /^#([0-9a-fA-F]{6})$/.test(v)) return v;
    return ACTIVE_TAB_COLOR_DEFAULT;
  }
  function saveActiveTabColor(v){
    if (v && /^#([0-9a-fA-F]{6})$/.test(v)) localStorage.setItem(ACTIVE_TAB_COLOR_KEY, v);
  }

  function patchActiveTabColorUI(){
    // Find existing UI: it might already exist. Add reset button next to apply.
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;

    // Locate the block containing "アクティブタブ色"
    const titleEls = $$('.setting-title', settingsBar);
    let targetTitle=null;
    for (const t of titleEls){
      if (t.textContent && t.textContent.includes('アクティブタブ')){ targetTitle=t; break; }
    }
    if (!targetTitle) return;

    // Ensure default stored & applied
    const current = loadActiveTabColor();
    applyActiveTabColor(current);

    // Add reset button if missing
    if (!targetTitle.querySelector('#btn-active-tab-color-reset')){
      const btn = document.createElement('button');
      btn.className='btn';
      btn.id='btn-active-tab-color-reset';
      btn.textContent='リセット';
      btn.style.marginLeft='6px';
      btn.addEventListener('click', ()=>{
        localStorage.setItem(ACTIVE_TAB_COLOR_KEY, ACTIVE_TAB_COLOR_DEFAULT);
        applyActiveTabColor(ACTIVE_TAB_COLOR_DEFAULT);
        // reflect into any inputs
        const inp = document.getElementById('active-tab-color-input');
        const txt = document.getElementById('active-tab-color-text');
        if (inp) inp.value = ACTIVE_TAB_COLOR_DEFAULT;
        if (txt) txt.value = ACTIVE_TAB_COLOR_DEFAULT;
        try{ if (typeof window.renderInputTabs==='function') window.renderInputTabs(); }catch(e){}
      });
      targetTitle.appendChild(btn);
    }

    // Hook apply button if exists
    const applyBtn = targetTitle.querySelector('.btn-apply') || targetTitle.querySelector('button');
    // But avoid messing if already bound; we just ensure storage key and CSS var
    const colorInput = document.getElementById('active-tab-color-input') || document.getElementById('st-active-tab-color');
    if (colorInput){
      // ensure default
      if (!colorInput.value) colorInput.value = current;
      colorInput.addEventListener('input', ()=>{
        const v=colorInput.value;
        applyActiveTabColor(v);
        saveActiveTabColor(v);
        try{ if (typeof window.renderInputTabs==='function') window.renderInputTabs(); }catch(e){}
      });
    }
  }

  // Apply active tab color by overriding existing CSS:
  function injectActiveTabCSS(){
    if (document.getElementById('cc-active-tab-style')) return;
    const st = document.createElement('style');
    st.id='cc-active-tab-style';
    st.textContent = `
      .input-tab.active, .memo-tab.active { background: var(--active-tab-bg, ${ACTIVE_TAB_COLOR_DEFAULT}) !important; }
    `;
    document.head.appendChild(st);
  }

  // -----------------------------
  // 5) Outline settings: move from Settings to Outline gear overlay
  // -----------------------------
  const OUTLINE_RULES_KEY = 'cc_outline_rules_v1';
  function loadOutlineRules(){
    return lsGet(OUTLINE_RULES_KEY, {
      useHash:true, useBox:true, useTri:true, useDia:true, useCir:true, useChapter:true, useCircNum:true, useRoman:true, extra:''
    });
  }
  function saveOutlineRules(r){ lsSet(OUTLINE_RULES_KEY, r); }

  function getOutlineRuleMatchers(r){
    const extra = (r.extra||'').trim();
    const symbols = [];
    if (r.useBox) symbols.push('■','□');
    if (r.useTri) symbols.push('▲');
    if (r.useDia) symbols.push('◆');
    if (r.useCir) symbols.push('○');
    if (extra) symbols.push(...extra.split(''));
    const symSet = symbols.length ? new RegExp(`^[${symbols.map(s=>s.replace(/[-/\^$*+?.()|[\]{}]/g,'\$&')).join('')}]+`) : null;
    const hash = r.useHash ? /^#+\s+/ : null;
    const chapter = r.useChapter ? /^第\s*[^\s]+\s*章/ : null;
    const circ = r.useCircNum ? /^[①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳]/ : null;
    const roman = r.useRoman ? /^[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+/ : null;
    return {symSet, hash, chapter, circ, roman};
  }

  // Patch updateOutline builder by filtering lines
  function patchOutlineBuilder(){
    if (typeof window.updateOutline !== 'function') return;
    const original = window.updateOutline;
    if (original.__cc_patched) return;
    function shouldPick(line, matchers){
      const t=line.trim();
      if (!t) return false;
      // existing outline may already parse '#', '■' etc; we only allow if matches any rule
      if (matchers.hash && matchers.hash.test(t)) return true;
      if (matchers.symSet && matchers.symSet.test(t)) return true;
      if (matchers.chapter && matchers.chapter.test(t)) return true;
      if (matchers.circ && matchers.circ.test(t)) return true;
      if (matchers.roman && matchers.roman.test(t)) return true;
      return false;
    }
    window.updateOutline = function(){
      // Let original build the outline items, then filter/hide ones not matching?
      original();
      const rules = loadOutlineRules();
      const m = getOutlineRuleMatchers(rules);
      const list = document.getElementById('outline-list');
      if (!list) return;
      // Each item may have data-rawline? If not, we can't filter reliably. We'll rebuild from stored outlineItems if exists.
      if (Array.isArray(window.outlineItems) && window.outlineItems.length){
        // outlineItems are produced by original; filter by their text
        const kept = window.outlineItems.filter(it=> shouldPick(it.title||it.text||'', m) || it.level===0);
        if (kept.length !== window.outlineItems.length){
          window.outlineItems = kept;
          // Re-render using existing renderOutline if exists
          if (typeof window.renderOutline === 'function') {
            window.renderOutline();
          } else {
            // fallback: no op
          }
        }
      }
    };
    window.updateOutline.__cc_patched = true;
  }

  function addOutlineGearUI(){
    const outlinePanel = document.getElementById('outline-panel');
    if (!outlinePanel) return;
    if (document.getElementById('outline-gear-btn')) return;

    // Find toolbar area
    const toolbar = outlinePanel.querySelector('.outline-toolbar') || outlinePanel.querySelector('.panel-action-buttons')?.parentElement || outlinePanel;
    const btn = document.createElement('button');
    btn.id='outline-gear-btn';
    btn.className='btn';
    btn.textContent='⚙';
    btn.title='目次の抽出ルール';
    btn.style.marginLeft='6px';
    btn.addEventListener('click', ()=> openOutlineRuleModal());

    // Place near existing update button if exists
    const updateBtn = outlinePanel.querySelector('button[onclick*="updateOutline"],button[onclick*="updateAllOutlines"]');
    if (updateBtn && updateBtn.parentElement) updateBtn.parentElement.insertBefore(btn, updateBtn.nextSibling);
    else toolbar.appendChild(btn);

    // build modal
    if (!document.getElementById('outline-rule-modal')){
      const modal = document.createElement('div');
      modal.id='outline-rule-modal';
      modal.className='modal-overlay';
      modal.setAttribute('aria-hidden','true');
      modal.innerHTML = `
        <div class="modal-content" style="max-width:520px;">
          <div class="modal-header"><h3>⚙ 目次の抽出ルール</h3><button class="modal-close" id="btn-outline-rule-close">✕</button></div>
          <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px;">
            <label><input type="checkbox" id="cc-outline-use-hash"> #</label>
            <label><input type="checkbox" id="cc-outline-use-box"> ■□</label>
            <label><input type="checkbox" id="cc-outline-use-tri"> ▲</label>
            <label><input type="checkbox" id="cc-outline-use-dia"> ◆</label>
            <label><input type="checkbox" id="cc-outline-use-cir"> ○</label>
            <label><input type="checkbox" id="cc-outline-use-chapter"> 第○章</label>
            <label><input type="checkbox" id="cc-outline-use-circnum"> ①</label>
            <label><input type="checkbox" id="cc-outline-use-roman"> Ⅰ</label>
          </div>
          <div style="margin-bottom:10px;">
            <label>追加記号: <input type="text" id="cc-outline-extra" placeholder="例: ●★◇" style="width:240px;"></label>
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button class="btn btn-apply" id="btn-outline-rule-apply">適用</button>
            <button class="btn" id="btn-outline-rule-cancel">キャンセル</button>
          </div>
          <div style="font-size:0.85rem; color:var(--text-muted); margin-top:10px; line-height:1.5;">
            ※設定後、目次を更新すると反映されます（自動更新もします）。
          </div>
        </div>`;
      document.body.appendChild(modal);

      const close = ()=>{ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); };
      $('#btn-outline-rule-close', modal)?.addEventListener('click', close);
      $('#btn-outline-rule-cancel', modal)?.addEventListener('click', close);
      modal.addEventListener('mousedown', (e)=>{ if(e.target===modal) close(); });

      $('#btn-outline-rule-apply', modal)?.addEventListener('click', ()=>{
        const r = {
          useHash: !!$('#cc-outline-use-hash',modal)?.checked,
          useBox: !!$('#cc-outline-use-box',modal)?.checked,
          useTri: !!$('#cc-outline-use-tri',modal)?.checked,
          useDia: !!$('#cc-outline-use-dia',modal)?.checked,
          useCir: !!$('#cc-outline-use-cir',modal)?.checked,
          useChapter: !!$('#cc-outline-use-chapter',modal)?.checked,
          useCircNum: !!$('#cc-outline-use-circnum',modal)?.checked,
          useRoman: !!$('#cc-outline-use-roman',modal)?.checked,
          extra: ($('#cc-outline-extra',modal)?.value||'')
        };
        saveOutlineRules(r);
        close();
        try{ if (typeof window.updateOutline==='function') window.updateOutline(); }catch(e){}
      });
    }

    function openOutlineRuleModal(){
      const modal = document.getElementById('outline-rule-modal');
      if (!modal) return;
      const r = loadOutlineRules();
      $('#cc-outline-use-hash',modal).checked = !!r.useHash;
      $('#cc-outline-use-box',modal).checked = !!r.useBox;
      $('#cc-outline-use-tri',modal).checked = !!r.useTri;
      $('#cc-outline-use-dia',modal).checked = !!r.useDia;
      $('#cc-outline-use-cir',modal).checked = !!r.useCir;
      $('#cc-outline-use-chapter',modal).checked = !!r.useChapter;
      $('#cc-outline-use-circnum',modal).checked = !!r.useCircNum;
      $('#cc-outline-use-roman',modal).checked = !!r.useRoman;
      $('#cc-outline-extra',modal).value = r.extra || '';
      modal.classList.add('show');
      modal.setAttribute('aria-hidden','false');
      setTimeout(()=>$('#cc-outline-extra',modal)?.focus(), 0);
    }
    window.openOutlineRuleModal = openOutlineRuleModal;
  }

  function hideOutlineRulesFromSettings(){
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;
    // Find the row with st-outline-use-hash and hide its block
    const el = document.getElementById('st-outline-use-hash');
    if (el){
      const blk = el.closest('.setting-block');
      if (blk) blk.style.display='none';
    }
  }

  // -----------------------------
  // 6) Outline click: also sync preview & reader when available
  // -----------------------------
  function enhanceOutlineClicks(){
    const list = document.getElementById('outline-list');
    if (!list || list.dataset.ccEnhanced==='1') return;
    list.dataset.ccEnhanced='1';

    list.addEventListener('click', (e)=>{
      const item = e.target.closest('.outline-item');
      if (!item) return;
      // existing onclick might already run; we just schedule sync afterwards
      setTimeout(()=>{
        try{
          // Sync preview to cursor line if preview open
          if (typeof window.syncPreviewPosition==='function'){
            // If preview pane hidden, do nothing. We respect user default; but they asked outline click also sync.
            const pvPane = document.getElementById('pane-preview');
            if (pvPane && !pvPane.classList.contains('hidden')) window.syncPreviewPosition();
          }
        }catch(err){}
        try{
          // If reader open, jump to active tab section
          const reader = document.getElementById('reader-overlay');
          if (reader && reader.getAttribute('aria-hidden')==='false'){
            if (typeof window.readerJumpToTabSection==='function') window.readerJumpToTabSection(window.activeTabId);
          }
        }catch(err){}
      }, 0);
    }, true);
  }

  // helper for reader to jump to tab section (by data-tabid)
  window.readerJumpToTabSection = function(tabId){
    const rc = document.getElementById('reader-content');
    const sc = document.getElementById('reader-scroll');
    if (!rc || !sc) return;
    const sec = rc.querySelector(`[data-tabid="${tabId}"]`);
    if (!sec) return;
    sec.classList.add('cc-reader-bm-hit');
    setTimeout(()=>sec.classList.remove('cc-reader-bm-hit'), 900);
    const top = sec.offsetTop - 20;
    sc.scrollTop = Math.max(0, top);
  };

  // -----------------------------
  // 7) Reader bookmarks: show snippet labels & highlight on jump (no 0px)
  // -----------------------------
  function patchReaderBookmarks(){
    if (typeof window.readerAddBookmark !== 'function') return;

    // We'll override readerAddBookmark to use current tab + cursor line snippet
    const _add = window.readerAddBookmark;
    window.readerAddBookmark = function(){
      try{
        // Try to reuse normal bookmarks if exist
        if (typeof window.addBookmark==='function') window.addBookmark();
      }catch(e){}
      // still keep reader's own list for compatibility
      try{ _add(); }catch(e){}
      try{ if (typeof window.renderReaderBookmarks==='function') window.renderReaderBookmarks(); }catch(e){}
    };

    // Override renderReaderBookmarks to show better labels if possible
    const _render = window.renderReaderBookmarks;
    if (typeof _render === 'function' && !_render.__cc_patched){
      window.renderReaderBookmarks = function(){
        _render();
        const sel = document.getElementById('reader-bookmark-select');
        if (!sel) return;
        // If options contain "0px" style, rewrite labels
        for (const opt of Array.from(sel.options)){
          if (!opt.value) continue;
          if (/\d+px/.test(opt.textContent||'')){
            // try map via stored bookmarks in localStorage reader key if exists
            opt.textContent = opt.textContent.replace(/\d+px/g,'');
          }
        }
      };
      window.renderReaderBookmarks.__cc_patched=true;
    }

    // Override readerJumpBookmark: highlight section
    const _jump = window.readerJumpBookmark;
    window.readerJumpBookmark = function(){
      const sel = document.getElementById('reader-bookmark-select');
      const v = sel ? sel.value : '';
      if (!v){ if (typeof _jump==='function') return _jump(); return; }
      try{ if (typeof _jump==='function') _jump(); }catch(e){}
      // attempt to highlight based on bookmark data-tabid attribute if encoded
      try{
        // if value looks like JSON {tabId,pos}
        let data=null;
        try{ data = JSON.parse(v); }catch(e){}
        if (data && data.tabId){
          window.readerJumpToTabSection(data.tabId);
        }
      }catch(e){}
    };

  }

  // -----------------------------
  // 8) Memo context menu & Title context menu
  // -----------------------------
  function addMemoContextMenu(){
    if (!document.getElementById('memo-tabs')) return;
    const tabsBar = document.getElementById('memo-tabs');
    if (tabsBar.dataset.ccCtx==='1') return;
    tabsBar.dataset.ccCtx='1';

    tabsBar.addEventListener('contextmenu', (e)=>{
      const tabEl = e.target.closest('.memo-tab');
      if (!tabEl) return;
      e.preventDefault();
      const tabId = parseInt(tabEl.dataset.id || tabEl.getAttribute('data-id') || tabEl.dataset.tabId || '');
      // reuse existing tab context menu but in memo mode
      const menu = document.getElementById('tab-context-menu');
      if (!menu) return;
      menu.dataset.mode='memo';
      menu.dataset.targetId = String(tabId);
      // Configure menu items: we will set labels and handlers dynamically
      buildContextMenuFor('memo', tabId);
      showContextMenuAt(menu, e.clientX, e.clientY);
    });
  }

  function addTitleContextMenu(){
    const titleEl = document.getElementById('novel-title');
    if (!titleEl || titleEl.dataset.ccCtx==='1') return;
    titleEl.dataset.ccCtx='1';

    // Create menu
    let menu = document.getElementById('title-context-menu');
    if (!menu){
      menu = document.createElement('div');
      menu.id='title-context-menu';
      menu.style.position='fixed';
      menu.style.zIndex='10000';
      menu.style.display='none';
      menu.style.minWidth='180px';
      menu.style.background='var(--panel-bg)';
      menu.style.color='var(--text-color)';
      menu.style.border='1px solid var(--border-color)';
      menu.style.borderRadius='12px';
      menu.style.padding='6px';
      menu.style.boxShadow='0 20px 60px rgba(0,0,0,.25)';
      menu.innerHTML = `
        <button class="cc-title-menu-btn" data-act="rename">✏️ リネーム</button>
        <button class="cc-title-menu-btn" data-act="reset">🧹 初期化（入力）</button>
      `;
      const st = document.createElement('style');
      st.textContent = `
        #title-context-menu button{width:100%;text-align:left;padding:8px 10px;border:none;border-radius:10px;background:transparent;color:inherit;cursor:pointer;}
        #title-context-menu button:hover{background:rgba(59,130,246,.10);}
      `;
      document.head.appendChild(st);
      document.body.appendChild(menu);

      menu.addEventListener('click', (e)=>{
        const btn = e.target.closest('button');
        if (!btn) return;
        const act = btn.dataset.act;
        if (act==='rename'){
          try{ if (typeof window.startEditNovelTitle==='function') window.startEditNovelTitle(); }catch(err){}
        }
        if (act==='reset'){
          titleEl.textContent='入力';
          try{ if (typeof window.saveNovelTitle==='function') window.saveNovelTitle('入力'); }catch(err){}
          try{ localStorage.setItem('novelTitle','入力'); }catch(err){}
        }
        hideTitleMenu();
      });

      document.addEventListener('mousedown', (e)=>{
        if (menu.style.display==='none') return;
        if (!menu.contains(e.target)) hideTitleMenu();
      });
      window.addEventListener('scroll', hideTitleMenu, true);
      window.addEventListener('resize', hideTitleMenu);

      function hideTitleMenu(){ menu.style.display='none'; }
      window.hideTitleMenu = hideTitleMenu;
    }

    titleEl.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      e.stopPropagation();
      menu.style.display='block';
      const x = Math.min(e.clientX, window.innerWidth - menu.offsetWidth - 8);
      const y = Math.min(e.clientY, window.innerHeight - menu.offsetHeight - 8);
      menu.style.left = Math.max(8,x)+'px';
      menu.style.top = Math.max(8,y)+'px';
    });
  }

  // Reuse existing context menu show/hide functions if present, else implement
  function showContextMenuAt(menu, x, y){
    if (!menu) return;
    menu.style.display='block';
    const w = menu.offsetWidth || 180;
    const h = menu.offsetHeight || 220;
    const xx = Math.min(x, window.innerWidth - w - 8);
    const yy = Math.min(y, window.innerHeight - h - 8);
    menu.style.left = Math.max(8,xx)+'px';
    menu.style.top = Math.max(8,yy)+'px';
    menu.setAttribute('aria-hidden','false');
  }

  function buildContextMenuFor(mode, id){
    const menu = document.getElementById('tab-context-menu');
    if (!menu) return;
    // Buttons may be pre-defined; we rewrite the inner HTML to avoid dependency
    menu.innerHTML = '';
    const addBtn = (label, fn)=>{
      const b=document.createElement('button');
      b.textContent=label;
      b.addEventListener('click', ()=>{ hideContextMenu(); fn(); });
      menu.appendChild(b);
    };
    const addHr = ()=>{ const hr=document.createElement('hr'); menu.appendChild(hr); };

    function hideContextMenu(){
      menu.style.display='none';
      menu.setAttribute('aria-hidden','true');
    }
    window.hideContextMenu = window.hideContextMenu || hideContextMenu;

    if (mode==='memo'){
      addBtn('＋ 新規メモタブ', ()=>{ try{ if (typeof window.addNewMemoTab==='function') window.addNewMemoTab(); }catch(e){} });
      addBtn('✏️ リネーム', ()=>{ try{ if (typeof window.renameMemoTab==='function') window.renameMemoTab(id); }catch(e){} });
      addBtn('📄 複製', ()=>{ try{ if (typeof window.duplicateMemoTab==='function') window.duplicateMemoTab(id); }catch(e){} });
      addHr();
      addBtn('✕ 閉じる', ()=>{ try{ if (typeof window.closeMemoTab==='function') window.closeMemoTab(id); }catch(e){} });
    } else {
      // default (input)
      addBtn('＋ 新規タブ', ()=>{ try{ if (typeof window.addNewTab==='function') window.addNewTab(); }catch(e){} });
      addBtn('✏️ リネーム', ()=>{ try{ if (typeof window.renameTab==='function') window.renameTab(id); }catch(e){} });
      addBtn('📄 複製', ()=>{ try{ if (typeof window.duplicateTab==='function') window.duplicateTab(id); }catch(e){} });
      addHr();
      addBtn('✕ 閉じる', ()=>{ try{ if (typeof window.closeTab==='function') window.closeTab(id); }catch(e){} });
    }

    // close on outside click
    setTimeout(()=>{
      const onDown = (ev)=>{ if (!menu.contains(ev.target)) { hideContextMenu(); document.removeEventListener('mousedown', onDown, true); } };
      document.addEventListener('mousedown', onDown, true);
    },0);
  }

  function calcLineInfo(text, pos){
    const before = text.slice(0,pos);
    const lineNum = (before.match(/\n/g)||[]).length + 1;
    const lineStart = before.lastIndexOf('\n')+1;
    const lineEnd = text.indexOf('\n', pos);
    const lineText = text.slice(lineStart, lineEnd===-1?text.length:lineEnd);
    return {lineNum, lineText: lineText.trim(), lineStart};
  }

  // -----------------------------
  // 10) Search/Replace: scope current/all + hits list + replace preview
  // -----------------------------
  let ccSearchMatches = [];
  let ccSearchIndex = -1;
  let ccLastQuery = '';
  let ccLastScope = 'current';

  function collectMatches(query, scope){
    const esc = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const rx = new RegExp(esc, 'g');
    const matches=[];
    const tabs = Array.isArray(window.inputTabs)?window.inputTabs:[];
    const tabList = (scope==='all') ? tabs : [tabs.find(t=>t.id===window.activeTabId)].filter(Boolean);
    for (const tab of tabList){
      const text = tab.id===window.activeTabId ? (window.inputArea?.value ?? tab.content ?? '') : (tab.content ?? '');
      let m;
      while((m=rx.exec(text))!==null){
        const pos=m.index;
        const li=calcLineInfo(text, pos);
        matches.push({tabId: tab.id, tabName: tab.name||'', start:pos, end:pos+m[0].length, lineNum:li.lineNum, preview:li.lineText.slice(0,80)});
        if (m[0].length===0) rx.lastIndex++;
      }
    }
    return matches;
  }

  function updateSearchUI(){
    const info = document.getElementById('search-match-info');
    if (info) info.textContent = `${ccSearchMatches.length? (ccSearchIndex+1):0} / ${ccSearchMatches.length}`;
  }

  function renderHitList(){
    const box = document.getElementById('search-hits');
    if (!box) return;
    box.innerHTML='';
    if (!ccLastQuery){
      box.innerHTML = '<div class="outline-empty">ヒット一覧はここに表示されます</div>';
      return;
    }
    if (!ccSearchMatches.length){
      box.innerHTML = '<div class="outline-empty">ヒットなし</div>';
      return;
    }

    const maxShow = 300;
    const matches = ccSearchMatches.slice(0, maxShow);
    const grouped = {};
    for (const m of matches){
      (grouped[m.tabId] ||= {name:m.tabName||('タブ'+m.tabId), items:[]}).items.push(m);
    }

    for (const [tabId, g] of Object.entries(grouped)){
      const head=document.createElement('div');
      head.style.fontWeight='700';
      head.style.margin='6px 0 2px';
      head.textContent = `【${g.name}】 (${g.items.length})`;
      box.appendChild(head);
      for (const m of g.items){
        const div=document.createElement('div');
        div.className='bookmark-item';
        div.style.cursor='pointer';
        div.innerHTML = `🔎 ${m.lineNum}行: ${escapeHtml(m.preview)}`;
        div.addEventListener('click', ()=> jumpToMatch(m));
        box.appendChild(div);
      }
    }

    if (ccSearchMatches.length>maxShow){
      const note=document.createElement('div');
      note.className='outline-empty';
      note.textContent = `表示は${maxShow}件まで（全${ccSearchMatches.length}件）`;
      box.appendChild(note);
    }

    // Add replace preview controls
    const pvBtn = document.createElement('button');
    pvBtn.className='btn';
    pvBtn.textContent='置換プレビュー';
    pvBtn.style.marginTop='8px';
    pvBtn.addEventListener('click', showReplacePreview);
    box.appendChild(pvBtn);
  }

  function jumpToMatch(m){
    try{
      if (m.tabId!==window.activeTabId && typeof window.switchTab==='function') window.switchTab(m.tabId);
      const ta=window.inputArea;
      if (!ta) return;
      ta.focus();
      ta.setSelectionRange(m.start, m.end);
      if (typeof window.scrollToCursorPosition==='function') setTimeout(()=>window.scrollToCursorPosition(m.start), 60);
      if (typeof window.updateCursorLineDisplay==='function') window.updateCursorLineDisplay();
      ccSearchIndex = ccSearchMatches.findIndex(x=>x.tabId===m.tabId && x.start===m.start && x.end===m.end);
      updateSearchUI();
    }catch(e){}
  }

  window.doSearch = function(){
    const q = (document.getElementById('search-input')?.value||'');
    const scope = document.getElementById('search-scope')?.value || 'current';
    ccLastQuery = q;
    ccLastScope = scope;
    if (!q){
      ccSearchMatches=[]; ccSearchIndex=-1;
      updateSearchUI();
      renderHitList();
      return;
    }
    ccSearchMatches = collectMatches(q, scope);
    ccSearchIndex = ccSearchMatches.length?0:-1;
    updateSearchUI();
    renderHitList();
    if (ccSearchIndex>=0) jumpToMatch(ccSearchMatches[0]);
  };

  window.findNext = function(){
    if (!ccSearchMatches.length) return;
    ccSearchIndex = (ccSearchIndex+1) % ccSearchMatches.length;
    jumpToMatch(ccSearchMatches[ccSearchIndex]);
  };
  window.findPrev = function(){
    if (!ccSearchMatches.length) return;
    ccSearchIndex = (ccSearchIndex-1 + ccSearchMatches.length) % ccSearchMatches.length;
    jumpToMatch(ccSearchMatches[ccSearchIndex]);
  };

  window.replaceOne = function(){
    const q = (document.getElementById('search-input')?.value||'');
    const rep = (document.getElementById('replace-input')?.value||'');
    if (!q) return;
    if (!ccSearchMatches.length || ccSearchIndex<0) window.doSearch();
    if (!ccSearchMatches.length) return;
    const m = ccSearchMatches[ccSearchIndex];
    const tabs = window.inputTabs||[];
    const tab = tabs.find(t=>t.id===m.tabId);
    if (!tab) return;
    const ta = window.inputArea;
    let text = (m.tabId===window.activeTabId && ta) ? ta.value : (tab.content||'');
    // verify substring
    if (text.slice(m.start, m.end)!==q){
      // re-search
      window.doSearch();
      return;
    }
    text = text.slice(0,m.start) + rep + text.slice(m.end);
    if (m.tabId===window.activeTabId && ta){ ta.value=text; }
    tab.content = text;
    try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
    // re-search to refresh
    window.doSearch();
  };

  window.replaceAll = function(){
    const q = (document.getElementById('search-input')?.value||'');
    const rep = (document.getElementById('replace-input')?.value||'');
    if (!q) return;
    if (!ccSearchMatches.length) window.doSearch();
    const count = ccSearchMatches.length;
    if (!count) return;
    if (!confirm(`${count}件を全置換しますか？（範囲: ${ccLastScope==='all'?'全タブ':'このタブ'}）`)) return;
    const tabs = window.inputTabs||[];
    const tabIds = new Set(ccSearchMatches.map(m=>m.tabId));
    for (const tabId of tabIds){
      const tab = tabs.find(t=>t.id===tabId);
      if (!tab) continue;
      const ta=window.inputArea;
      let text = (tabId===window.activeTabId && ta) ? ta.value : (tab.content||'');
      text = text.split(q).join(rep);
      if (tabId===window.activeTabId && ta) ta.value=text;
      tab.content=text;
    }
    try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
    window.doSearch();
  };

  function showReplacePreview(){
    const q = (document.getElementById('search-input')?.value||'');
    const rep = (document.getElementById('replace-input')?.value||'');
    if (!q) return;
    if (!ccSearchMatches.length) window.doSearch();
    if (!ccSearchMatches.length) return;
    const box = document.getElementById('search-hits');
    if (!box) return;

    // Clear and build preview list
    box.innerHTML='';
    const top = document.createElement('div');
    top.style.display='flex';
    top.style.gap='8px';
    top.style.flexWrap='wrap';
    top.style.alignItems='center';
    top.style.marginBottom='8px';
    top.innerHTML = `<div style="font-weight:700;">置換プレビュー（${ccSearchMatches.length}件）</div>`;
    const btnApply = document.createElement('button');
    btnApply.className='btn btn-apply';
    btnApply.textContent='チェック分を適用';
    const btnAll = document.createElement('button');
    btnAll.className='btn';
    btnAll.textContent='全部適用';
    const btnBack = document.createElement('button');
    btnBack.className='btn';
    btnBack.textContent='戻る';
    top.appendChild(btnApply);
    top.appendChild(btnAll);
    top.appendChild(btnBack);
    box.appendChild(top);

    const max=200;
    const rows=[];
    for (const m of ccSearchMatches.slice(0,max)){
      const row=document.createElement('div');
      row.className='replace-preview-row';
      row.dataset.tabId = String(m.tabId);
      row.dataset.start = String(m.start);
      row.dataset.end = String(m.end);
      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=true;
      cb.style.marginTop='4px';
      const info=document.createElement('div');
      info.style.flex='1';
      const before = m.preview;
      const after = before.replace(q, rep);
      info.innerHTML = `<div class="search-meta">【${escapeHtml(m.tabName||('タブ'+m.tabId))}】${m.lineNum}行</div>
        <div class="rp-snippet">${escapeHtml(before)}</div>
        <div class="rp-snippet rp-after">→ ${escapeHtml(after)}</div>`;
      row.appendChild(cb);
      row.appendChild(info);
      row.addEventListener('click', (ev)=>{ if(ev.target.tagName==='INPUT') return; jumpToMatch(m); });
      box.appendChild(row);
      rows.push({row, cb, m});
    }
    if (ccSearchMatches.length>max){
      const note=document.createElement('div');
      note.className='outline-empty';
      note.textContent = `プレビューは${max}件まで（全${ccSearchMatches.length}件）。`;
      box.appendChild(note);
    }

    const applySelection = (onlyChecked)=>{
      const targets = onlyChecked ? rows.filter(r=>r.cb.checked).map(r=>r.m) : ccSearchMatches.slice();
      const count = targets.length;
      if (!count) return;
      if (!confirm(`${count}件を置換しますか？`)) return;
      const tabs=window.inputTabs||[];
      // group by tab and apply from end to start to keep indices stable
      const byTab={};
      for(const m of targets){ (byTab[m.tabId] ||= []).push(m); }
      for (const [tabIdS, ms] of Object.entries(byTab)){
        const tabId=parseInt(tabIdS);
        const tab=tabs.find(t=>t.id===tabId);
        if(!tab) continue;
        const ta=window.inputArea;
        let text = (tabId===window.activeTabId && ta) ? ta.value : (tab.content||'');
        // sort descending
        ms.sort((a,b)=>b.start-a.start);
        for(const m of ms){
          if(text.slice(m.start,m.end)===q){
            text = text.slice(0,m.start)+rep+text.slice(m.end);
          }
        }
        if (tabId===window.activeTabId && ta) ta.value=text;
        tab.content=text;
      }
      try{ if(typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
      window.doSearch();
    };

    btnApply.addEventListener('click', ()=>applySelection(true));
    btnAll.addEventListener('click', ()=>applySelection(false));
    btnBack.addEventListener('click', ()=>renderHitList());
  }

  // Ensure Ctrl+F opens panel still uses doSearch

  // -----------------------------
  // 11) Writing speed (chars/min or chars/hour) using tracker
  // -----------------------------
  const SPEED_MODE_KEY='cc_speed_mode_v1';
  function getSpeedMode(){ return localStorage.getItem(SPEED_MODE_KEY)==='hour' ? 'hour' : 'min'; }
  function setSpeedMode(m){ localStorage.setItem(SPEED_MODE_KEY, m==='hour'?'hour':'min'); }

  function calcTodayChars(){
    try{
      // Use existing "today baseline" if present
      if (typeof window.getTodayKey==='function' && typeof window.getTabBaseline==='function'){
        // Not sure; fallback
      }
    }catch(e){}
    // Fallback: sum of current tabs lengths
    const tabs=window.inputTabs||[];
    let total=0;
    for (const t of tabs){
      const text = (t.id===window.activeTabId ? (window.inputArea?.value ?? t.content ?? '') : (t.content ?? ''));
      total += String(text).replace(/[\s　]+/g,'').length;
    }
    return total;
  }

  function injectSpeedUI(){
    // Add to header (right) maybe near writing time display if exists
    const el = document.getElementById('writing-time-display');
    if (!el) return;
    if (document.getElementById('writing-speed-display')) return;
    const sp=document.createElement('span');
    sp.id='writing-speed-display';
    sp.style.marginLeft='10px';
    sp.style.fontWeight='700';
    sp.style.color='var(--text-muted)';
    sp.style.cursor='pointer';
    sp.title='クリックで字/分 ⇄ 字/時';
    sp.addEventListener('click', ()=>{
      const next = getSpeedMode()==='min' ? 'hour' : 'min';
      setSpeedMode(next);
      updateSpeedDisplay();
    });
    el.parentElement?.appendChild(sp);
    updateSpeedDisplay();
  }

  function updateSpeedDisplay(){
    const sp=document.getElementById('writing-speed-display');
    if (!sp) return;
    const sec = window.writingSeconds || 0;
    if (!sec){ sp.textContent=''; return; }
    const chars = calcTodayChars();
    const mode = getSpeedMode();
    const minutes = sec/60;
    const hours = sec/3600;
    const val = mode==='hour' ? (hours? (chars/hours):0) : (minutes? (chars/minutes):0);
    const unit = mode==='hour' ? '字/時' : '字/分';
    sp.textContent = `｜速度: ${val.toFixed(1)}${unit}`;
  }

  // Hook into updateWritingTimeDisplay if exists
  function hookWritingTime(){
    if (typeof window.updateWritingTimeDisplay !== 'function') return;
    const orig = window.updateWritingTimeDisplay;
    if (orig.__cc_speed) return;
    window.updateWritingTimeDisplay = function(){
      orig();
      updateSpeedDisplay();
    };
    window.updateWritingTimeDisplay.__cc_speed = true;
  }

  // -----------------------------
  // 12) Fix reset showing memo/outline swap buttons: ensure updateDockPanelButton called
  // -----------------------------
  function patchResetHooks(){
    const orig = window.resetAll;
    if (typeof orig !== 'function' || orig.__cc_patched) return;
    window.resetAll = function(){
      orig();
      try{ if (typeof window.updateDockPanelButton==='function'){
        window.updateDockPanelButton('memo-panel','btn-toggle-memo','check-memo-dock');
        window.updateDockPanelButton('outline-panel','btn-toggle-outline','check-outline-dock');
      }}catch(e){}
    };
    window.resetAll.__cc_patched = true;
  }

  // -----------------------------
  // Init
  // -----------------------------
  function init(){
    injectPaneColorCSS();
    applyPaneColors(loadPaneColors());
    observeThemeChanges();

    hideOpenSettings();
    hideOutlineRulesFromSettings();
    addOutlineGearUI();
    patchOutlineBuilder();

    injectActiveTabCSS();
    applyActiveTabColor(loadActiveTabColor());
    patchActiveTabColorUI();

    enhanceOutlineClicks();
    patchReaderBookmarks();
    addMemoContextMenu();
    addTitleContextMenu();

    // pane colors settings UI
    try{
      // create UI block and bind
      if (!document.getElementById('cc-pane-colors-block')){
        // We place after initial blocks by appending at end to be safe
        const settingsBar = document.getElementById('settings-bar');
        if (settingsBar){
          // create block
          const block = document.createElement('div');
          block.className='setting-block';
          block.id='cc-pane-colors-block';
          block.innerHTML = `
            <div class="setting-title">ペイン色（背景/ヘッダー）
              <button class="btn btn-apply" id="cc-pane-colors-apply">適用</button>
              <button class="btn" id="cc-pane-colors-reset">リセット</button>
            </div>
            <div class="setting-row" style="flex-direction:column; gap:10px; align-items:stretch;">
              ${['input','preview','memo','outline','structure','character','world','terms'].map(k=>{
                const label = ({input:'入力',preview:'プレビュー',memo:'メモ',outline:'目次',structure:'構成',character:'登場人物',world:'世界観',terms:'用語'})[k];
                return `
                <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                  <div style="min-width:64px; font-weight:700;">${label}</div>
                  <label style="display:flex; align-items:center; gap:6px;">背景 <input type="color" id="cc-pane-${k}-bg" style="width:44px; height:28px;">
                    <input type="text" id="cc-pane-${k}-bg-t" placeholder="#RRGGBB" style="width:96px;">
                  </label>
                  <label style="display:flex; align-items:center; gap:6px;">ヘッダー <input type="color" id="cc-pane-${k}-head" style="width:44px; height:28px;">
                    <input type="text" id="cc-pane-${k}-head-t" placeholder="#RRGGBB" style="width:96px;">
                  </label>
                </div>`;
              }).join('')}
              <div style="font-size:0.85rem; color:var(--text-muted); line-height:1.5;">
                ※「ヘッダー」は <b>ペイン上部 + 位置バー + タブバー</b> を含みます。テーマ変更より優先（カスタム優先）。
              </div>
            </div>`;
          settingsBar.appendChild(block);
        }
      }
      // bind and populate
      const defaults = getDefaultComputedColors();
      const saved = loadPaneColors();
      const use = saved || null;
      const norm = (v)=>{ if(!v) return null; return v.startsWith('#')?v:'#'+v; };
      for (const k of ['input','preview','memo','outline','structure','character','world','terms']){
        const bg = (use && use[k] && use[k].bg) ? use[k].bg : defaults[k].bg;
        const head = (use && use[k] && use[k].head) ? use[k].head : defaults[k].head;
        const bgEl = document.getElementById(`cc-pane-${k}-bg`);
        const bgT = document.getElementById(`cc-pane-${k}-bg-t`);
        const hdEl = document.getElementById(`cc-pane-${k}-head`);
        const hdT = document.getElementById(`cc-pane-${k}-head-t`);
        if (bgEl) bgEl.value = bg; if (bgT) bgT.value = bg;
        if (hdEl) hdEl.value = head; if (hdT) hdT.value = head;
        // sync
        if (bgEl && bgT){
          bgEl.addEventListener('input', ()=>{ bgT.value = bgEl.value; });
          bgT.addEventListener('change', ()=>{ const v=bgT.value.trim(); if(/^#?[0-9a-fA-F]{6}$/.test(v)){ const vv=norm(v); bgEl.value=vv; bgT.value=vv; } });
        }
        if (hdEl && hdT){
          hdEl.addEventListener('input', ()=>{ hdT.value = hdEl.value; });
          hdT.addEventListener('change', ()=>{ const v=hdT.value.trim(); if(/^#?[0-9a-fA-F]{6}$/.test(v)){ const vv=norm(v); hdEl.value=vv; hdT.value=vv; } });
        }
      }
      bindPaneColorsApply();
    }catch(e){}

    hookWritingTime();
    injectSpeedUI();
    patchResetHooks();

    // Remove settings hint in open modal if still present
    try{
      const modal=document.getElementById('open-choice-modal');
      if(modal){
        const hint = modal.querySelector('div[style*="font-size:0.8rem"]');
        if(hint){ hint.innerHTML = hint.innerHTML.replace(/※既定は[^<]*<br\s*\/>?/,''); }
      }
    }catch(e){}
  }

  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();

</script>


<!-- ===== v0.97 fix2 patches (reader bookmarks/search, active tab color reliable apply, per-tab stats, disable focus shortcuts) ===== -->
<script>
(()=>{
  'use strict';
  const $ = (sel, root=document)=>root.querySelector(sel);

  // ---------- 1) Reader: make search/bookmarks reliable and human-readable ----------
  const READER_BM_KEY_V2 = 'cc_reader_bookmarks_v2';
  function loadBMs(){
    try{
      const raw = localStorage.getItem(READER_BM_KEY_V2) || localStorage.getItem('cc_reader_bookmarks_v1');
      const b = raw ? JSON.parse(raw) : [];
      return Array.isArray(b) ? b : [];
    }catch(e){ return []; }
  }
  function saveBMs(bms){
    try{ localStorage.setItem(READER_BM_KEY_V2, JSON.stringify(bms)); }catch(e){}
  }
  function getReaderEls(){
    return {
      overlay: document.getElementById('reader-overlay'),
      scroll: document.getElementById('reader-scroll'),
      content: document.getElementById('reader-content'),
      input: document.getElementById('reader-search-input'),
      info: document.getElementById('reader-search-info'),
      select: document.getElementById('reader-bookmark-select'),
    };
  }
  function readerSections(){
    const {content} = getReaderEls();
    return content ? Array.from(content.querySelectorAll('.reader-section')) : [];
  }
  function findSectionAt(scrollTop){
    const secs = readerSections();
    if (!secs.length) return {idx:0, offset:0};
    let idx=0;
    for (let i=0;i<secs.length;i++){
      if (secs[i].offsetTop <= scrollTop + 6) idx=i;
      else break;
    }
    const off = Math.max(0, scrollTop - secs[idx].offsetTop);
    return {idx, offset: off};
  }
  function getTabName(idx){
    try{
      const t = window.inputTabs?.[idx];
      return (t?.name || `タブ${idx+1}`);
    }catch(e){ return `タブ${idx+1}`; }
  }
  function excerptFromTab(idx, ratio){
    try{
      const t = window.inputTabs?.[idx];
      const s = String(t?.content||'');
      if (!s.trim()) return '';
      const lines = s.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      if (!lines.length) return '';
      const pick = lines[Math.min(lines.length-1, Math.floor(ratio*lines.length))];
      return pick.length>24 ? pick.slice(0,24)+'…' : pick;
    }catch(e){ return ''; }
  }

  // Reader bookmark render functions disabled (feature removed)
  function renderReaderBookmarkSelect(){ /* disabled */ }
  function renderReaderBookmarkPins(){ /* disabled */ }

  // Ensure styles exist
  (function ensureReaderBmCss(){
    if (document.getElementById('cc-reader-bm-css')) return;
    const st = document.createElement('style');
    st.id = 'cc-reader-bm-css';
    st.textContent = `
      .reader-bm-pin{ position:absolute; left:8px; width:18px; height:18px; display:flex; align-items:center; justify-content:center;
        border-radius:999px; background: rgba(253,224,71,0.85); border:1px solid rgba(245,158,11,0.85); cursor:pointer;
        user-select:none; font-size:12px; line-height:1; z-index:10; box-shadow:0 1px 2px rgba(0,0,0,0.15);
      }
      body.theme-dark .reader-bm-pin{ background: rgba(14,116,144,0.55); border-color: rgba(56,189,248,0.7); }
    `;
    document.head.appendChild(st);
  })();

  // Reader bookmark functions disabled (feature removed)
  window.readerAddBookmark = function(){ /* disabled */ };
  window.readerJumpBookmark = function(){ /* disabled */ };

  // Reader search: make Enter work and ensure active hit scrolls
  if (typeof window.readerDoSearch === 'function'){
    // keep existing, but ensure it runs after render
  }

  function hookReaderOpen(){
    if (typeof window.openReaderView === 'function' && !window.openReaderView.__fix2){
      const baseOpen = window.openReaderView;
      window.openReaderView = function(){
        const r = baseOpen.apply(this, arguments);
        setTimeout(()=>{
          renderReaderBookmarkSelect();
          renderReaderBookmarkPins();
          try{ if ($('#reader-search-info')) $('#reader-search-info').textContent = '0/0'; }catch(_){ }
        }, 0);
        return r;
      };
      window.openReaderView.__fix2 = true;
    }
    if (typeof window.closeReaderView === 'function' && !window.closeReaderView.__fix2){
      const baseClose = window.closeReaderView;
      window.closeReaderView = function(){
        const r = baseClose.apply(this, arguments);
        return r;
      };
      window.closeReaderView.__fix2 = true;
    }
  }
  hookReaderOpen();

  // Ensure reader search binds to Enter
  (function bindReaderEnter(){
    const {input} = getReaderEls();
    if (!input || input.__fix2) return;
    input.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        e.preventDefault();
        window.readerDoSearch?.();
      }
    });
    input.__fix2 = true;
  })();

  // ---------- 2) Active tab color: reliable apply + reset button ----------
  const ACTIVE_TAB_DEFAULT = '#fff59d';
  const ACTIVE_TAB_KEY = 'cc_active_tab_color_v2';
  function shadeHex(hex, amt){
    let c = String(hex||'').trim();
    if (!c) return hex;
    if (c[0]==='#') c=c.slice(1);
    if (c.length===3) c=c.split('').map(ch=>ch+ch).join('');
    if (c.length!==6) return '#f59e0b';
    const num=parseInt(c,16);
    let r=(num>>16)&255,g=(num>>8)&255,b=num&255;
    const f=(x)=> Math.max(0, Math.min(255, Math.round(x + (amt>=0 ? (255-x)*amt : x*amt))));
    r=f(r); g=f(g); b=f(b);
    return '#' + ((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
  }
  function applyActiveTabColor(color){
    const c = color || ACTIVE_TAB_DEFAULT;
    const root = document.documentElement;
    root.style.setProperty('--active-tab-bg', c);
    root.style.setProperty('--active-tab-border', shadeHex(c, -0.35));
    root.style.setProperty('--active-tab-text', 'var(--text-color)');
  }
  function loadActiveTabColor(){
    try{ return localStorage.getItem(ACTIVE_TAB_KEY) || localStorage.getItem('cc_active_tab_color_v1') || ACTIVE_TAB_DEFAULT; }catch(e){ return ACTIVE_TAB_DEFAULT; }
  }
  function saveActiveTabColor(c){
    try{ localStorage.setItem(ACTIVE_TAB_KEY, c); }catch(e){}
  }
  function bindActiveTabControls(){
    const inp = document.getElementById('st-active-tab-color') || document.getElementById('active-tab-color-input');
    if (inp && !inp.__fix2){
      const c = loadActiveTabColor();
      inp.value = c;
      applyActiveTabColor(c);
      inp.addEventListener('input', ()=>{ applyActiveTabColor(inp.value); saveActiveTabColor(inp.value); });
      inp.__fix2 = true;
    }
    // add reset button near the setting label
    const label = inp?.closest('label') || inp?.parentElement;
    if (label && !document.getElementById('btn-active-tab-color-reset-fix2')){
      const btn = document.createElement('button');
      btn.type='button';
      btn.className='btn';
      btn.id='btn-active-tab-color-reset-fix2';
      btn.textContent='リセット';
      btn.style.marginLeft='6px';
      btn.addEventListener('click', ()=>{
        const d = ACTIVE_TAB_DEFAULT;
        if (inp) inp.value = d;
        applyActiveTabColor(d);
        saveActiveTabColor(d);
      });
      label.appendChild(btn);
    }
  }
  bindActiveTabControls();
  window.addEventListener('load', ()=>{ applyActiveTabColor(loadActiveTabColor()); bindActiveTabControls(); }, {once:true});

  // ---------- 3) Per-tab stats: show (chars and today's delta) on each tab ----------
  const DAY_START_KEY = 'cc_day_start_v1';
  const TAB_SNAP_KEY = 'cc_tab_daily_base_v1';
  function getDayStartMin(){
    // Try to read from UI if exists, else localStorage, else 0.
    const t = document.getElementById('st-day-start')?.value;
    let raw = t;
    if (!raw){
      try{ raw = localStorage.getItem(DAY_START_KEY) || '00:00'; }catch(e){ raw='00:00'; }
    }
    const m = /^\s*(\d{1,2}):(\d{2})\s*$/.exec(String(raw||''));
    if (!m) return 0;
    const hh = Math.max(0, Math.min(23, int(m[1])));
    const mm = Math.max(0, Math.min(59, int(m[2])));
    return hh*60+mm;
  }
  function int(s){ try{ return parseInt(s,10); }catch(e){ return 0; } }
  function todayKey(){
    const now = new Date();
    const off = getDayStartMin();
    const shifted = new Date(now.getTime() - off*60*1000);
    const y = shifted.getFullYear();
    const m = String(shifted.getMonth()+1).padStart(2,'0');
    const d = String(shifted.getDate()).padStart(2,'0');
    return `${y}-${m}-${d}`;
  }
  function loadTabSnap(){
    try{
      const raw = localStorage.getItem(TAB_SNAP_KEY);
      const v = raw ? JSON.parse(raw) : {};
      return (v && typeof v==='object') ? v : {};
    }catch(e){ return {}; }
  }
  function saveTabSnap(v){
    try{ localStorage.setItem(TAB_SNAP_KEY, JSON.stringify(v)); }catch(e){}
  }
  function countChars(s){
    return String(s||'').replace(/[\s　]/g,'').length;
  }
  function ensureDailyBase(tabId, current){
    const k = todayKey();
    const snap = loadTabSnap();
    snap[k] = snap[k] || {};
    if (snap[k][tabId] == null) snap[k][tabId] = current;
    saveTabSnap(snap);
    return snap[k][tabId];
  }
  function tabButtons(){
    const bar = document.getElementById('input-tabs');
    if (!bar) return [];
    return Array.from(bar.querySelectorAll('.input-tab'));
  }
  function renderTabStats(){
    if (!Array.isArray(window.inputTabs)) return;
    // sync current
    try{
      const active = window.inputTabs.find(t=>t.id===window.activeTabId);
      const ia = document.getElementById('input-area');
      if (active && ia) active.content = ia.value;
    }catch(_){ }

    const buttons = tabButtons();
    const map = new Map(window.inputTabs.map(t=>[t.id,t]));
    buttons.forEach(btn=>{
      const id = btn.dataset.tabId || btn.getAttribute('data-tab-id');
      const tab = map.get(id);
      if (!tab) return;
      const cnt = countChars(tab.content||'');
      const base = ensureDailyBase(tab.id, cnt);
      const delta = cnt - base;
      let badge = btn.querySelector('.tab-count-badge-fix2');
      if (!badge){
        badge = document.createElement('span');
        badge.className = 'tab-count-badge-fix2';
        badge.style.marginLeft = '6px';
        badge.style.fontSize = '11px';
        badge.style.opacity = '0.82';
        badge.style.whiteSpace = 'nowrap';
        btn.appendChild(badge);
      }
      const ds = delta>0 ? ` +${delta}` : (delta<0 ? ` ${delta}` : '');
      badge.textContent = `(${cnt}${ds})`;
    });
  }
  let tmr=null;
  function schedule(){
    clearTimeout(tmr);
    tmr=setTimeout(renderTabStats, 200);
  }
  const ia = document.getElementById('input-area');
  if (ia && !ia.__fix2TabStats){
    ia.addEventListener('input', schedule);
    ia.__fix2TabStats = true;
  }
  if (typeof window.setActiveTab === 'function' && !window.setActiveTab.__fix2Wrapped){
    const base = window.setActiveTab;
    window.setActiveTab = function(){
      const r = base.apply(this, arguments);
      setTimeout(renderTabStats, 0);
      return r;
    };
    window.setActiveTab.__fix2Wrapped = true;
  }
  window.addEventListener('load', ()=>setTimeout(renderTabStats, 60), {once:true});

  // ---------- 4) Concentration mode: disable Ctrl+Shift shortcuts to avoid misfires ----------
  const BLOCK = new Set(['KeyP','KeyM','KeyO']);
  window.addEventListener('keydown', (e)=>{
    if (!document.body.classList.contains('concentrate-mode')) return;
    if (e.ctrlKey && e.shiftKey && BLOCK.has(e.code)){
      e.stopImmediatePropagation();
      e.preventDefault();
    }
  }, true);

})();
</script>


<script>
// ===== v0.98: Outline panel becomes NAV (目次/しおり/検索/メモ) + shortcuts Alt+O/M/F/B =====
(function(){
  function $1(sel, root){ return (root||document).querySelector(sel); }
  let suppressSearchRefresh = false;

  function genericSwitchOutlineTab(key){
    document.querySelectorAll('#outline-panel .outline-tab-content').forEach(d=>d.classList.remove('active'));
    const content = document.getElementById('outline-tab-'+key);
    if (content) content.classList.add('active');
    document.querySelectorAll('#outline-panel .memo-tab').forEach(t=>t.classList.remove('active'));
    const btn = Array.from(document.querySelectorAll('#outline-panel .memo-tab')).find(el=> (el.getAttribute('onclick')||'').includes("'"+key+"'"));
    if (btn) btn.classList.add('active');
  }

  // Patch switchOutlineTab to handle new keys reliably
  if (typeof window.switchOutlineTab === 'function'){
    const orig = window.switchOutlineTab;
    window.switchOutlineTab = function(key){
      try{ orig(key); }catch(e){}
      if (document.getElementById('outline-tab-'+key)) genericSwitchOutlineTab(key);
    };
  } else {
    window.switchOutlineTab = genericSwitchOutlineTab;
  }

  // Open NAV + focus
  window.openNavTab = function(which){
    if (which === 'search') {
      if (typeof window.toggleSearchPanel === 'function') window.toggleSearchPanel();
      return;
    }
    if (which === 'memo') {
      if (typeof window.toggleMemoPanel === 'function') window.toggleMemoPanel();
      return;
    }
    const panel = document.getElementById('outline-panel');
    if (!panel) return;
    panel.classList.add('open');
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}

    window.switchOutlineTab(which);

    if (which==='memo'){
      const ta = document.getElementById('memo-area');
      if (ta) setTimeout(()=>ta.focus(), 0);
    }
    if (which==='search'){
      const si = document.getElementById('search-input');
      if (si) setTimeout(()=>si.focus(), 0);
    }
  };

  // Move memo panel into nav tabs
  function relocatePanelsIntoNav(){
    const memoPanel = document.getElementById('memo-panel');
    const memoHost = document.getElementById('nav-memo-host');
    if (memoPanel && memoHost && !memoHost.contains(memoPanel)){
      memoHost.appendChild(memoPanel);
      memoPanel.classList.add('open');
    }

    // Old resizers are confusing now
    const rz1 = document.getElementById('resizer-memo');
    const rz2 = document.getElementById('resizer-memo-outline');
    if (rz1) rz1.style.display = 'none';
    if (rz2) rz2.style.display = 'none';

    // Header buttons -> nav
    const btnMemo = document.getElementById('btn-toggle-memo');
    if (btnMemo) btnMemo.onclick = ()=> openNavTab('memo');
    const btnOutline = document.getElementById('btn-toggle-outline');
    if (btnOutline) btnOutline.onclick = ()=> openNavTab('outline');
    const btnSearch = document.getElementById('btn-toggle-search');
    if (btnSearch) btnSearch.onclick = ()=> openNavTab('search');

    // Ctrl+F -> nav search
    document.addEventListener('keydown', (e)=>{
      if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey && (e.key==='f' || e.key==='F')){
        e.preventDefault();
        openNavTab('search');
      }
    }, true);
  }

  // Alt shortcuts
  function hookAltShortcuts(){
    document.addEventListener('keydown', (e)=>{
      if (!e.altKey || e.ctrlKey || e.metaKey) return;
      const k = (e.key||'').toLowerCase();
      const map = { 'o':'outline', 'm':'memo', 'f':'search', 'b':'bookmark' };
      if (!map[k]) return;
      e.preventDefault();
      e.stopPropagation();
      openNavTab(map[k]);
    }, true);
  }

  // Extend search target to include memo (dropdown)
  function patchSearchTargetAndEngine(){
    const sel = document.getElementById('search-scope');
    if (!sel) return;

    // Save current value if one of old options
    const oldVal = sel.value || 'current';

    sel.innerHTML = '';
    const opts = [
      ['input_current','本文(このタブ)'],
      ['input_all','本文(全タブ)'],
      ['memo_current','メモ(このタブ)'],
      ['memo_all','メモ(全タブ)'],
      ['both_all','本文+メモ(全て)'],
    ];
    for (const [v,lab] of opts){
      const o=document.createElement('option');
      o.value=v; o.textContent=lab;
      sel.appendChild(o);
    }
    sel.value = (oldVal==='all') ? 'input_all' : 'input_current';

    // We override doSearch/findNext/findPrev/replaceOne/replaceAll with an engine that supports our targets.
    // This replaces the previous patch but keeps behavior (hits list, preview, etc.)

    let matches = [];
    let idx = -1;
    let lastQ = '';
    let lastScope = 'input_current';

    const escapeRe = (s)=> s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    function calcLineInfo(text, pos){
      const before = text.slice(0,pos);
      const lineNum = (before.match(/\n/g)||[]).length + 1;
      const lineStart = before.lastIndexOf('\n')+1;
      const lineEnd = text.indexOf('\n', pos);
      const lineText = text.slice(lineStart, lineEnd===-1?text.length:lineEnd);
      return {lineNum, lineText: lineText.trim(), lineStart};
    }

    function getInputTextForTab(tab){
      if (!tab) return '';
      if (tab.id === window.activeTabId && window.inputArea) return window.inputArea.value;
      return tab.content || '';
    }
    function getMemoTextForTab(tab){
      if (!tab) return '';
      // memo active might be in textarea
      if (tab.id === window.activeMemoTabId && window.memoArea) return window.memoArea.value;
      return tab.content || '';
    }

    function collectAll(query, scope){
      const rx = new RegExp(escapeRe(query), 'g');
      const inputTabs = Array.isArray(window.inputTabs) ? window.inputTabs : [];
      const memoTabs = Array.isArray(window.memoTabs) ? window.memoTabs : [];
      const res=[];

      function scan(text, meta){
        if (!text) return;
        rx.lastIndex = 0;
        let m;
        while((m=rx.exec(text))!==null){
          const pos = m.index;
          const li = calcLineInfo(text, pos);
          res.push({
            kind: meta.kind, // 'input'|'memo'
            tabId: meta.tabId,
            tabName: meta.tabName,
            start: pos,
            end: pos + m[0].length,
            lineNum: li.lineNum,
            preview: li.lineText.slice(0,80),
            memoTabId: meta.memoTabId
          });
          if (m[0].length===0) rx.lastIndex++;
        }
      }

      if (scope==='input_current'){
        const t = inputTabs.find(t=>t.id===window.activeTabId);
        scan(getInputTextForTab(t), {kind:'input', tabId: t?.id, tabName: t?.name||''});
      } else if (scope==='input_all'){
        for (const t of inputTabs) scan(getInputTextForTab(t), {kind:'input', tabId: t.id, tabName: t.name||''});
      } else if (scope==='memo_current'){
        const t = memoTabs.find(t=>t.id===window.activeMemoTabId);
        scan(getMemoTextForTab(t), {kind:'memo', tabId: window.activeTabId, tabName: (inputTabs.find(x=>x.id===window.activeTabId)?.name)||'', memoTabId: t?.id});
      } else if (scope==='memo_all'){
        for (const mt of memoTabs){
          scan(getMemoTextForTab(mt), {kind:'memo', tabId: window.activeTabId, tabName: (inputTabs.find(x=>x.id===window.activeTabId)?.name)||'', memoTabId: mt.id});
        }
      } else if (scope==='both_all'){
        for (const t of inputTabs) scan(getInputTextForTab(t), {kind:'input', tabId: t.id, tabName: t.name||''});
        for (const mt of memoTabs) scan(getMemoTextForTab(mt), {kind:'memo', tabId: window.activeTabId, tabName: (inputTabs.find(x=>x.id===window.activeTabId)?.name)||'', memoTabId: mt.id});
      }

      return res.filter(m=>m.tabId!=null);
    }

    function updateInfo(){
      const info = document.getElementById('search-match-info');
      if (info) info.textContent = `${matches.length? (idx+1):0} / ${matches.length}`;
    }

    function jumpTo(m){
      if (!m) return;
      suppressSearchRefresh = true;
      try {
        if (m.kind==='input'){
          if (m.tabId!==window.activeTabId && typeof window.switchTab==='function') window.switchTab(m.tabId);
          const ta = window.inputArea;
          if (!ta) return;
          ta.focus();
          ta.setSelectionRange(m.start, m.end);
          if (typeof window.scrollToCursorPosition==='function') setTimeout(()=>window.scrollToCursorPosition(m.start), 60);
          if (typeof window.updateCursorLineDisplay==='function') window.updateCursorLineDisplay();
        } else {
          // memo
          openNavTab('memo');
          if (typeof window.switchMemoTab==='function' && m.memoTabId) window.switchMemoTab(m.memoTabId);
          const ta = window.memoArea || document.getElementById('memo-area');
          if (!ta) return;
          ta.focus();
          try{ ta.setSelectionRange(m.start, m.end); }catch(e){}
        }
        idx = matches.findIndex(x=>x.kind===m.kind && x.tabId===m.tabId && x.start===m.start && x.end===m.end && x.memoTabId===m.memoTabId);
        updateInfo();
      } finally {
        suppressSearchRefresh = false;
      }
    }

    function renderHits(){
      const box = document.getElementById('search-hits');
      if (!box) return;
      box.innerHTML = '';
      if (!lastQ){
        box.innerHTML = '<div class="outline-empty">ヒット一覧はここに表示されます</div>';
        return;
      }
      if (!matches.length){
        box.innerHTML = '<div class="outline-empty">ヒットなし</div>';
        return;
      }

      const maxShow = 300;
      const slice = matches.slice(0, maxShow);
      const grouped = {};
      for (const m of slice){
        const key = m.kind==='memo' ? `memo-${m.memoTabId||0}` : `input-${m.tabId}`;
        const name = m.kind==='memo' ? `メモ${m.memoTabId||''}` : (m.tabName||('タブ'+m.tabId));
        (grouped[key] ||= {name, kind:m.kind, items:[]}).items.push(m);
      }

      for (const g of Object.values(grouped)){
        const head = document.createElement('div');
        head.style.fontWeight='700';
        head.style.margin='6px 0 2px';
        head.textContent = `【${g.name}】 (${g.items.length})`;
        box.appendChild(head);
        for (const m of g.items){
          const div = document.createElement('div');
          div.className = 'bookmark-item';
          div.style.cursor='pointer';
          const prefix = (m.kind==='memo') ? '📝' : '🔎';
          div.innerHTML = `${prefix} ${m.lineNum}行: ${escapeHtml(m.preview)}`;
          div.addEventListener('click', ()=> jumpTo(m));
          div.addEventListener('contextmenu', (ev)=>{
            ev.preventDefault();
            // right-click -> add bookmark (only for input) / add reader bookmark (for memo not supported)
            if (m.kind==='input' && typeof window.addBookmark==='function'){
              // jump first so bookmark captures correct pos
              jumpTo(m);
              setTimeout(()=>{ try{ window.addBookmark(); }catch(e){} }, 0);
            }
          });
          box.appendChild(div);
        }
      }

      if (matches.length > maxShow){
        const note = document.createElement('div');
        note.className='outline-empty';
        note.textContent = `表示は${maxShow}件まで（全${matches.length}件）`;
        box.appendChild(note);
      }
    }

    window.doSearch = function(){
      const q = (document.getElementById('search-input')?.value || '').trim();
      const scope = document.getElementById('search-scope')?.value || 'input_current';
      lastQ = q;
      lastScope = scope;
      if (!q){
        matches = []; idx = -1;
        updateInfo();
        renderHits();
        return;
      }
      matches = collectAll(q, scope);
      // sort stable
      matches.sort((a,b)=> (a.kind===b.kind?0:(a.kind==='input'?-1:1)) || (a.tabId-b.tabId) || ((a.memoTabId||0)-(b.memoTabId||0)) || (a.start-b.start));
      idx = matches.length ? 0 : -1;
      updateInfo();
      renderHits();
      if (idx>=0) jumpTo(matches[0]);
    };

    window.findNext = function(){
      if (!matches.length) return;
      idx = (idx+1) % matches.length;
      updateInfo();
      jumpTo(matches[idx]);
    };
    window.findPrev = function(){
      if (!matches.length) return;
      idx = (idx-1 + matches.length) % matches.length;
      updateInfo();
      jumpTo(matches[idx]);
    };

    window.replaceOne = function(){
      const q = (document.getElementById('search-input')?.value || '');
      const rep = (document.getElementById('replace-input')?.value || '');
      if (!q) return;
      if (!matches.length || idx<0) window.doSearch();
      if (!matches.length) return;
      const m = matches[idx];
      if (m.kind==='memo'){
        openNavTab('memo');
        if (typeof window.switchMemoTab==='function' && m.memoTabId) window.switchMemoTab(m.memoTabId);
        const ta = window.memoArea || document.getElementById('memo-area');
        if (!ta) return;
        const text = ta.value;
        if (text.slice(m.start, m.end) !== q){ window.doSearch(); return; }
        ta.setRangeText(rep, m.start, m.end, 'select');
        try{ if (typeof window.saveMemoTabs==='function') window.saveMemoTabs(); }catch(e){}
      } else {
        // input
        jumpTo(m);
        const ta = window.inputArea;
        if (!ta) return;
        const text = ta.value;
        if (text.slice(m.start, m.end) !== q){ window.doSearch(); return; }
        ta.setRangeText(rep, m.start, m.end, 'select');
        // update active tab content
        const t = (window.inputTabs||[]).find(t=>t.id===window.activeTabId);
        if (t) t.content = ta.value;
        try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
      }
      window.doSearch();
    };

    window.replaceAll = function(){
      const q = (document.getElementById('search-input')?.value || '');
      const rep = (document.getElementById('replace-input')?.value || '');
      if (!q) return;
      if (!matches.length) window.doSearch();
      const count = matches.length;
      if (!count) return;
      if (!confirm(`${count}件を全置換しますか？（範囲: ${document.getElementById('search-scope')?.selectedOptions?.[0]?.textContent||''}）`)) return;

      const scope = document.getElementById('search-scope')?.value || 'input_current';
      const inputTabs = Array.isArray(window.inputTabs) ? window.inputTabs : [];
      const memoTabs = Array.isArray(window.memoTabs) ? window.memoTabs : [];

      const replaceInText = (text)=> text.split(q).join(rep);

      if (scope==='input_current'){
        const ta=window.inputArea;
        if (ta) ta.value = replaceInText(ta.value);
        const t=inputTabs.find(t=>t.id===window.activeTabId);
        if (t) t.content = ta?ta.value:replaceInText(t.content||'');
      } else if (scope==='input_all' || scope==='both_all'){
        for (const t of inputTabs){
          if (t.id===window.activeTabId && window.inputArea){
            window.inputArea.value = replaceInText(window.inputArea.value);
            t.content = window.inputArea.value;
          } else {
            t.content = replaceInText(t.content||'');
          }
        }
      }

      if (scope==='memo_current'){
        openNavTab('memo');
        const ta = window.memoArea || document.getElementById('memo-area');
        if (ta) ta.value = replaceInText(ta.value);
        const t=memoTabs.find(t=>t.id===window.activeMemoTabId);
        if (t) t.content = ta?ta.value:replaceInText(t.content||'');
        try{ if (typeof window.saveMemoTabs==='function') window.saveMemoTabs(); }catch(e){}
      } else if (scope==='memo_all' || scope==='both_all'){
        for (const mt of memoTabs){
          if (mt.id===window.activeMemoTabId && (window.memoArea||document.getElementById('memo-area'))){
            const ta = window.memoArea || document.getElementById('memo-area');
            if (ta){ ta.value = replaceInText(ta.value); mt.content = ta.value; }
          } else {
            mt.content = replaceInText(mt.content||'');
          }
        }
        try{ if (typeof window.saveMemoTabs==='function') window.saveMemoTabs(); }catch(e){}
      }

      try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
      window.doSearch();
    };

    // rerun search when scope changes
    sel.addEventListener('change', ()=>{ if (document.getElementById('search-input')?.value) window.doSearch(); });
  }

  function resetSearchPanel(){
    const searchInput = document.getElementById('search-input');
    const replaceInput = document.getElementById('replace-input');
    if (searchInput) searchInput.value = '';
    if (replaceInput) replaceInput.value = '';
    if (typeof window.doSearch === 'function') window.doSearch();
    const hits = document.getElementById('search-hits');
    if (hits && !searchInput?.value) {
      hits.innerHTML = '<div class="outline-empty">ヒット一覧はここに表示されます</div>';
    }
  }
  window.resetSearchPanel = resetSearchPanel;

  function hookSearchRefreshOnTabChange(){
    const refreshIfCurrent = () => {
      if (suppressSearchRefresh) return;
      const q = document.getElementById('search-input')?.value || '';
      const scope = document.getElementById('search-scope')?.value || 'input_current';
      if (!q) return;
      if (scope === 'input_current' || scope === 'memo_current') {
        if (typeof window.doSearch === 'function') window.doSearch();
      }
    };

    if (typeof window.switchTab === 'function' && !window.switchTab.__searchRefreshWrapped) {
      const base = window.switchTab;
      window.switchTab = function(){
        const r = base.apply(this, arguments);
        refreshIfCurrent();
        return r;
      };
      window.switchTab.__searchRefreshWrapped = true;
    }

    if (typeof window.switchMemoTab === 'function' && !window.switchMemoTab.__searchRefreshWrapped) {
      const base = window.switchMemoTab;
      window.switchMemoTab = function(){
        const r = base.apply(this, arguments);
        refreshIfCurrent();
        return r;
      };
      window.switchMemoTab.__searchRefreshWrapped = true;
    }
  }

  function setupPanelDragSwap(){
    const headers = document.querySelectorAll('.panel-drag-handle[data-panel-id]');
    if (!headers.length) return;
    const container = document.getElementById('main-container');
    if (!container) return;

    const isPanelDocked = (panelId) => {
      if (panelId === 'memo-panel') return container.classList.contains('memo-docked');
      if (panelId === 'outline-panel') return container.classList.contains('outline-docked');
      if (panelId === 'search-panel') return container.classList.contains('search-docked');
      return false;
    };

    const getPanelSide = (panelId) => {
      if (panelId === 'memo-panel') return container.classList.contains('memo-right') ? 'right' : 'left';
      if (panelId === 'outline-panel') return container.classList.contains('outline-left') ? 'left' : 'right';
      if (panelId === 'search-panel') return container.classList.contains('search-left') ? 'left' : 'right';
      return 'right';
    };

    const setPanelSide = (panelId, side) => {
      if (panelId === 'memo-panel') container.classList.toggle('memo-right', side === 'right');
      if (panelId === 'outline-panel') container.classList.toggle('outline-left', side === 'left');
      if (panelId === 'search-panel') container.classList.toggle('search-left', side === 'left');
    };

    headers.forEach(header => {
      header.addEventListener('dragstart', (e) => {
        const panelId = header.dataset.panelId;
        if (!panelId || !isPanelDocked(panelId)) {
          e.preventDefault();
          return;
        }
        header.classList.add('dragging');
        e.dataTransfer.setData('text/plain', panelId);
        e.dataTransfer.effectAllowed = 'move';
      });

      header.addEventListener('dragend', () => {
        header.classList.remove('dragging');
      });

      header.addEventListener('dragover', (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
      });

      header.addEventListener('drop', (e) => {
        e.preventDefault();
        const sourceId = e.dataTransfer.getData('text/plain');
        const targetId = header.dataset.panelId;
        if (!sourceId || !targetId || sourceId === targetId) return;
        if (!isPanelDocked(sourceId) || !isPanelDocked(targetId)) return;
        const sourceSide = getPanelSide(sourceId);
        const targetSide = getPanelSide(targetId);
        if (sourceSide === targetSide) return;
        setPanelSide(sourceId, targetSide);
        setPanelSide(targetId, sourceSide);
        try{ if (typeof window.updateDockSplitState === 'function') window.updateDockSplitState(); }catch(e){}
        try{ if (typeof window.applyPaneWidthSettings === 'function') window.applyPaneWidthSettings(); }catch(e){}
        try{ if (typeof window.updatePanelButtonStates === 'function') window.updatePanelButtonStates(); }catch(e){}
      });
    });
  }

  function init(){
    // relocatePanelsIntoNav(); // Disabled: keep panels independent per user request
    setupIndependentPanels();
    hookAltShortcuts();
    patchSearchTargetAndEngine();
    hookSearchRefreshOnTabChange();
    setupPanelDragSwap();
  }

  // Setup independent panels (memo, outline, search) instead of nav tabs
  function setupIndependentPanels(){
    const searchPanel = document.getElementById('search-panel');
    if (searchPanel) {
      searchPanel.classList.remove('open');
      searchPanel.style.display = 'none';
    }

    // Keep memo-panel independent
    const memoPanel = document.getElementById('memo-panel');
    if (memoPanel) {
      memoPanel.classList.remove('open');
    }

    // Show resizers
    const rz1 = document.getElementById('resizer-memo');
    const rz2 = document.getElementById('resizer-memo-outline');
    if (rz1) rz1.style.display = '';
    if (rz2) rz2.style.display = '';

    // Header buttons -> toggle individual panels
    const btnMemo = document.getElementById('btn-toggle-memo');
    if (btnMemo) btnMemo.onclick = ()=> toggleMemoPanel();
    const btnOutline = document.getElementById('btn-toggle-outline');
    if (btnOutline) btnOutline.onclick = ()=> toggleOutlinePanel();
    const btnSearch = document.getElementById('btn-toggle-search');
    if (btnSearch) btnSearch.onclick = ()=> toggleSearchPanel();

    // Ctrl+F -> search panel
    document.addEventListener('keydown', (e)=>{
      if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey && (e.key==='f' || e.key==='F')){
        e.preventDefault();
        toggleSearchPanel();
      }
    }, true);
  }

  // Toggle search panel (click cycle: closed -> open floating -> docked -> closed)
  // Same behavior as memo panel
  function toggleSearchPanel() {
    const panel = document.getElementById('search-panel');
    const checkbox = document.getElementById('check-search-dock');
    if (!panel || !checkbox) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;
    const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('search-panel'));

    if (!isOpen) {
      
      panel.classList.add('open');
      panel.style.display = 'flex';
      if (checkbox.checked) { checkbox.checked = false; toggleSearchDock(); }
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      const input = document.getElementById('search-input');
      if (input) setTimeout(()=> input.focus(), 0);
    } else if (!isDocked) {
      if (!isFront) {
        if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
        if (typeof window.updatePanelButtonStates === 'function') window.updatePanelButtonStates();
        return;
      }
      if (typeof window.__ccRequestDockWithLimit === 'function') { window.__ccRequestDockWithLimit('search'); } else { checkbox.checked = true; toggleSearchDock(); panel.classList.add('open'); }
} else {
      checkbox.checked = false;
      toggleSearchDock();
      panel.classList.remove('open');
      panel.style.display = 'none';
      panel.style.zIndex = '';
      if (window.__ccFrontPanelId === 'search-panel') window.__ccFrontPanelId = null;
    }

    const isDockedNow = checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
    try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}
}
  window.toggleSearchPanel = toggleSearchPanel;

  // Toggle outline panel (click cycle: closed -> open floating -> docked -> closed)
  function toggleOutlinePanel(){
    const panel = document.getElementById('outline-panel');
    if (!panel) return;
    const checkbox = document.getElementById('check-outline-dock');
    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox && checkbox.checked;

    if (!isOpen) {
      // Closed -> Open (floating)
      if (typeof window.generateOutline === 'function') window.generateOutline();
      panel.classList.add('open');
      switchOutlineTabDirect('outline');
      if (isDocked) {
        checkbox.checked = false;
        if (typeof window.toggleOutlineDock === 'function') window.toggleOutlineDock();
      }
    } else if (!isDocked) {
      // Open floating -> Docked
      if (checkbox) checkbox.checked = true;
      if (typeof window.toggleOutlineDock === 'function') window.toggleOutlineDock();
      panel.classList.add('open');
    } else {
      // Docked -> Closed
      if (checkbox) checkbox.checked = false;
      if (typeof window.toggleOutlineDock === 'function') window.toggleOutlineDock();
      panel.classList.remove('open');
    }

    const isDockedNow = checkbox && checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
  }
  window.toggleOutlinePanel = toggleOutlinePanel;

  // Switch outline tab directly (for independent outline panel)
  function switchOutlineTabDirect(tabName){
    document.querySelectorAll('#outline-panel .outline-tab-content').forEach(d=>d.classList.remove('active'));
    const content = document.getElementById('outline-tab-'+tabName);
    if (content) content.classList.add('active');
    document.querySelectorAll('#outline-panel .memo-tab').forEach(t=>t.classList.remove('active'));
    const tabEl = document.querySelector(`#outline-panel .memo-tab[onclick*="${tabName}"]`);
    if (tabEl) tabEl.classList.add('active');
  }
  window.switchOutlineTabDirect = switchOutlineTabDirect;

  // Panel limit check - disabled per user request
  function checkPanelLimit(){
    // No longer showing panel limit warnings
  }
  window.checkPanelLimit = checkPanelLimit;

  // Show panel swap notification
  function showPanelSwapNotification(panels){
    let notify = document.getElementById('panel-swap-notify');
    if (!notify) {
      notify = document.createElement('div');
      notify.id = 'panel-swap-notify';
      notify.style.cssText = 'position:fixed; bottom:60px; right:20px; background:#fef3c7; border:1px solid #f59e0b; border-radius:8px; padding:12px 16px; z-index:9999; box-shadow:0 4px 12px rgba(0,0,0,0.15); font-size:0.85rem;';
      document.body.appendChild(notify);
    }

    // Build swap options (exclude input/preview)
    const swappable = panels.filter(p => p.id !== 'pane-input' && p.id !== 'pane-preview');
    const lastPanel = swappable[swappable.length - 1];

    let html = '<div style="margin-bottom:8px; font-weight:bold;">⚠ パネルが4枚を超えています</div>';
    html += '<div style="margin-bottom:8px;">閉じるパネルを選択してください：</div>';
    html += '<select id="panel-swap-select" style="padding:4px 8px; border-radius:4px; border:1px solid #d4a574; margin-right:8px;">';
    swappable.forEach(p => {
      html += `<option value="${p.id}">${p.name}</option>`;
    });
    html += '</select>';
    html += '<button onclick="closePanelFromSwap()" style="padding:4px 12px; background:#f59e0b; color:white; border:none; border-radius:4px; cursor:pointer;">閉じる</button>';
    html += '<button onclick="hidePanelSwapNotification()" style="padding:4px 8px; background:#e5e7eb; border:none; border-radius:4px; cursor:pointer; margin-left:4px;">×</button>';

    notify.innerHTML = html;
    notify.style.display = 'block';
  }
  window.showPanelSwapNotification = showPanelSwapNotification;

  function hidePanelSwapNotification(){
    const notify = document.getElementById('panel-swap-notify');
    if (notify) notify.style.display = 'none';
  }
  window.hidePanelSwapNotification = hidePanelSwapNotification;

  function closePanelFromSwap(){
    const sel = document.getElementById('panel-swap-select');
    if (!sel) return;
    const panelId = sel.value;

    if (panelId === 'memo-panel') {
      const panel = document.getElementById('memo-panel');
      if (panel) panel.classList.remove('open');
    } else if (panelId === 'outline-panel') {
      const panel = document.getElementById('outline-panel');
      if (panel) panel.classList.remove('open');
    }

    hidePanelSwapNotification();
    checkPanelLimit();
  }
  window.closePanelFromSwap = closePanelFromSwap;

  // ========== Search Panel Functions ==========

  function toggleSearchDock(){
    const mainContainer = document.getElementById('main-container');
    const panel = document.getElementById('search-panel');
    const checkbox = document.getElementById('check-search-dock');
    const swapBtn = document.getElementById('btn-search-swap');
    const pinBtn = document.getElementById('btn-search-pin');
    if (!mainContainer || !panel) return;

    const isDocked = mainContainer.classList.contains('search-docked');
    if (isDocked) {
      mainContainer.classList.remove('search-docked');
      if (checkbox) checkbox.checked = false;
      if (swapBtn) swapBtn.classList.remove('is-active');
panel.style.width = '320px';
    } else {
      mainContainer.classList.add('search-docked');
      if (checkbox) checkbox.checked = true;
      if (swapBtn) swapBtn.classList.add('is-active');
    }
    if (pinBtn && checkbox) pinBtn.classList.toggle('pinned', checkbox.checked);
    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
  }
  window.toggleSearchDock = toggleSearchDock;

  function toggleSearchDockPin() {
    const checkbox = document.getElementById('check-search-dock');
    const panel = document.getElementById('search-panel');
    if (!checkbox) return;

    if (!checkbox.checked) {
      if (typeof window.__ccRequestDockWithLimit === 'function') {
        window.__ccRequestDockWithLimit('search');
        return;
      }
      checkbox.checked = true;
      toggleSearchDock();
      if (panel) panel.classList.add('open');
      return;
    }

    checkbox.checked = false;
    toggleSearchDock();
    if (panel) {
      panel.classList.add('open');
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    }
}
  window.toggleSearchDockPin = toggleSearchDockPin;

  function swapSearchSide() {
    if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('search');
  }

  window.swapSearchSide = swapSearchSide;

  function closeSearchPanel(){
    const panel = document.getElementById('search-panel');
    const mainContainer = document.getElementById('main-container');
    const checkbox = document.getElementById('check-search-dock');
    const swapBtn = document.getElementById('btn-search-swap');
    if (panel) {
      panel.classList.remove('open');
      panel.style.display = 'none';
    }
    if (mainContainer) mainContainer.classList.remove('search-docked');
    if (checkbox) checkbox.checked = false;
    if (swapBtn) swapBtn.classList.remove('is-active');
    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.updateDockSplitState==='function') window.updateDockSplitState(); }catch(e){}
  }
  window.closeSearchPanel = closeSearchPanel;

  // Toggle outline settings overlay
  function toggleOutlineSettings(){
    const overlay = document.getElementById('outline-settings-overlay');
    if (!overlay) return;
    overlay.style.display = overlay.style.display === 'none' ? 'block' : 'none';

    // Load from localStorage when opening
    if (overlay.style.display === 'block') {
      loadOutlineRulesToOverlay();
    }
  }
  window.toggleOutlineSettings = toggleOutlineSettings;

  // Load outline rules from localStorage to overlay
  function loadOutlineRulesToOverlay(){
    const OUTLINE_RULES_KEY = 'cc_outline_rules_v1';
    let rules = { useHash:true, useBox:true, useTri:true, useDia:true, useCir:true, useChapter:true, useCircNum:true, useRoman:true, extra:'' };
    try {
      const saved = localStorage.getItem(OUTLINE_RULES_KEY);
      if (saved) rules = { ...rules, ...JSON.parse(saved) };
    } catch(e){}

    const el = (id) => document.getElementById(id);
    if (el('or-use-hash')) el('or-use-hash').checked = rules.useHash !== false;
    if (el('or-use-box')) el('or-use-box').checked = rules.useBox !== false;
    if (el('or-use-tri')) el('or-use-tri').checked = rules.useTri !== false;
    if (el('or-use-dia')) el('or-use-dia').checked = rules.useDia !== false;
    if (el('or-use-cir')) el('or-use-cir').checked = rules.useCir !== false;
    if (el('or-use-chapter')) el('or-use-chapter').checked = rules.useChapter !== false;
    if (el('or-use-circnum')) el('or-use-circnum').checked = rules.useCircNum !== false;
    if (el('or-use-roman')) el('or-use-roman').checked = rules.useRoman !== false;
    if (el('or-extra')) el('or-extra').value = rules.extra || '';
  }

  // Apply outline rules from overlay directly to localStorage
  function applyOutlineRulesFromOverlay(){
    const OUTLINE_RULES_KEY = 'cc_outline_rules_v1';
    const el = (id) => document.getElementById(id);

    const rules = {
      useHash: el('or-use-hash')?.checked ?? true,
      useBox: el('or-use-box')?.checked ?? true,
      useTri: el('or-use-tri')?.checked ?? true,
      useDia: el('or-use-dia')?.checked ?? true,
      useCir: el('or-use-cir')?.checked ?? true,
      useChapter: el('or-use-chapter')?.checked ?? true,
      useCircNum: el('or-use-circnum')?.checked ?? true,
      useRoman: el('or-use-roman')?.checked ?? true,
      extra: el('or-extra')?.value || ''
    };

    try { localStorage.setItem(OUTLINE_RULES_KEY, JSON.stringify(rules)); } catch(e){}

    // Regenerate outline with new rules
    if (typeof window.generateOutline === 'function') window.generateOutline();
    else if (typeof window.updateOutline === 'function') window.updateOutline();

    toggleOutlineSettings();
  }
  window.applyOutlineRulesFromOverlay = applyOutlineRulesFromOverlay;

  // Drag functionality for floating panels
  let dragState = { panel: null, offsetX: 0, offsetY: 0 };
  function startDragPanel(e, panelId){
    const panel = document.getElementById(panelId);
    if (!panel) return;
    dragState.panel = panel;
    dragState.offsetX = e.clientX - panel.offsetLeft;
    dragState.offsetY = e.clientY - panel.offsetTop;
    document.addEventListener('mousemove', onDragPanel);
    document.addEventListener('mouseup', stopDragPanel);
    e.preventDefault();
  }
  window.startDragPanel = startDragPanel;

  function onDragPanel(e){
    if (!dragState.panel) return;
    dragState.panel.style.left = (e.clientX - dragState.offsetX) + 'px';
    dragState.panel.style.top = (e.clientY - dragState.offsetY) + 'px';
    dragState.panel.style.right = 'auto';
  }

  function stopDragPanel(){
    dragState.panel = null;
    document.removeEventListener('mousemove', onDragPanel);
    document.removeEventListener('mouseup', stopDragPanel);
  }

  // Right-click context menu for coloring
  function setupContextMenus(){
    // Tab right-click for active tab color
    document.addEventListener('contextmenu', (e) => {
      const tab = e.target.closest('.input-tab, .preview-tab, .memo-tab');
      if (tab) {
        e.preventDefault();
        showTabContextMenu(e, tab);
        return;
      }

      // Pane header right-click for header color
      const header = e.target.closest('.pane-header, .memo-header, .outline-header, .structure-header, .character-header, .world-header, .terms-header');
      if (header && !e.target.closest('#novel-title')) {
        e.preventDefault();
        showHeaderContextMenu(e, header);
        return;
      }
    });
  }

  let contextMenuClickHandler = null;

  function showTabContextMenu(e, tab){
    hideContextMenusOnly();
    let menu = document.getElementById('tab-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'tab-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:160px;';
      document.body.appendChild(menu);
    }

    menu.innerHTML = `
      <div class="context-menu-item" data-action="rename">リネーム</div>
      <div class="context-menu-item" data-action="duplicate">複製</div>
      <div class="context-menu-item" data-action="new">＋ 新しいタブ</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="color">🎨 カラーリングの変更</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" style="color:#dc2626;" data-action="close">× このタブを閉じる</div>
    `;

    // Add event listeners to menu items
    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'rename') { renameActiveTab(); hideContextMenusOnly(); }
        else if (action === 'duplicate') { duplicateTab(); hideContextMenusOnly(); }
        else if (action === 'new') { addNewTab(); hideContextMenusOnly(); }
        else if (action === 'color') { showTabColorPicker(); }
        else if (action === 'close') { closeActiveTab(); hideContextMenusOnly(); }
      };
    });

    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.style.display = 'block';

    // Close on click outside
    if (contextMenuClickHandler) {
      document.removeEventListener('click', contextMenuClickHandler);
    }
    contextMenuClickHandler = (ev) => {
      if (!ev.target.closest('#tab-context-menu, #header-context-menu, #color-picker-popup')) {
        hideAllContextMenus();
      }
    };
    setTimeout(() => {
      document.addEventListener('click', contextMenuClickHandler);
    }, 0);
  }

  function showHeaderContextMenu(e, header){
    hideContextMenusOnly();
    let menu = document.getElementById('header-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'header-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:180px;';
      document.body.appendChild(menu);
    }

    const paneId = header.closest('.pane, #memo-panel, #outline-panel, #structure-panel, #character-panel, #world-panel')?.id || '';
    menu.dataset.paneId = paneId;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="header-color" data-pane="${paneId}">🎨 ヘッダーカラーの変更</div>
      <div class="context-menu-item" data-action="bg-color" data-pane="${paneId}">🖼️ 背景色の変更</div>
    `;

    // Add event listeners
    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        const pId = item.dataset.pane;
        if (action === 'header-color') { showHeaderColorPicker(pId); }
        else if (action === 'bg-color') { showBgColorPicker(pId); }
      };
    });

    menu.style.left = e.clientX + 'px';
    menu.style.top = e.clientY + 'px';
    menu.style.display = 'block';

    if (contextMenuClickHandler) {
      document.removeEventListener('click', contextMenuClickHandler);
    }
    contextMenuClickHandler = (ev) => {
      if (!ev.target.closest('#tab-context-menu, #header-context-menu, #color-picker-popup')) {
        hideAllContextMenus();
      }
    };
    setTimeout(() => {
      document.addEventListener('click', contextMenuClickHandler);
    }, 0);
  }

  function hideContextMenusOnly(){
    ['tab-context-menu', 'header-context-menu'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
  }

  function hideAllContextMenus(){
    ['tab-context-menu', 'header-context-menu', 'color-picker-popup'].forEach(id => {
      const el = document.getElementById(id);
      if (el) el.style.display = 'none';
    });
    if (contextMenuClickHandler) {
      document.removeEventListener('click', contextMenuClickHandler);
      contextMenuClickHandler = null;
    }
  }
  window.hideAllContextMenus = hideAllContextMenus;

  // Color presets
  const colorPresets = {
    tab: ['#fff59d', '#fecaca', '#bfdbfe', '#bbf7d0', '#ddd6fe', '#fed7aa', '#fce7f3', '#f5f5dc', '#e0e7ff', '#ccfbf1'],
    header: ['#f9fafb', '#fef3c7', '#dbeafe', '#dcfce7', '#fce7f3', '#e0e7ff', '#f5f5dc', '#fef2f2', '#ecfdf5', '#faf5ff'],
    bg: ['#ffffff', '#fdfcf0', '#f0f9ff', '#f0fdf4', '#fdf2f8', '#eef2ff', '#fffbeb', '#fef2f2', '#f5f5f4', '#1f2937']
  };

  function showTabColorPicker(){
    hideContextMenusOnly();

    let picker = document.getElementById('color-picker-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'color-picker-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
      document.body.appendChild(picker);
    }

    // Get current color
    const currentColor = getComputedStyle(document.documentElement).getPropertyValue('--active-tab-bg').trim() || '#fff59d';

    let presetsHtml = colorPresets.tab.map(c =>
      `<button class="color-preset" data-color="${c}" style="width:24px; height:24px; background:${c}; border:1px solid #ccc; border-radius:4px; cursor:pointer;${c === currentColor ? ' outline:2px solid #2563eb;' : ''}"></button>`
    ).join('');

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">アクティブタブの色</span>
        <button class="picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input type="color" id="tab-color-input" value="${currentColor}" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px;">
        <input type="text" id="tab-color-text" value="${currentColor}" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetsHtml}
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="picker-cancel">キャンセル</button>
        <button class="btn btn-apply" id="picker-apply">適用</button>
      </div>
    `;

    picker.style.left = '50%';
    picker.style.top = '50%';
    picker.style.transform = 'translate(-50%, -50%)';
    picker.style.display = 'block';

    // Event handlers
    const colorInput = picker.querySelector('#tab-color-input');
    const colorText = picker.querySelector('#tab-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.color-preset').forEach(btn => {
      btn.onclick = () => {
        const c = btn.dataset.color;
        colorInput.value = c;
        colorText.value = c;
        picker.querySelectorAll('.color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    picker.querySelector('.picker-close').onclick = () => hideColorPicker();
    picker.querySelector('#picker-cancel').onclick = () => hideColorPicker();
    picker.querySelector('#picker-apply').onclick = () => {
      const color = colorInput.value || '#fff59d';
      document.documentElement.style.setProperty('--active-tab-bg', color);
      try { localStorage.setItem('cc_active_tab_color', color); } catch(e){}
      hideColorPicker();
    };

    // Stop propagation to prevent closing
    picker.onclick = (e) => e.stopPropagation();
  }
  window.showTabColorPicker = showTabColorPicker;

  function hideColorPicker(){
    const picker = document.getElementById('color-picker-popup');
    if (picker) picker.style.display = 'none';
  }
  window.hideColorPicker = hideColorPicker;

  function showHeaderColorPicker(paneId){
    hideContextMenusOnly();

    let picker = document.getElementById('color-picker-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'color-picker-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
      document.body.appendChild(picker);
    }

    const paneMap = {
      'pane-input': '--pane-input-head',
      'pane-preview': '--pane-preview-head',
      'memo-panel': '--pane-memo-head',
      'outline-panel': '--pane-outline-head',
      'search-panel': '--pane-search-head',
      'structure-panel': '--pane-structure-head',
      'character-panel': '--pane-character-head',
      'world-panel': '--pane-world-head',
    };
    const varName = paneMap[paneId] || '';
    const currentColor = varName ? (getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '#f9fafb') : '#f9fafb';

    let presetsHtml = colorPresets.header.map(c =>
      `<button class="color-preset" data-color="${c}" style="width:24px; height:24px; background:${c}; border:1px solid #ccc; border-radius:4px; cursor:pointer;${c === currentColor ? ' outline:2px solid #2563eb;' : ''}"></button>`
    ).join('');

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">ヘッダーカラー</span>
        <button class="picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input type="color" id="header-color-input" value="${currentColor}" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px;">
        <input type="text" id="header-color-text" value="${currentColor}" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetsHtml}
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="picker-cancel">キャンセル</button>
        <button class="btn btn-apply" id="picker-apply">適用</button>
      </div>
    `;

    picker.style.left = '50%';
    picker.style.top = '50%';
    picker.style.transform = 'translate(-50%, -50%)';
    picker.style.display = 'block';

    const colorInput = picker.querySelector('#header-color-input');
    const colorText = picker.querySelector('#header-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.color-preset').forEach(btn => {
      btn.onclick = () => {
        const c = btn.dataset.color;
        colorInput.value = c;
        colorText.value = c;
        picker.querySelectorAll('.color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    picker.querySelector('.picker-close').onclick = () => hideColorPicker();
    picker.querySelector('#picker-cancel').onclick = () => hideColorPicker();
    picker.querySelector('#picker-apply').onclick = () => {
      const color = colorInput.value || '#f9fafb';
      if (varName) {
        document.documentElement.style.setProperty(varName, color);
        try { localStorage.setItem('cc_' + varName.replace('--', ''), color); } catch(e){}
      }
      hideColorPicker();
    };

    picker.onclick = (e) => e.stopPropagation();
  }
  window.showHeaderColorPicker = showHeaderColorPicker;

  function showBgColorPicker(paneId){
    hideContextMenusOnly();

    let picker = document.getElementById('color-picker-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'color-picker-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
      document.body.appendChild(picker);
    }

    const paneMap = {
      'pane-input': '--pane-input-bg',
      'pane-preview': '--pane-preview-bg',
      'memo-panel': '--pane-memo-bg',
      'outline-panel': '--pane-outline-bg',
      'search-panel': '--pane-search-bg',
      'structure-panel': '--pane-structure-bg',
      'character-panel': '--pane-character-bg',
      'world-panel': '--pane-world-bg',
    };
    const varName = paneMap[paneId] || '';
    const currentColor = varName ? (getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || '#ffffff') : '#ffffff';

    let presetsHtml = colorPresets.bg.map(c =>
      `<button class="color-preset" data-color="${c}" style="width:24px; height:24px; background:${c}; border:1px solid #ccc; border-radius:4px; cursor:pointer;${c === currentColor ? ' outline:2px solid #2563eb;' : ''}"></button>`
    ).join('');

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">背景色</span>
        <button class="picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input type="color" id="bg-color-input" value="${currentColor}" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px;">
        <input type="text" id="bg-color-text" value="${currentColor}" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetsHtml}
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="picker-cancel">キャンセル</button>
        <button class="btn btn-apply" id="picker-apply">適用</button>
      </div>
    `;

    picker.style.left = '50%';
    picker.style.top = '50%';
    picker.style.transform = 'translate(-50%, -50%)';
    picker.style.display = 'block';

    const colorInput = picker.querySelector('#bg-color-input');
    const colorText = picker.querySelector('#bg-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.color-preset').forEach(btn => {
      btn.onclick = () => {
        const c = btn.dataset.color;
        colorInput.value = c;
        colorText.value = c;
        picker.querySelectorAll('.color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    picker.querySelector('.picker-close').onclick = () => hideColorPicker();
    picker.querySelector('#picker-cancel').onclick = () => hideColorPicker();
    picker.querySelector('#picker-apply').onclick = () => {
      const color = colorInput.value || '#ffffff';
      if (varName) {
        document.documentElement.style.setProperty(varName, color);
        try { localStorage.setItem('cc_' + varName.replace('--', ''), color); } catch(e){}
      }
      hideColorPicker();
    };

    picker.onclick = (e) => e.stopPropagation();
  }
  window.showBgColorPicker = showBgColorPicker;

  // Show preset panel color picker on right-click of theme select
  function showPresetPanelColorPicker(e){
    e.preventDefault();
    hideContextMenusOnly();

    let picker = document.getElementById('color-picker-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'color-picker-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:280px;';
      document.body.appendChild(picker);
    }

    const presets = colorPresets.bg || ['#ffffff','#f9fafb','#f3f4f6','#e5e7eb','#d1d5db','#fffbeb','#fef3c7','#fde68a','#1f2937','#111827'];

    let presetsHtml = presets.map(c =>
      `<button class="color-preset" data-color="${c}" style="width:28px; height:28px; background:${c}; border:1px solid #888; border-radius:4px; cursor:pointer;"></button>`
    ).join('');

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">プリセットパネルカラー</span>
        <button class="picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="font-size:0.8rem; color:var(--text-muted); margin-bottom:8px;">クリックで全パネルの背景色を変更</div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetsHtml}
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:12px;">
        <input type="color" id="preset-color-input" value="#ffffff" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px;">
        <input type="text" id="preset-color-text" value="#ffffff" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="preset-cancel">キャンセル</button>
        <button class="btn btn-apply" id="preset-apply">全パネルに適用</button>
      </div>
    `;

    picker.style.left = e.clientX + 'px';
    picker.style.top = e.clientY + 'px';
    picker.style.transform = 'none';
    picker.style.display = 'block';

    const colorInput = picker.querySelector('#preset-color-input');
    const colorText = picker.querySelector('#preset-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.color-preset').forEach(btn => {
      btn.onclick = () => {
        const c = btn.dataset.color;
        colorInput.value = c;
        colorText.value = c;
        picker.querySelectorAll('.color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    picker.querySelector('.picker-close').onclick = () => hideColorPicker();
    picker.querySelector('#preset-cancel').onclick = () => hideColorPicker();
    picker.querySelector('#preset-apply').onclick = () => {
      const color = colorInput.value || '#ffffff';
      // Apply to all pane backgrounds
      const vars = ['--pane-input-bg', '--pane-preview-bg', '--pane-memo-bg', '--pane-outline-bg', '--pane-structure-bg', '--pane-search-bg'];
      vars.forEach(v => {
        document.documentElement.style.setProperty(v, color);
        try { localStorage.setItem('cc_' + v.replace('--', ''), color); } catch(e){}
      });
      hideColorPicker();
    };

    picker.onclick = (e) => e.stopPropagation();
  }
  window.showPresetPanelColorPicker = showPresetPanelColorPicker;

  // Add right-click handler for theme select
  function setupThemePresetContextMenu(){
    const themeSelect = document.getElementById('st-theme-preset');
    if (themeSelect) {
      themeSelect.addEventListener('contextmenu', showPresetPanelColorPicker);
    }
  }

  // Initialize context menus
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', setupContextMenus);
    document.addEventListener('DOMContentLoaded', setupThemePresetContextMenu);
  } else {
    setupContextMenus();
    setupThemePresetContextMenu();
  }

  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>

<!-- ===== 構成ボード (Chapter Structure Board) ===== -->
<script>
(function() {
  'use strict';

  // ========== データ構造 ==========
  const STRUCTURE_STORAGE_KEY = 'cc_structure_data';
  let structureData = [];
  let structureNextId = 1;
  let editingCardId = null;
  let draggingCardId = null;

  // ステータスラベル
  const STATUS_LABELS = {
    none: '未着手',
    draft: '草稿',
    revise: '推敲',
    done: '完了'
  };

  // 階層タイプラベル
  const LEVEL_LABELS = {
    chapter: '章',
    episode: '話',
    scene: 'シーン'
  };

  // ========== 初期化 ==========
  function initStructure() {
    loadStructureData();
    renderStructureList();
    setupStructureEventListeners();
    setupStructurePanelContextMenu();
    if (window.loadPanelBackground) window.loadPanelBackground('structure');
  }

  // ========== データ管理 ==========
  function loadStructureData() {
    try {
      const saved = localStorage.getItem(STRUCTURE_STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        structureData = (parsed.data || []).map(card => ({
          ...card,
          selected: false,
          collapsed: !!card.collapsed,
          expanded: !!card.expanded,
          linkedCharacters: card.linkedCharacters || [],
          linkedTerms: card.linkedTerms || [],
          linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
          isNew: false
        }));
        structureNextId = parsed.nextId || 1;
      }
    } catch (e) {
      console.warn('構成データの読み込みに失敗:', e);
      structureData = [];
      structureNextId = 1;
    }
  }

  window.getStructureData = function() { return structureData; };

  function saveStructureData() {
    try {
      const sanitized = structureData.map(({ selected, isNew, ...rest }) => rest);
      localStorage.setItem(STRUCTURE_STORAGE_KEY, JSON.stringify({
        data: sanitized,
        nextId: structureNextId
      }));
    } catch (e) {
      console.warn('構成データの保存に失敗:', e);
    }
  }

  // ========== カード追加 ==========
  function addStructureCard(level) {
    const newCard = {
      id: structureNextId++,
      level: level,
      title: LEVEL_LABELS[level] + structureData.filter(c => c.level === level).length + 1,
      summary: '',
      viewpoint: '',
      tags: [],
      linkedCharacters: [],
      linkedWorlds: [],
      status: 'none',
      tabId: null,
      collapsed: false,
      expanded: false,
      selected: false,
      color: null,
      isNew: true
    };

    // 適切な位置に挿入
    if (level === 'chapter') {
      structureData.push(newCard);
    } else if (level === 'episode') {
      // 最後の章の後、または最後に追加
      const lastChapterIdx = findLastIndex(structureData, c => c.level === 'chapter');
      if (lastChapterIdx >= 0) {
        // その章に属する最後の要素の後に挿入
        let insertIdx = lastChapterIdx + 1;
        while (insertIdx < structureData.length && structureData[insertIdx].level !== 'chapter') {
          insertIdx++;
        }
        structureData.splice(insertIdx, 0, newCard);
      } else {
        structureData.push(newCard);
      }
    } else if (level === 'scene') {
      // 最後の話の後、または最後の章の後、または最後に追加
      const lastEpisodeIdx = findLastIndex(structureData, c => c.level === 'episode');
      const lastChapterIdx = findLastIndex(structureData, c => c.level === 'chapter');
      let insertIdx = structureData.length;
      if (lastEpisodeIdx >= 0) {
        insertIdx = lastEpisodeIdx + 1;
        while (insertIdx < structureData.length && structureData[insertIdx].level === 'scene') {
          insertIdx++;
        }
      } else if (lastChapterIdx >= 0) {
        insertIdx = lastChapterIdx + 1;
      }
      structureData.splice(insertIdx, 0, newCard);
    }

    saveStructureData();
    renderStructureList();
    openEditModal(newCard.id);
  }

  function getStructureSelectedLevel() {
    const select = document.getElementById('structure-add-level');
    return select?.value || 'chapter';
  }

  function createStructureCardFromSelection() {
    addStructureCard(getStructureSelectedLevel());
  }

  function refreshStructurePanel() {
    loadStructureData();
    renderStructureList();
  }

  function findLastIndex(arr, predicate) {
    for (let i = arr.length - 1; i >= 0; i--) {
      if (predicate(arr[i])) return i;
    }
    return -1;
  }

  // ========== レンダリング ==========
  function renderStructureList() {
    const container = document.getElementById('structure-list');
    if (!container) return;

    // 件数を更新
    const countEl = document.getElementById('structure-count');
    if (countEl) {
      const chapters = structureData.filter(c => c.level === 'chapter').length;
      const episodes = structureData.filter(c => c.level === 'episode').length;
      const scenes = structureData.filter(c => c.level === 'scene').length;
      countEl.textContent = `${chapters}章 ${episodes}話 ${scenes}シーン`;
    }

    if (structureData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; padding:20px; text-align:center;">構成カードがありません。<br>上のボタンから章・話・シーンを追加してください。</div>';
      updateStructureBulkButtons();
      return;
    }

    container.innerHTML = '';

    // 折りたたみ状態を追跡
    let parentCollapsed = { chapter: false, episode: false };
    let lastChapterCollapsed = false;
    let lastEpisodeCollapsed = false;

    structureData.forEach((card, index) => {
      // 章の場合：折りたたみ状態をリセット
      if (card.level === 'chapter') {
        lastChapterCollapsed = card.collapsed;
        lastEpisodeCollapsed = false;
      }
      // 話の場合：章が折りたたまれていれば非表示
      else if (card.level === 'episode') {
        if (lastChapterCollapsed) return; // 章が折りたたまれていれば話を非表示
        lastEpisodeCollapsed = card.collapsed;
      }
      // シーンの場合：章または話が折りたたまれていれば非表示
      else if (card.level === 'scene') {
        if (lastChapterCollapsed || lastEpisodeCollapsed) return;
      }

      const cardEl = createCardElement(card, index);
      container.appendChild(cardEl);
    });

    updateStructureBulkButtons();
  }

  function createCardElement(card, index) {
    // 互換性: expanded (boolean) を expandLevel に変換
    if (card.expandLevel === undefined) {
      card.expandLevel = card.expanded ? 2 : 0;
    }
    const expandLevel = card.expandLevel || 0;

    const div = document.createElement('div');
    div.className = `structure-card level-${card.level}`;
    if (expandLevel > 0) div.classList.add('expanded');
    if (expandLevel === 3) div.classList.add('fully-expanded');
    if (card.collapsed) div.classList.add('collapsed');
    if (card.color) {
      div.classList.add('has-custom-color');
      div.style.setProperty('--structure-card-accent', card.color);
      div.style.setProperty('--structure-card-bg', toRgba(card.color, 0.12));
    }
    div.dataset.id = card.id;
    div.draggable = true;

    // ヘッダー部分
    const header = document.createElement('div');
    header.className = 'structure-card-header';
    header.onclick = (e) => {
      if (e.target.closest('button, input')) return;
      toggleStructureExpand(card.id);
    };

    const selection = document.createElement('input');
    selection.type = 'checkbox';
    selection.className = 'structure-select';
    selection.checked = !!card.selected;
    selection.onclick = (e) => {
      e.stopPropagation();
      card.selected = selection.checked;
      saveStructureData();
    };
    header.appendChild(selection);

    // 折りたたみトグル（章/話のみ）
    const toggle = document.createElement('span');
    toggle.className = 'structure-toggle';
    if (card.level !== 'scene') {
      toggle.textContent = card.collapsed ? '▶' : '▼';
      toggle.onclick = (e) => {
        e.stopPropagation();
        card.collapsed = !card.collapsed;
        saveStructureData();
        renderStructureList();
      };
    }
    header.appendChild(toggle);

    // 展開レベルトグル（4段階）
    const expandToggle = document.createElement('span');
    expandToggle.className = 'structure-expand-toggle';
    const expandSymbols = ['▶', '▽', '▼', '◆'];
    const expandTitles = ['名前のみ', 'タグのみ', 'タグ+プレビュー', 'すべて表示'];
    const lvl = Math.min(Math.max(expandLevel || 0, 0), 3);
    expandToggle.textContent = expandSymbols[lvl];
    expandToggle.title = expandTitles[lvl];
    expandToggle.onclick = (e) => {
      e.stopPropagation();
      toggleStructureExpand(card.id);
    };
    header.appendChild(expandToggle);

    // タイトル
    const title = document.createElement('span');
    title.className = 'structure-title';
    title.textContent = card.title;
    title.ondblclick = (e) => {
      e.stopPropagation();
      if (typeof startInlineEdit === 'function') {
        startInlineEdit(title, card.title, (newTitle) => {
          card.title = newTitle;
          saveStructureData();
        });
      }
    };
    header.appendChild(title);

    // ステータスバッジ
    const status = document.createElement('span');
    status.className = `structure-status status-${card.status}`;
    status.textContent = STATUS_LABELS[card.status];
    header.appendChild(status);

    const moveGroup = document.createElement('div');
    moveGroup.className = 'structure-move-group';
    const moveUp = document.createElement('button');
    moveUp.type = 'button';
    moveUp.className = 'structure-move-btn';
    moveUp.textContent = '↑';
    moveUp.title = '上のカードと入れ替える';
    moveUp.onclick = (e) => {
      e.stopPropagation();
      moveStructureCard(card.id, -1);
    };
    const moveDown = document.createElement('button');
    moveDown.type = 'button';
    moveDown.className = 'structure-move-btn';
    moveDown.textContent = '↓';
    moveDown.title = '下のカードと入れ替える';
    moveDown.onclick = (e) => {
      e.stopPropagation();
      moveStructureCard(card.id, 1);
    };
    moveGroup.appendChild(moveUp);
    moveGroup.appendChild(moveDown);
    header.appendChild(moveGroup);

    div.appendChild(header);

    // expandLevel === 1: タグのみ表示
    if (expandLevel === 1) {
      const tagsOnlyBody = document.createElement('div');
      tagsOnlyBody.className = 'structure-card-body';

      if (card.viewpoint) {
        const viewpointField = document.createElement('div');
        viewpointField.className = 'structure-field';
        viewpointField.innerHTML = `<div class="structure-field-label">視点</div><span class="structure-viewpoint">${escapeHtml(card.viewpoint)}</span>`;
        tagsOnlyBody.appendChild(viewpointField);
      }

      if (card.tags && card.tags.length > 0) {
        const tagsField = document.createElement('div');
        tagsField.className = 'structure-field';
        tagsField.innerHTML = `<div class="structure-field-label">舞台</div><div class="structure-tags">${card.tags.map(t => `<span class="structure-tag">${escapeHtml(t)}</span>`).join('')}</div>`;
        tagsOnlyBody.appendChild(tagsField);
      }

      div.appendChild(tagsOnlyBody);
    }

    // expandLevel === 2: タグ + 要約1行プレビュー
    if (expandLevel === 2) {
      const previewBody = document.createElement('div');
      previewBody.className = 'structure-card-body';

      if (card.viewpoint) {
        const viewpointField = document.createElement('div');
        viewpointField.className = 'structure-field';
        viewpointField.innerHTML = `<div class="structure-field-label">視点</div><span class="structure-viewpoint">${escapeHtml(card.viewpoint)}</span>`;
        previewBody.appendChild(viewpointField);
      }

      if (card.tags && card.tags.length > 0) {
        const tagsField = document.createElement('div');
        tagsField.className = 'structure-field';
        tagsField.innerHTML = `<div class="structure-field-label">舞台</div><div class="structure-tags">${card.tags.map(t => `<span class="structure-tag">${escapeHtml(t)}</span>`).join('')}</div>`;
        previewBody.appendChild(tagsField);
      }

      if (card.summary) {
        const summaryPreview = document.createElement('div');
        summaryPreview.className = 'structure-summary-preview';
        const firstLine = card.summary.split('\n')[0].substring(0, 80);
        summaryPreview.textContent = firstLine + (card.summary.length > 80 ? '...' : '');
        previewBody.appendChild(summaryPreview);
      }

      div.appendChild(previewBody);
    }

    // expandLevel === 3: 全詳細表示
    const body = document.createElement('div');
    body.className = 'structure-card-body';
    if (expandLevel !== 3) body.style.display = 'none';

    if (card.summary) {
      const summaryField = document.createElement('div');
      summaryField.className = 'structure-field';
      summaryField.innerHTML = `<div class="structure-field-label">要約</div><div class="structure-summary">${escapeHtml(card.summary)}</div>`;
      body.appendChild(summaryField);
    }

    if (card.viewpoint) {
      const viewpointField = document.createElement('div');
      viewpointField.className = 'structure-field';
      viewpointField.innerHTML = `<div class="structure-field-label">視点</div><span class="structure-viewpoint">${escapeHtml(card.viewpoint)}</span>`;
      body.appendChild(viewpointField);
    }

    if (card.tags && card.tags.length > 0) {
      const tagsField = document.createElement('div');
      tagsField.className = 'structure-field';
      tagsField.innerHTML = `<div class="structure-field-label">舞台</div><div class="structure-tags">${card.tags.map(t => `<span class="structure-tag">${escapeHtml(t)}</span>`).join('')}</div>`;
      body.appendChild(tagsField);
    }

    if (card.tabId && window.inputTabs) {
      const tab = window.inputTabs.find(t => t.id === card.tabId);
      if (tab) {
        const tabField = document.createElement('div');
        tabField.className = 'structure-field';
        tabField.innerHTML = `<div class="structure-field-label">紐づけタブ</div><span style="color:#2563eb; cursor:pointer;" onclick="if(window.switchTab) window.switchTab(${card.tabId})">📄 ${escapeHtml(tab.name)}</span>`;
        body.appendChild(tabField);
      }
    }

    // リンクされた登場人物・世界観を表示
    const hasLinkedChars = card.linkedCharacters && card.linkedCharacters.length > 0;
    const hasLinkedWorlds = card.linkedWorlds && card.linkedWorlds.length > 0;
    const hasLinkedTerms = card.linkedTerms && card.linkedTerms.length > 0;
    if (hasLinkedChars || hasLinkedWorlds || hasLinkedTerms) {
      const linkedSection = document.createElement('div');
      linkedSection.className = 'structure-linked-section';

      if (hasLinkedChars) {
        const charData = window.getCharacterData ? window.getCharacterData() : [];
        const linkedCharsHtml = card.linkedCharacters.map(cid => {
          const char = charData.find(c => c.id === cid);
          if (!char) return '';
          return `<span class="structure-linked-item structure-linked-character" onclick="event.stopPropagation(); goToLinkedPanel('character', ${cid})"><span class="structure-linked-icon">👤</span><span class="structure-linked-text">${escapeHtml(char.name)}</span></span>`;
        }).filter(h => h).join('');
        if (linkedCharsHtml) {
          linkedSection.innerHTML += `<div class="structure-linked-label">登場人物</div><div class="structure-linked-items">${linkedCharsHtml}</div>`;
        }
      }

      if (hasLinkedWorlds) {
        const worldData = window.getWorldData ? window.getWorldData() : [];
        const linkedWorldsHtml = card.linkedWorlds.map(wid => {
          const world = worldData.find(w => w.id === wid);
          if (!world) return '';
          return `<span class="structure-linked-item structure-linked-world" onclick="event.stopPropagation(); goToLinkedPanel('world', ${wid})"><span class="structure-linked-icon">🌍</span><span class="structure-linked-text">${escapeHtml(world.name)}</span></span>`;
        }).filter(h => h).join('');
        if (linkedWorldsHtml) {
          linkedSection.innerHTML += `<div class="structure-linked-label" style="margin-top:6px;">世界観</div><div class="structure-linked-items">${linkedWorldsHtml}</div>`;
        }
      }

      if (hasLinkedTerms) {
        const termData = window.getTermsData ? window.getTermsData() : [];
        const linkedTermsHtml = card.linkedTerms.map(tid => {
          const term = termData.find(t => t.id === tid);
          if (!term) return '';
          const label = (term.category ? `${escapeHtml(term.category)} / ` : '') + escapeHtml(term.name || '');
          return `<span class="structure-linked-item structure-linked-term" onclick="event.stopPropagation(); goToLinkedPanel('terms', ${tid})"><span class="structure-linked-icon">📚</span><span class="structure-linked-text">${label}</span></span>`;
        }).filter(h => h).join('');
        if (linkedTermsHtml) {
          linkedSection.innerHTML += `<div class="structure-linked-label" style="margin-top:6px;">用語</div><div class="structure-linked-items">${linkedTermsHtml}</div>`;
        }
      }

      body.appendChild(linkedSection);
    }

    // アクションボタン
    const actions = document.createElement('div');
    actions.className = 'structure-card-actions';
    actions.innerHTML = `
      <button onclick="openEditModal(${card.id})">✏️ 編集</button>
      <button class="btn-delete" onclick="deleteStructureCard(${card.id})">🗑 削除</button>
    `;
    body.appendChild(actions);

    div.appendChild(body);

    // ドラッグイベント
    div.addEventListener('dragstart', handleDragStart);
    div.addEventListener('dragend', handleDragEnd);
    div.addEventListener('dragover', handleDragOver);
    div.addEventListener('drop', handleDrop);
    div.addEventListener('dragleave', handleDragLeave);
    div.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      showStructureContextMenu(e, card.id);
    });

    return div;
  }

  function escapeHtml(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
  }

  function findChapterIndexForIndex(startIdx) {
    for (let i = startIdx; i >= 0; i--) {
      if (structureData[i]?.level === 'chapter') return i;
    }
    return -1;
  }

  function findEpisodeIndexForIndex(startIdx) {
    for (let i = startIdx; i >= 0; i--) {
      if (structureData[i]?.level === 'episode') return i;
      if (structureData[i]?.level === 'chapter') return -1;
    }
    return -1;
  }

  function findChapterEndIndex(chapterIdx) {
    let i = chapterIdx + 1;
    while (i < structureData.length && structureData[i].level !== 'chapter') {
      i++;
    }
    return i;
  }

  function findEpisodeEndIndex(episodeIdx) {
    let i = episodeIdx + 1;
    while (i < structureData.length && structureData[i].level === 'scene') {
      i++;
    }
    return i;
  }

  // カードとその子要素のインデックス範囲を取得
  function getCardRangeWithChildren(cardIdx) {
    const card = structureData[cardIdx];
    if (!card) return { start: cardIdx, end: cardIdx };

    let endIdx = cardIdx;
    if (card.level === 'chapter') {
      // 次の章まで、または配列の終わりまで
      for (let i = cardIdx + 1; i < structureData.length; i++) {
        if (structureData[i].level === 'chapter') break;
        endIdx = i;
      }
    } else if (card.level === 'episode') {
      // 次の章または話まで、または配列の終わりまで
      for (let i = cardIdx + 1; i < structureData.length; i++) {
        if (structureData[i].level === 'chapter' || structureData[i].level === 'episode') break;
        endIdx = i;
      }
    }
    // シーンは自身のみ

    return { start: cardIdx, end: endIdx };
  }

  function moveCardToIndex(dragIdx, insertIdx) {
    if (dragIdx === insertIdx) return;
    const [card] = structureData.splice(dragIdx, 1);
    let targetIdx = insertIdx;
    if (dragIdx < insertIdx) targetIdx -= 1;
    structureData.splice(targetIdx, 0, card);
  }

  // カードと子要素を一緒に移動
  function moveCardWithChildrenToIndex(dragIdx, insertIdx) {
    const range = getCardRangeWithChildren(dragIdx);
    const count = range.end - range.start + 1;

    if (dragIdx === insertIdx) return;

    // 移動するカードを抽出
    const cardsToMove = structureData.splice(range.start, count);

    // 挿入位置を調整
    let targetIdx = insertIdx;
    if (range.start < insertIdx) {
      targetIdx -= count;
    }

    // カードを挿入
    structureData.splice(targetIdx, 0, ...cardsToMove);
  }

  function moveCardToChapter(dragIdx, chapterIdx) {
    if (chapterIdx < 0) return;
    const insertIdx = findChapterEndIndex(chapterIdx);
    moveCardWithChildrenToIndex(dragIdx, insertIdx);
  }

  function moveCardToEpisode(dragIdx, episodeIdx) {
    if (episodeIdx < 0) return;
    const insertIdx = findEpisodeEndIndex(episodeIdx);
    moveCardWithChildrenToIndex(dragIdx, insertIdx);
  }

  function moveStructureCard(cardId, direction) {
    const idx = structureData.findIndex(c => c.id === cardId);
    if (idx < 0) return;

    const card = structureData[idx];
    const range = getCardRangeWithChildren(idx);
    const count = range.end - range.start + 1;

    if (direction === -1) {
      // 上に移動
      if (idx <= 0) return;
      // 上のカードの位置を探す
      let targetIdx = idx - 1;
      // 上のカードとその子要素をスキップ
      if (targetIdx >= 0) {
        // 前のカードの先頭を見つける
        while (targetIdx > 0) {
          const prevCard = structureData[targetIdx - 1];
          if (prevCard.level === 'chapter') break;
          if (prevCard.level === 'episode' && card.level === 'chapter') break;
          if (prevCard.level === card.level) break;
          targetIdx--;
        }
        // 移動するカードを抽出して挿入
        const cardsToMove = structureData.splice(range.start, count);
        structureData.splice(targetIdx, 0, ...cardsToMove);
      }
    } else if (direction === 1) {
      // 下に移動
      const nextIdx = range.end + 1;
      if (nextIdx >= structureData.length) return;
      // 次のカードとその子要素を取得
      const nextRange = getCardRangeWithChildren(nextIdx);
      // 移動するカードを抽出
      const cardsToMove = structureData.splice(range.start, count);
      // 次のカード(とその子要素)の後に挿入
      const insertPos = nextRange.end - count + 1;
      structureData.splice(insertPos, 0, ...cardsToMove);
    }

    saveStructureData();
    renderStructureList();
  }

  function duplicateStructureCard(cardId) {
    const idx = structureData.findIndex(c => c.id === cardId);
    if (idx < 0) return;
    const card = structureData[idx];
    const copy = {
      ...card,
      id: structureNextId++,
      title: `${card.title}（コピー）`,
      selected: false
    };
    structureData.splice(idx + 1, 0, copy);
    saveStructureData();
    renderStructureList();
  }

  function deleteSelectedStructureCards() {
    const hasSelected = structureData.some(c => c.selected);
    if (!hasSelected) {
      alert('選択されたカードがありません。');
      return;
    }
    if (!confirm('選択した構成カードを削除しますか？')) return;
    structureData = structureData.filter(c => !c.selected);
    saveStructureData();
    renderStructureList();
  }

  function deleteAllStructureCards() {
    if (structureData.length === 0) {
      alert('削除する構成カードがありません。');
      return;
    }
    if (!confirm('構成カードをすべて削除しますか？')) return;
    structureData = [];
    structureNextId = 1;
    saveStructureData();
    renderStructureList();
  }

  function buildStructureIndexMap() {
    let chapterNum = 0;
    let episodeNum = 0;
    const map = new Map();
    structureData.forEach(card => {
      if (card.level === 'chapter') {
        chapterNum++;
        episodeNum = 0;
        map.set(card.id, { chapterNum, episodeNum: null });
      } else if (card.level === 'episode') {
        episodeNum++;
        map.set(card.id, { chapterNum, episodeNum });
      } else {
        map.set(card.id, { chapterNum, episodeNum });
      }
    });
    return map;
  }

  function getMoveTargetsForCard(card) {
    const map = buildStructureIndexMap();
    if (card.level === 'episode') {
      return structureData
        .filter(c => c.level === 'chapter')
        .map(ch => {
          const meta = map.get(ch.id) || { chapterNum: 0 };
          return { type: 'chapter', id: ch.id, label: `第${meta.chapterNum}章: ${ch.title}` };
        });
    }
    if (card.level === 'scene') {
      const episodes = structureData.filter(c => c.level === 'episode');
      if (episodes.length > 0) {
        return episodes.map(ep => {
          const meta = map.get(ep.id) || { chapterNum: 0, episodeNum: 0 };
          return { type: 'episode', id: ep.id, label: `第${meta.chapterNum}章 第${meta.episodeNum}話: ${ep.title}` };
        });
      }
      return structureData
        .filter(c => c.level === 'chapter')
        .map(ch => {
          const meta = map.get(ch.id) || { chapterNum: 0 };
          return { type: 'chapter', id: ch.id, label: `第${meta.chapterNum}章: ${ch.title}` };
        });
    }
    return [];
  }

  function moveCardToChapterById(cardId, chapterId) {
    const dragIdx = structureData.findIndex(c => c.id === cardId);
    const chapterIdx = structureData.findIndex(c => c.id === chapterId);
    if (dragIdx < 0 || chapterIdx < 0) return;
    moveCardToChapter(dragIdx, chapterIdx);
    saveStructureData();
    renderStructureList();
  }

  function moveCardToEpisodeById(cardId, episodeId) {
    const dragIdx = structureData.findIndex(c => c.id === cardId);
    const episodeIdx = structureData.findIndex(c => c.id === episodeId);
    if (dragIdx < 0 || episodeIdx < 0) return;
    moveCardToEpisode(dragIdx, episodeIdx);
    saveStructureData();
    renderStructureList();
  }

  let structureMenuClickHandler = null;
  let structureColorPickerHandler = null;

  // コンテキストメニューの位置を画面内に収める
  function adjustContextMenuPosition(menu, x, y) {
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';
    menu.style.display = 'block';
    // メニューの実際のサイズを取得
    const rect = menu.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    // 右端を超える場合は左に寄せる
    if (rect.right > viewportWidth) {
      menu.style.left = Math.max(0, viewportWidth - rect.width - 10) + 'px';
    }
    // 下端を超える場合は上に寄せる
    if (rect.bottom > viewportHeight) {
      menu.style.top = Math.max(0, viewportHeight - rect.height - 10) + 'px';
    }
  }
  window.adjustContextMenuPosition = adjustContextMenuPosition;

  // カード名のインライン編集機能
  function startInlineEdit(titleElement, currentValue, onSave) {
    if (titleElement.querySelector('input')) return; // 既に編集中
    const originalText = titleElement.textContent;
    const input = document.createElement('input');
    input.type = 'text';
    input.value = currentValue;
    input.style.cssText = 'width:100%; padding:2px 4px; border:1px solid var(--border-color); border-radius:4px; font-size:inherit; font-weight:inherit; background:var(--panel-bg); color:var(--text-color);';
    titleElement.textContent = '';
    titleElement.appendChild(input);
    input.focus();
    input.select();

    const finish = (save) => {
      const newValue = input.value.trim();
      if (save && newValue && newValue !== currentValue) {
        onSave(newValue);
        titleElement.textContent = newValue;
      } else {
        titleElement.textContent = originalText;
      }
    };

    input.onblur = () => finish(true);
    input.onkeydown = (e) => {
      if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
      if (e.key === 'Escape') { e.preventDefault(); finish(false); }
    };
    input.onclick = (e) => e.stopPropagation();
  }
  window.startInlineEdit = startInlineEdit;

  function showStructurePanelContextMenu(e) {
    if (typeof window.hideAllContextMenus === 'function') window.hideAllContextMenus();
    let menu = document.getElementById('structure-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'structure-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:200px;';
      document.body.appendChild(menu);
    }

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-item" data-action="bg-color">🎨 背景色の変更</div>
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'new-card') createStructureCardFromSelection();
        if (action === 'bg-color' && window.openPanelBackgroundColorPicker) {
          window.openPanelBackgroundColorPicker('structure');
        }
        hideStructureContextMenu();
      };
    });

    adjustContextMenuPosition(menu, e.clientX, e.clientY);

    if (structureMenuClickHandler) {
      document.removeEventListener('click', structureMenuClickHandler);
    }
    structureMenuClickHandler = (ev) => {
      if (!ev.target.closest('#structure-context-menu')) {
        hideStructureContextMenu();
      }
    };
    setTimeout(() => {
      document.addEventListener('click', structureMenuClickHandler);
    }, 0);
  }

  function showStructureContextMenu(e, cardId) {
    if (typeof window.hideAllContextMenus === 'function') window.hideAllContextMenus();
    let menu = document.getElementById('structure-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'structure-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:200px;';
      document.body.appendChild(menu);
    }

    const card = structureData.find(c => c.id === cardId);
    if (!card) return;

    const expandLevel = card.expandLevel || 0;

    const moveTargets = getMoveTargetsForCard(card);
    const moveSection = moveTargets.length
      ? `
        <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
        <div class="context-menu-item" style="color:var(--text-muted); pointer-events:none;">移動先</div>
        ${moveTargets.map(t => `<div class="context-menu-item" data-action="move" data-target-type="${t.type}" data-target-id="${t.id}">➡ ${t.label}</div>`).join('')}
      `
      : '';

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="edit">✏️ 編集</div>
      <div class="context-menu-item" data-action="duplicate">📋 複製</div>
      <div class="context-menu-item" data-action="toggle">↕ 次の展開レベル</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="expand-0" style="padding-left:24px;">▶ 名前のみ${expandLevel === 0 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-1" style="padding-left:24px;">▽ タグのみ${expandLevel === 1 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-2" style="padding-left:24px;">▼ タグ+プレビュー${expandLevel === 2 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-3" style="padding-left:24px;">◆ すべて表示${expandLevel === 3 ? ' ✓' : ''}</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="color">🎨 カード色を変更</div>
      <div class="context-menu-item" data-action="reset-color">↩ 色をリセット</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="move-up">⬆ 上へ</div>
      <div class="context-menu-item" data-action="move-down">⬇ 下へ</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="delete" style="color:#dc2626;">🗑 削除</div>
      ${moveSection}
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'new-card') createStructureCardFromSelection();
        if (action === 'edit') openEditModal(cardId);
        if (action === 'duplicate') duplicateStructureCard(cardId);
        if (action === 'toggle') {
          const target = structureData.find(c => c.id === cardId);
          if (target) {
            target.expandLevel = ((target.expandLevel || 0) + 1) % 4;
            target.expanded = target.expandLevel > 0;
            saveStructureData();
            renderStructureList();
          }
        }
        if (action === 'expand-0' || action === 'expand-1' || action === 'expand-2' || action === 'expand-3') {
          const target = structureData.find(c => c.id === cardId);
          if (target) {
            target.expandLevel = parseInt(action.split('-')[1]);
            target.expanded = target.expandLevel > 0;
            saveStructureData();
            renderStructureList();
          }
        }
        if (action === 'move-up') moveStructureCard(cardId, -1);
        if (action === 'move-down') moveStructureCard(cardId, 1);
        if (action === 'delete') deleteStructureCard(cardId);
        if (action === 'color') openStructureCardColorPicker(cardId);
        if (action === 'reset-color') resetStructureCardColor(cardId);
        if (action === 'move') {
          const type = item.dataset.targetType;
          const targetId = parseInt(item.dataset.targetId);
          if (type === 'chapter') moveCardToChapterById(cardId, targetId);
          if (type === 'episode') moveCardToEpisodeById(cardId, targetId);
        }
        hideStructureContextMenu();
      };
    });

    adjustContextMenuPosition(menu, e.clientX, e.clientY);

    if (structureMenuClickHandler) {
      document.removeEventListener('click', structureMenuClickHandler);
    }
    structureMenuClickHandler = (ev) => {
      if (!ev.target.closest('#structure-context-menu')) {
        hideStructureContextMenu();
      }
    };
    setTimeout(() => {
      document.addEventListener('click', structureMenuClickHandler);
    }, 0);
  }

  function hideStructureContextMenu() {
    const menu = document.getElementById('structure-context-menu');
    if (menu) menu.style.display = 'none';
    if (structureMenuClickHandler) {
      document.removeEventListener('click', structureMenuClickHandler);
      structureMenuClickHandler = null;
    }
  }

  function setupStructurePanelContextMenu() {
    const list = document.getElementById('structure-list');
    if (!list) return;
    list.addEventListener('contextmenu', (e) => {
      if (e.target.closest('.structure-card')) return;
      e.preventDefault();
      showStructurePanelContextMenu(e);
    });
  }

  function openStructureCardColorPicker(cardId) {
    const card = structureData.find(c => c.id === cardId);
    if (!card) return;

    // カスタムカラーピッカーUIを作成
    let picker = document.getElementById('structure-card-color-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'structure-card-color-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
      document.body.appendChild(picker);
    }

    const currentColor = card.color || '#6366f1';
    const presetColors = ['#6366f1', '#8b5cf6', '#a78bfa', '#3b82f6', '#06b6d4', '#10b981', '#22c55e', '#eab308', '#f59e0b', '#ef4444', '#ec4899', '#8b5cf6'];

    const presetsHtml = presetColors.map(c =>
      `<button class="structure-color-preset" data-color="${c}" style="width:24px; height:24px; background:${c}; border:1px solid #ccc; border-radius:4px; cursor:pointer;${c === currentColor ? ' outline:2px solid #2563eb;' : ''}"></button>`
    ).join('');

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">カードの色</span>
        <button class="structure-picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input type="color" id="structure-card-color-input" value="${currentColor}" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px; cursor:pointer;">
        <input type="text" id="structure-card-color-text" value="${currentColor}" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetsHtml}
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="structure-picker-cancel">キャンセル</button>
        <button class="btn btn-apply" id="structure-picker-apply">適用</button>
      </div>
    `;

    picker.style.left = '50%';
    picker.style.top = '50%';
    picker.style.transform = 'translate(-50%, -50%)';
    picker.style.display = 'block';

    const colorInput = picker.querySelector('#structure-card-color-input');
    const colorText = picker.querySelector('#structure-card-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.structure-color-preset').forEach(btn => {
      btn.onclick = () => {
        const c = btn.dataset.color;
        colorInput.value = c;
        colorText.value = c;
        picker.querySelectorAll('.structure-color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    const closePopup = () => {
      picker.style.display = 'none';
    };

    picker.querySelector('.structure-picker-close').onclick = closePopup;
    picker.querySelector('#structure-picker-cancel').onclick = closePopup;
    picker.querySelector('#structure-picker-apply').onclick = () => {
      card.color = colorInput.value;
      saveStructureData();
      renderStructureList();
      closePopup();
    };
  }

  function resetStructureCardColor(cardId) {
    const card = structureData.find(c => c.id === cardId);
    if (!card) return;
    card.color = null;
    saveStructureData();
    renderStructureList();
  }

  function toRgba(color, alpha = 1) {
    if (!color) return `rgba(0,0,0,${alpha})`;
    if (color.startsWith('#')) {
      const hex = color.replace('#', '');
      const size = hex.length === 3 ? 1 : 2;
      const to255 = (idx) => {
        const part = hex.substr(idx, size);
        return parseInt(size === 1 ? part + part : part, 16);
      };
      const r = to255(0);
      const g = to255(size);
      const b = to255(size * 2);
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    if (color.startsWith('rgb')) {
      const nums = color.replace(/rgba?\(|\)/g, '').split(',').map(n => n.trim());
      const [r, g, b] = nums;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }
    return color;
  }

  // ========== 一括展開レベル（4段階）: 構成 ==========
  const BULK_EXPAND_SYMBOLS = ['▶', '▽', '▼', '◆'];
  const BULK_EXPAND_TITLES  = ['名前のみ', 'タグのみ', 'タグ+プレビュー', 'すべて表示'];

  function getUniformStructureExpandLevel() {
    if (!Array.isArray(structureData) || structureData.length === 0) return { level: 0, mixed: false };
    const getLvl = (c) => (c && c.expandLevel !== undefined) ? (c.expandLevel || 0) : (c && c.expanded ? 2 : 0);
    const base = getLvl(structureData[0]);
    for (const c of structureData) {
      if (getLvl(c) !== base) return { level: base, mixed: true };
    }
    return { level: base, mixed: false };
  }

  function updateStructureBulkButtons() {
    const upBtn = document.getElementById('btn-structure-bulk-up');
    const downBtn = document.getElementById('btn-structure-bulk-down');
    if (!upBtn || !downBtn) return;

    const info = getUniformStructureExpandLevel();

    let sym, title;
    if (info.mixed) {
      sym = '≋';
      title = '混在';
    } else {
      const level = Math.min(Math.max(info.level || 0, 0), 3);
      sym = BULK_EXPAND_SYMBOLS[level];
      title = BULK_EXPAND_TITLES[level];
    }

    upBtn.textContent = `全展開 +${sym}`;
    downBtn.textContent = `全折畳 -${sym}`;

    if (info.mixed) {
      upBtn.title = '一括で表示段階を上げます（現在: 混在 / カードごとに段階が異なります）';
      downBtn.title = '一括で最小表示（名前のみ）にします（現在: 混在）';
    } else {
      upBtn.title = `一括で表示段階を上げます（現在: ${sym} ${title}）`;
      downBtn.title = `一括で最小表示（名前のみ）にします（現在: ${sym} ${title}）`;
    }
  }

  // 現在の一括レベル（混在状態からの基準用）
  let structureBulkExpandLevel = 0;

  function cycleStructureBulkExpand(delta) {
    const info = getUniformStructureExpandLevel();
    const base = info.mixed ? (typeof structureBulkExpandLevel === 'number' ? structureBulkExpandLevel : (info.level || 0)) : (info.level || 0);
    const next = (base + delta + 4) % 4;
    structureBulkExpandLevel = next;

    structureData.forEach(c => {
      c.expandLevel = next;
      c.expanded = next > 0;
      // 注意: collapsed（章/話の折畳）は別概念なので触れない
    });

    saveStructureData();
    renderStructureList();
  }

  // ========== ドラッグ＆ドロップ ==========
  function handleDragStart(e) {
    draggingCardId = parseInt(e.currentTarget.dataset.id);
    e.currentTarget.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  }

  function handleDragEnd(e) {
    e.currentTarget.classList.remove('dragging');
    document.querySelectorAll('.structure-card.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggingCardId = null;
  }

  function handleDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    const card = e.currentTarget;
    if (parseInt(card.dataset.id) !== draggingCardId) {
      card.classList.add('drag-over');
    }
  }

  function handleDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
  }

  function handleDrop(e) {
    e.preventDefault();
    const targetId = parseInt(e.currentTarget.dataset.id);
    e.currentTarget.classList.remove('drag-over');

    if (draggingCardId === null || draggingCardId === targetId) return;

    const dragIdx = structureData.findIndex(c => c.id === draggingCardId);
    const targetIdx = structureData.findIndex(c => c.id === targetId);

    if (dragIdx < 0 || targetIdx < 0) return;

    const dragCard = structureData[dragIdx];
    const targetCard = structureData[targetIdx];

    if (dragCard.level === targetCard.level) {
      // 同じレベル間の移動: 子要素も一緒に移動
      moveCardWithChildrenToIndex(dragIdx, targetIdx);
    } else if (dragCard.level === 'scene' && targetCard.level === 'episode') {
      // シーンを話にドロップ: その話の下に移動
      moveCardToEpisode(dragIdx, targetIdx);
    } else if (dragCard.level === 'scene' && targetCard.level === 'chapter') {
      // シーンを章にドロップ: その章の下に移動
      moveCardToChapter(dragIdx, targetIdx);
    } else if (dragCard.level === 'episode' && targetCard.level === 'chapter') {
      // 話を章にドロップ: その章の下に移動（配下のシーンも一緒に）
      moveCardToChapter(dragIdx, targetIdx);
    } else if (dragCard.level === 'episode' && targetCard.level === 'scene') {
      // 話をシーンにドロップ: そのシーンの章に移動
      const chapterIdx = findChapterIndexForIndex(targetIdx);
      if (chapterIdx >= 0) moveCardToChapter(dragIdx, chapterIdx);
    } else if (dragCard.level === 'chapter' && targetCard.level !== 'chapter') {
      // 章を話/シーンにドロップ: 直近の章の位置に移動
      const targetChapterIdx = findChapterIndexForIndex(targetIdx);
      if (targetChapterIdx >= 0) {
        moveCardWithChildrenToIndex(dragIdx, targetChapterIdx);
      }
    } else {
      moveCardWithChildrenToIndex(dragIdx, targetIdx);
    }

    saveStructureData();
    renderStructureList();
  }

  // ========== 編集モーダル ==========
  function openEditModal(cardId) {
    const card = structureData.find(c => c.id === cardId);
    if (!card) return;

    editingCardId = cardId;

    // フォームに値を設定
    document.getElementById('structure-edit-name').value = card.title;
    document.getElementById('structure-edit-summary').value = card.summary;
    document.getElementById('structure-edit-viewpoint').value = card.viewpoint;
    document.getElementById('structure-edit-tags').value = (card.tags || []).join(', ');
    document.getElementById('structure-edit-status').value = card.status;

    // 文字数カウント更新
    updateSummaryCount();

    // タブ選択肢を更新
    const tabSelect = document.getElementById('structure-edit-tab');
    tabSelect.innerHTML = '<option value="">（なし）</option>';
    if (window.inputTabs) {
      window.inputTabs.forEach(tab => {
        const opt = document.createElement('option');
        opt.value = tab.id;
        opt.textContent = tab.name;
        if (card.tabId === tab.id) opt.selected = true;
        tabSelect.appendChild(opt);
      });
    }

    // 登場人物チェックボックスを生成
    populateCharacterCheckboxes(card.linkedCharacters || []);

    // 世界観チェックボックスを生成
    populateWorldCheckboxes(card.linkedWorlds || []);
    populateStructureTermCheckboxes(card.linkedTerms || []);

    // タグサジェストを閉じる
    const tagSuggest = document.getElementById('structure-tag-suggestions');
    if (tagSuggest) tagSuggest.style.display = 'none';

    // タイトル更新
    document.getElementById('structure-edit-title').textContent = LEVEL_LABELS[card.level] + 'を編集';

    // モーダル表示
    document.getElementById('structure-edit-modal').classList.add('show');
  }

  function populateCharacterCheckboxes(selectedIds) {
    const container = document.getElementById('structure-edit-characters');
    if (!container) return;

    const characterData = window.getCharacterData ? window.getCharacterData() : [];
    if (characterData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">登場人物パネルにキャラクターを追加してください</div>';
      return;
    }

    const CHARACTER_ROLES = { protagonist: '主人公', heroine: 'ヒロイン', antagonist: '敵役', supporting: 'サブ', mob: 'モブ' };
    container.innerHTML = characterData.map(c => {
      const selected = selectedIds.includes(c.id) ? 'selected' : '';
      const roleLabel = CHARACTER_ROLES[c.role] || c.role || '';
      return `<span class="link-tag-item ${selected}" data-id="${c.id}" onclick="toggleStructureCharacterLink(${c.id})"><span class="link-tag-text">${escapeHtml(c.name)}</span>${roleLabel ? `<span class="link-tag-badge">${roleLabel}</span>` : ''}</span>`;
    }).join('');
  }

  function toggleStructureCharacterLink(id) {
    const container = document.getElementById('structure-edit-characters');
    const item = container?.querySelector(`[data-id="${id}"]`);
    if (item) item.classList.toggle('selected');
  }

  function populateWorldCheckboxes(selectedIds) {
    const container = document.getElementById('structure-edit-worlds');
    if (!container) return;

    const worldData = window.getWorldData ? window.getWorldData() : [];
    if (worldData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">世界観パネルに設定を追加してください</div>';
      return;
    }

    const WORLD_LEVELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
    container.innerHTML = worldData.map(w => {
      const selected = selectedIds.includes(w.id) ? 'selected' : '';
      const levelLabel = WORLD_LEVELS[w.level] || w.level || '';
      return `<span class="link-tag-item ${selected}" data-id="${w.id}" onclick="toggleStructureWorldLink(${w.id})"><span class="link-tag-text"><span class="link-tag-text">${escapeHtml(w.name)}</span></span>${levelLabel ? `<span class="link-tag-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');
  }


function populateStructureTermCheckboxes(selectedIds){
  const container = document.getElementById('structure-edit-terms');
  if (!container) return;
  const terms = window.getTermsData ? window.getTermsData() : [];
  if (!terms.length){
    container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">用語パネルにカードを追加してください</div>';
    return;
  }
  container.innerHTML = terms.map(t=>{
    const selected = selectedIds.includes(t.id) ? 'selected' : '';
    const label = (t.category ? `${escapeHtml(t.category)} / ` : '') + escapeHtml(t.name||'');
    return `<span class="link-tag-item ${selected}" data-id="${t.id}" onclick="toggleStructureTermLink(${t.id})">${label}</span>`;
  }).join('');
}
function toggleStructureTermLink(termId){
  const container = document.getElementById('structure-edit-terms');
  if (!container) return;
  const tag = container.querySelector(`.link-tag-item[data-id="${termId}"]`);
  if (tag) tag.classList.toggle('selected');
}



  function toggleStructureWorldLink(id) {
    const container = document.getElementById('structure-edit-worlds');
    const item = container?.querySelector(`[data-id="${id}"]`);
    if (item) item.classList.toggle('selected');
  }

  function closeStructureEditModal() {
    const modal = document.getElementById('structure-edit-modal');
    if (modal) modal.classList.remove('show');
    if (editingCardId !== null) {
      const cardIndex = structureData.findIndex(c => c.id === editingCardId);
      const card = structureData[cardIndex];
      if (card && card.isNew) {
        structureData.splice(cardIndex, 1);
        saveStructureData();
        renderStructureList();
      }
    }
    editingCardId = null;
  }

  function saveStructureCard() {
    if (editingCardId === null) return;

    const card = structureData.find(c => c.id === editingCardId);
    if (!card) return;

    card.title = document.getElementById('structure-edit-name').value.trim() || card.title;
    card.summary = document.getElementById('structure-edit-summary').value.trim();
    card.viewpoint = document.getElementById('structure-edit-viewpoint').value.trim();
    card.status = document.getElementById('structure-edit-status').value;

    const tagsInput = document.getElementById('structure-edit-tags').value;
    card.tags = tagsInput.split(/[,、]/).map(t => t.trim()).filter(t => t);

    const tabId = document.getElementById('structure-edit-tab').value;
    card.tabId = tabId ? parseInt(tabId) : null;

    // リンクされた登場人物を取得（タグクリック形式）
    const charContainer = document.getElementById('structure-edit-characters');
    if (charContainer) {
      const selectedChars = charContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedCharacters = Array.from(selectedChars).map(el => parseInt(el.dataset.id));
    }

    // リンクされた世界観を取得（タグクリック形式）
    const worldContainer = document.getElementById('structure-edit-worlds');
    if (worldContainer) {
      const selectedWorlds = worldContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedWorlds = Array.from(selectedWorlds).map(el => parseInt(el.dataset.id));

// 関連する用語を取得（タグクリック形式）
const termContainer = document.getElementById('structure-edit-terms');
if (termContainer) {
  const selectedTerms = termContainer.querySelectorAll('.link-tag-item.selected');
  card.linkedTerms = Array.from(selectedTerms).map(el => parseInt(el.dataset.id));
  window.__ccSyncTermsLinks('structure', card.id, card.linkedTerms);
} else {
  card.linkedTerms = card.linkedTerms || [];
  window.__ccSyncTermsLinks('structure', card.id, card.linkedTerms);
}

    }

    card.isNew = false;

    saveStructureData();
    renderStructureList();
    closeStructureEditModal();
  }

  function toggleStructureExpand(cardId) {
    const card = structureData.find(c => c.id === cardId);
    if (card) {
      card.expandLevel = ((card.expandLevel || 0) + 1) % 4;
      card.expanded = card.expandLevel > 0;
      saveStructureData();
      renderStructureList();
    }
  }

  function updateSummaryCount() {
    const textarea = document.getElementById('structure-edit-summary');
    const counter = document.getElementById('structure-summary-count');
    if (textarea && counter) {
      counter.textContent = textarea.value.length;
    }
  }

  // ========== カード削除 ==========
  // カードとその配下の子カードを取得（章→話・シーン、話→シーン）
  function getCardWithChildren(cardId) {
    const idx = structureData.findIndex(c => c.id === cardId);
    if (idx < 0) return [];

    const card = structureData[idx];
    const result = [cardId];

    if (card.level === 'chapter') {
      // 章の場合: 次の章まで、または配列の終わりまでの話とシーンを取得
      for (let i = idx + 1; i < structureData.length; i++) {
        if (structureData[i].level === 'chapter') break;
        result.push(structureData[i].id);
      }
    } else if (card.level === 'episode') {
      // 話の場合: 次の章または話まで、または配列の終わりまでのシーンを取得
      for (let i = idx + 1; i < structureData.length; i++) {
        if (structureData[i].level === 'chapter' || structureData[i].level === 'episode') break;
        result.push(structureData[i].id);
      }
    }
    // シーンの場合: シーンのみ（result にはすでに cardId が入っている）

    return result;
  }

  function deleteStructureCard(cardId) {
    const card = structureData.find(c => c.id === cardId);
    if (!card) return;

    const childIds = getCardWithChildren(cardId);
    const childCount = childIds.length - 1;

    let message = 'この構成カードを削除しますか？';
    if (childCount > 0) {
      message = `この${LEVEL_LABELS[card.level]}と、配下の${childCount}件のカードを削除しますか？`;
    }

    if (!confirm(message)) return;

    // 配下のカードを含めて削除
    structureData = structureData.filter(c => !childIds.includes(c.id));
    saveStructureData();
    renderStructureList();
  }

  // ========== 全展開/全折畳 ==========
  function expandAllStructure() {
    // 一括で最大展開（段階を回さず、常に最大へ）
    structureBulkExpandLevel = 3;
    structureData.forEach(c => {
      c.expandLevel = 3;
      c.expanded = true;
    });
    saveStructureData();
    renderStructureList();

  }

  function collapseAllStructure() {
    // 一括で最小表示（名前のみ）にする
    structureBulkExpandLevel = 0;
    structureData.forEach(c => {
      c.expandLevel = 0;
      c.expanded = false;
    });
    saveStructureData();
    renderStructureList();
  }

  // ========== 全画面モード ==========
  function toggleStructureFullscreen() {
    document.body.classList.toggle('structure-fullscreen-mode');
    if (document.body.classList.contains('structure-fullscreen-mode')) {
      // 構成タブに切り替え
      if (typeof window.switchOutlineTab === 'function') {
        window.switchOutlineTab('structure');
      }
      const panel = document.getElementById('outline-panel');
      if (panel) panel.classList.add('open');
    }
  }

  // ========== テキスト出力 ==========
  function exportStructureText() {
    if (structureData.length === 0) {
      alert('出力する構成データがありません。');
      return;
    }

    let text = '【構成一覧】\n\n';
    let chapterNum = 0, episodeNum = 0, sceneNum = 0;

    structureData.forEach(card => {
      let prefix = '';
      if (card.level === 'chapter') {
        chapterNum++;
        episodeNum = 0;
        sceneNum = 0;
        prefix = `■ 第${chapterNum}章`;
      } else if (card.level === 'episode') {
        episodeNum++;
        sceneNum = 0;
        prefix = `  ├ 第${episodeNum}話`;
      } else if (card.level === 'scene') {
        sceneNum++;
        prefix = `    └ シーン${sceneNum}`;
      }

      text += `${prefix}: ${card.title}\n`;
      text += `    ステータス: ${STATUS_LABELS[card.status]}\n`;
      if (card.viewpoint) text += `    視点: ${card.viewpoint}\n`;
      if (card.tags && card.tags.length > 0) text += `    舞台: ${card.tags.join(', ')}\n`;
      if (card.summary) text += `    要約: ${card.summary}\n`;
      text += '\n';
    });

    // ダウンロード
    const blob = new Blob([text], { type: 'text/plain; charset=utf-8' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = '構成一覧.txt';
    a.click();
    URL.revokeObjectURL(url);
  }

  // ========== イベントリスナー設定 ==========
  function setupStructureEventListeners() {
    // 要約文字数カウント
    const summaryEl = document.getElementById('structure-edit-summary');
    if (summaryEl) {
      summaryEl.addEventListener('input', updateSummaryCount);
    }

    // モーダル外クリックで閉じる
    const modal = document.getElementById('structure-edit-modal');
    if (modal) {
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeStructureEditModal();
      });
    }

    // ESCキーで全画面モード解除
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.body.classList.contains('structure-fullscreen-mode')) {
        toggleStructureFullscreen();
      }
    });
  }

  // ========== 舞台タグサジェスト ==========
  function getAllStructureTags() {
    const tags = new Set();
    structureData.forEach(c => {
      if (c.tags) c.tags.forEach(t => tags.add(t));
    });
    return Array.from(tags);
  }

  function getAllStructureViewpoints() {
    const viewpoints = new Set();
    structureData.forEach(c => {
      if (c.viewpoint && c.viewpoint.trim()) viewpoints.add(c.viewpoint.trim());
    });
    return Array.from(viewpoints);
  }

  function toggleStructureViewpointSuggestions() {
    console.log('[DEBUG] toggleStructureViewpointSuggestions called');
    const container = document.getElementById('structure-viewpoint-suggestions');
    console.log('[DEBUG] container:', container);
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      const viewpoints = getAllStructureViewpoints();
      console.log('[DEBUG] viewpoints:', viewpoints);
      if (viewpoints.length === 0) {
        container.innerHTML = '<span class="no-tags">まだ視点がありません</span>';
      } else {
        container.innerHTML = viewpoints.map(v => `<span class="tag-item" onclick="setStructureViewpoint('${v.replace(/'/g, "\\'")}')">${v}</span>`).join('');
      }
      container.style.display = 'flex';
      console.log('[DEBUG] container.style.display set to flex');
    } else {
      container.style.display = 'none';
      console.log('[DEBUG] container hidden');
    }
  }

  function setStructureViewpoint(viewpoint) {
    const input = document.getElementById('structure-edit-viewpoint');
    if (input) {
      input.value = viewpoint;
    }
    const container = document.getElementById('structure-viewpoint-suggestions');
    if (container) container.style.display = 'none';
  }

  function toggleStructureTagSuggestions() {
    const container = document.getElementById('structure-tag-suggestions');
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      const tags = getAllStructureTags();
      if (tags.length === 0) {
        container.innerHTML = '<span class="no-tags">まだ舞台タグがありません</span>';
      } else {
        container.innerHTML = tags.map(t => `<span class="tag-item" onclick="addStructureTag('${t.replace(/'/g, "\\'")}')">${t}</span>`).join('');
      }
      container.style.display = 'flex';
    } else {
      container.style.display = 'none';
    }
  }

  function addStructureTag(tag) {
    const input = document.getElementById('structure-edit-tags');
    if (!input) return;
    const current = input.value.split(/[,、]/).map(t => t.trim()).filter(t => t);
    if (!current.includes(tag)) {
      current.push(tag);
      input.value = current.join(', ');
    }
  }

  // ========== リンクポップアップ ==========
  let currentLinkPopup = null;

  function showStructureLinkedPopup(event, type, itemId) {
    event.stopPropagation();
    closeLinkPopup();

    let item = null;
    let badgeText = '';
    let badgeClass = '';

    if (type === 'character') {
      const charData = window.getCharacterData ? window.getCharacterData() : [];
      item = charData.find(c => c.id === itemId);
      if (!item) return;
      const roles = { main: '主人公', sub: 'サブ', support: 'モブ' };
      badgeText = roles[item.role] || item.role;
      badgeClass = 'character';
    } else {
      const worldData = window.getWorldData ? window.getWorldData() : [];
      item = worldData.find(w => w.id === itemId);
      if (!item) return;
      const levels = { major: '大カテゴリ', medium: '中カテゴリ', minor: '小カテゴリ' };
      badgeText = levels[item.level] || item.level;
      badgeClass = 'world';
    }

    const popup = document.createElement('div');
    popup.className = 'structure-link-popup';
    popup.innerHTML = `
      <div class="structure-link-popup-header">
        <span class="structure-link-popup-title">${escapeHtml(item.name)}</span>
        <span class="structure-link-popup-badge ${badgeClass}">${badgeText}</span>
      </div>
      <div class="structure-link-popup-desc">${escapeHtml(item.description || '（説明なし）')}</div>
      <div class="structure-link-popup-actions">
        <button onclick="closeLinkPopup()">閉じる</button>
        <button class="btn-goto" onclick="goToLinkedPanel('${type}', ${itemId})">パネルへ移動</button>
      </div>
    `;

    document.body.appendChild(popup);
    currentLinkPopup = popup;

    // ポップアップ位置を調整
    const rect = event.target.getBoundingClientRect();
    let left = rect.left;
    let top = rect.bottom + 5;

    // 画面外に出る場合の調整
    const popupRect = popup.getBoundingClientRect();
    if (left + popupRect.width > window.innerWidth) {
      left = window.innerWidth - popupRect.width - 10;
    }
    if (top + popupRect.height > window.innerHeight) {
      top = rect.top - popupRect.height - 5;
    }

    popup.style.left = left + 'px';
    popup.style.top = top + 'px';

    // 外部クリックで閉じる
    setTimeout(() => {
      document.addEventListener('click', handleLinkPopupOutsideClick);
    }, 0);
  }

  function handleLinkPopupOutsideClick(e) {
    if (currentLinkPopup && !currentLinkPopup.contains(e.target)) {
      closeLinkPopup();
    }
  }

  function closeLinkPopup() {
    if (currentLinkPopup) {
      currentLinkPopup.remove();
      currentLinkPopup = null;
      document.removeEventListener('click', handleLinkPopupOutsideClick);
    }
  }

  function goToLinkedPanel(type, itemId) {
    closeLinkPopup();
    if (type === 'character') {
      if (typeof window.toggleCharacterPanel === 'function') {
        const panel = document.getElementById('character-panel');
        if (!panel || !panel.classList.contains('open')) {
          window.toggleCharacterPanel();
        } else if (window.bringPanelToFront) {
          window.bringPanelToFront(panel, false);
        }
        // 対象のカードをハイライトしてスクロール
        setTimeout(() => {
          const card = document.querySelector(`#character-list .character-card[data-id="${itemId}"]`);
          if (card) {
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            card.style.boxShadow = '0 0 0 3px #f472b6';
            setTimeout(() => card.style.boxShadow = '', 2000);
          }
        }, 300);
      }
      return;
    }
    if (type === 'structure') {
      if (typeof window.toggleStructurePanel === 'function') {
        const panel = document.getElementById('structure-panel');
        if (!panel || !panel.classList.contains('open')) {
          window.toggleStructurePanel();
        } else if (window.bringPanelToFront) {
          window.bringPanelToFront(panel, false);
        }
        setTimeout(() => {
          const card = document.querySelector(`#structure-list .structure-card[data-id="${itemId}"]`);
          if (card) {
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            card.style.boxShadow = '0 0 0 3px #60a5fa';
            setTimeout(() => card.style.boxShadow = '', 2000);
          }
        }, 300);
      }
      return;
    }
    if (typeof window.toggleWorldPanel === 'function') {
      const panel = document.getElementById('world-panel');
      if (!panel || !panel.classList.contains('open')) {
        window.toggleWorldPanel();
      } else if (window.bringPanelToFront) {
        window.bringPanelToFront(panel, false);
      }


// [v23] bidirectional sync between terms and other entities
function __ccSyncTermsLinks(entityType, entityId, newTermIds){
  const terms = window.getTermsData ? window.getTermsData() : null;
  if (!terms) return;
  const keyMap = { character:'linkedCharacters', world:'linkedWorlds', structure:'linkedStructures' };
  const linkKey = keyMap[entityType];
  if (!linkKey) return;

  // remove entityId from any term not in newTermIds
  terms.forEach(t=>{
    if (!Array.isArray(t[linkKey])) t[linkKey]=[];
    const has = t[linkKey].includes(entityId);
    const should = newTermIds.includes(t.id);
    if (has && !should) t[linkKey] = t[linkKey].filter(x=>x!==entityId);
    if (!has && should) t[linkKey].push(entityId);
  });

  // persist terms
  try{
    const saved = localStorage.getItem('cc_terms_data');
    let nextId = 1;
    if (saved){ const p=JSON.parse(saved); nextId = p.nextId || p.nextID || p.next_id || 1; }
    localStorage.setItem('cc_terms_data', JSON.stringify({ data: terms.map(t=>t), nextId }));
  }catch(e){ console.warn('用語リンク同期の保存に失敗', e); }
  if (typeof window.renderTermsList === 'function') window.renderTermsList();
}
window.__ccSyncTermsLinks = __ccSyncTermsLinks;



      // 対象のカードをハイライトしてスクロール
      setTimeout(() => {
        const card = document.querySelector(`#world-list .world-card[data-id="${itemId}"]`);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          card.style.boxShadow = '0 0 0 3px #34d399';
          setTimeout(() => card.style.boxShadow = '', 2000);
        }
      }, 300);
    }
  }

  // ========== グローバル公開 ==========
  window.addStructureCard = addStructureCard;
  window.createStructureCardFromSelection = createStructureCardFromSelection;
  window.refreshStructurePanel = refreshStructurePanel;
  window.openEditModal = openEditModal;
  window.closeStructureEditModal = closeStructureEditModal;
  window.saveStructureCard = saveStructureCard;
  window.deleteStructureCard = deleteStructureCard;
  window.deleteSelectedStructureCards = deleteSelectedStructureCards;
  window.deleteAllStructureCards = deleteAllStructureCards;
  window.expandAllStructure = expandAllStructure;
  window.collapseAllStructure = collapseAllStructure;
  window.toggleStructureExpand = toggleStructureExpand;
  window.toggleStructureFullscreen = toggleStructureFullscreen;
  window.exportStructureText = exportStructureText;
  window.toggleStructureTagSuggestions = toggleStructureTagSuggestions;
  window.toggleStructureViewpointSuggestions = toggleStructureViewpointSuggestions;
  window.setStructureViewpoint = setStructureViewpoint;
  window.addStructureTag = addStructureTag;
  window.toggleStructureCharacterLink = toggleStructureCharacterLink;
  window.toggleStructureWorldLink = toggleStructureWorldLink;
  window.showStructureLinkedPopup = showStructureLinkedPopup;
  window.closeLinkPopup = closeLinkPopup;
  window.goToLinkedPanel = goToLinkedPanel;

  // ========== パネル制御関数 ==========

  // パネル開閉トグル（メモパネルと同様の3段階切り替え、常に左側表示）
  function toggleStructurePanel() {
    const panel = document.getElementById('structure-panel');
    const checkbox = document.getElementById('check-structure-dock');
    const container = document.getElementById('main-container');
    if (!panel || !checkbox) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;
    const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('structure-panel'));

    if (isOpen && !isDocked) {
      // open floating
      if (!isFront) {
        if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
        if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
        if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
        return;
      }
      // front -> pin + collapse all others
      let __okDock = true;

      if (typeof window.__ccRequestDockWithLimit === 'function') { __okDock = window.__ccRequestDockWithLimit('structure'); }

      else { checkbox.checked = true; toggleStructureDock(); panel.classList.add('open'); __okDock = true; }

      if (!__okDock) {

        // 上限到達で入れ替えダイアログ表示中：ここでは何も畳まない

        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();

        return;

      }
} else if (!isOpen) {
      // closed -> open floating
      if (container) container.classList.remove('structure-right');
      panel.classList.add('open');
      if (checkbox.checked) { checkbox.checked = false; toggleStructureDock(); }
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    } else {
      // docked -> close
      checkbox.checked = false;
      toggleStructureDock();
      panel.classList.remove('open');
      panel.style.zIndex = '';
      if (window.__ccFrontPanelId === 'structure-panel') window.__ccFrontPanelId = null;
    }

    const isDockedNow = checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
    if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
    if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
    if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
}

  // ドック切り替え
  function toggleStructureDock() {
    const checkbox = document.getElementById('check-structure-dock');
    const container = document.getElementById('main-container');
    const panel = document.getElementById('structure-panel');
    const swapBtn = document.getElementById('btn-structure-swap');
    const pinBtn = document.getElementById('btn-structure-pin');
    if (!checkbox || !container || !panel) return;

    if (checkbox.checked) {
      container.classList.add('structure-docked');
      // 固定表示時は常に左側に表示（右側設定をリセット）
if (swapBtn) swapBtn.classList.add('is-active');
      if (pinBtn) pinBtn.classList.add('pinned');
    } else {
      container.classList.remove('structure-docked');
if (swapBtn) swapBtn.classList.remove('is-active');
      if (pinBtn) pinBtn.classList.remove('pinned');
    }

    if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses();
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    updateStructureButtonState();
  }

  // ピン切り替え
  function toggleStructureDockPin() {
    const checkbox = document.getElementById('check-structure-dock');
    const panel = document.getElementById('structure-panel');
    if (!checkbox) return;

    if (!checkbox.checked) {
      if (typeof window.__ccRequestDockWithLimit === 'function') {
        window.__ccRequestDockWithLimit('structure');
        return;
      }
      checkbox.checked = true;
      toggleStructureDock();
      if (panel) panel.classList.add('open');
      return;
    }

    checkbox.checked = false;
    toggleStructureDock();
    if (panel) {
      panel.classList.add('open');
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    }
}

  function swapStructureSide() {
    if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('structure');
  }


  // パネルを閉じる
  function closeStructurePanel(force) {
    const panel = document.getElementById('structure-panel');
    const checkbox = document.getElementById('check-structure-dock');
    const container = document.getElementById('main-container');
    if (!panel) return;

    document.body.classList.remove('structure-fullscreen-mode');
    if (force || !checkbox || !checkbox.checked) {
      panel.classList.remove('open');
      if (checkbox) checkbox.checked = false;
      if (container) {
        container.classList.remove('structure-docked');
      }
    } else {
      panel.classList.remove('open');
    }

    if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    updateStructureButtonState();
  }

  // ボタン状態更新
  function updateStructureButtonState() {
    const panel = document.getElementById('structure-panel');
    const checkbox = document.getElementById('check-structure-dock');
    const btn = document.getElementById('btn-toggle-structure');
    if (!btn || !panel) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox && checkbox.checked;
    const icon = btn.querySelector('.panel-state-icon');

    btn.classList.remove('active');
    if (isDocked) {
      if (icon) icon.textContent = '📌';
    } else if (isOpen) {
      if (icon) icon.textContent = '▾';
    } else {
      if (icon) icon.textContent = '▾';
    }
  }

  // 全画面モード更新（構成パネル用）
  function toggleStructureFullscreen() {
    const panel = document.getElementById('structure-panel');
    if (!panel) return;

    if (document.body.classList.contains('structure-fullscreen-mode')) {
      document.body.classList.remove('structure-fullscreen-mode');
    } else {
      // まずパネルを開く
      panel.classList.add('open');
      document.body.classList.add('structure-fullscreen-mode');
    }
  }

  // リセット時の初期化
  function initStructureFromReset() {
    structureData = [];
    structureNextId = 1;
    renderStructureList();
  }

  // ========== エクスポート/インポート ==========
  function exportStructureData() {
    if (structureData.length === 0) {
      alert('エクスポートする構成データがありません');
      return;
    }
    const exportData = {
      type: 'cc_structure',
      version: 1,
      data: structureData.map(({ selected, isNew, ...rest }) => rest),
      nextId: structureNextId,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `構成_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function exportStructureAsText() {
    if (structureData.length === 0) {
      alert('エクスポートする構成データがありません');
      return;
    }
    const LEVEL_LABELS = { chapter: '章', episode: '話', scene: 'シーン' };
    const lines = [];
    structureData.forEach(card => {
      const levelLabel = LEVEL_LABELS[card.level] || card.level;
      lines.push(`【${levelLabel}】${card.title}`);
      if (card.summary) lines.push(`　概要: ${card.summary}`);
      if (card.viewpoint) lines.push(`　視点: ${card.viewpoint}`);
      if (card.tags && card.tags.length > 0) lines.push(`　タグ: ${card.tags.join(', ')}`);
      lines.push('');
    });
    const content = lines.join('\n');
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `構成_${new Date().toISOString().slice(0,10)}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }
  window.exportStructureAsText = exportStructureAsText;

  function importStructureData(file, mode) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const imported = JSON.parse(e.target.result);
        if (imported.type !== 'cc_structure' || !Array.isArray(imported.data)) {
          alert('有効な構成データファイルではありません');
          return;
        }
        if (mode === 'overwrite') {
          structureData = imported.data.map(card => ({
            ...card,
            selected: false,
            isNew: false,
            linkedCharacters: card.linkedCharacters || [],
          linkedTerms: card.linkedTerms || [],
            linkedWorlds: card.linkedWorlds || []
          }));
          structureNextId = imported.nextId || (Math.max(...structureData.map(c => c.id), 0) + 1);
        } else {
          // 追加モード: IDを振り直して追加
          const maxId = Math.max(structureNextId, ...structureData.map(c => c.id), 0);
          let newId = maxId + 1;
          const newCards = imported.data.map(card => ({
            ...card,
            id: newId++,
            selected: false,
            isNew: false,
            linkedCharacters: card.linkedCharacters || [],
          linkedTerms: card.linkedTerms || [],
            linkedWorlds: card.linkedWorlds || []
          }));
          structureData = [...structureData, ...newCards];
          structureNextId = newId;
        }
        saveStructureData();
        renderStructureList();
        alert(mode === 'overwrite' ? '構成データを読み込みました' : '構成データを追加しました');
      } catch (err) {
        console.error('構成インポートエラー:', err);
        alert('ファイルの読み込みに失敗しました');
      }
    };
    reader.readAsText(file);
  }

  function getStructureDataForExport() {
    return structureData;
  }

  // パネル制御関数をグローバルに公開
  window.toggleStructurePanel = toggleStructurePanel;
  window.toggleStructureDock = toggleStructureDock;
  window.toggleStructureDockPin = toggleStructureDockPin;
  window.initStructureFromReset = initStructureFromReset;
  window.swapStructureSide = swapStructureSide;
  window.closeStructurePanel = closeStructurePanel;
  window.updateStructureButtonState = updateStructureButtonState;
  window.exportStructureData = exportStructureData;
  window.importStructureData = importStructureData;

  // ========== 初期化実行 ==========
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initStructure);
  } else {
    initStructure();
  }
})();

// ========== 登場人物パネル ==========
(function() {
  'use strict';

  const CHARACTER_STORAGE_KEY = 'cc_character_data';
  let characterData = [];
  let characterNextId = 1;
  let editingCharacterId = null;
  let draggingCharacterId = null;
  let characterMenuClickHandler = null;

  const CHARACTER_ROLES = {
    protagonist: '主人公',
    heroine: 'ヒロイン',
    antagonist: '敵役',
    supporting: 'サブ',
    mob: 'モブ'
  };

  function escapeHtml(str) {
    if (!str) return '';
    return String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function initCharacter() {
    loadCharacterData();
    renderCharacterList();
    setupCharacterFullscreenListener();
    setupCharacterPanelContextMenu();
    if (window.loadPanelBackground) window.loadPanelBackground('character');
  }

  function loadCharacterData() {
    try {
      const saved = localStorage.getItem(CHARACTER_STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        characterData = (parsed.data || []).map(card => ({
          ...card,
          selected: false,
          linkedStructures: card.linkedStructures || [],
          linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
          tabId: card.tabId ?? null,
          // expanded (boolean) から expandLevel (0,1,2) への移行対応
          expandLevel: card.expandLevel !== undefined ? card.expandLevel : (card.expanded ? 2 : 0)
        }));
        characterNextId = parsed.nextId || 1;
      }
    } catch (e) {
      console.warn('登場人物データの読み込みに失敗:', e);
      characterData = [];
      characterNextId = 1;
    }
  }

  function saveCharacterData() {
    try {
      const sanitized = characterData.map(({ selected, ...rest }) => rest);
      localStorage.setItem(CHARACTER_STORAGE_KEY, JSON.stringify({
        data: sanitized,
        nextId: characterNextId
      }));
    } catch (e) {
      console.warn('登場人物データの保存に失敗:', e);
    }
  }

  function addCharacterCard(role) {
    const count = characterData.filter(c => c.role === role).length;
    const newCard = {
      id: characterNextId++,
      name: CHARACTER_ROLES[role] + (count + 1),
      reading: '',
      role: role,
      affiliationTags: [],
      freeTags: [],
      linkedStructures: [],
      linkedWorlds: [],
      linkedTerms: [],
      description: '',
      color: null,
      expandLevel: 0,
      tabId: null,
      selected: false,
      isNew: true
    };
    characterData.push(newCard);
    saveCharacterData();
    renderCharacterList();
    openCharacterEditModal(newCard.id);
  }

  function getCharacterSelectedRole() {
    const select = document.getElementById('character-add-role');
    return select?.value || 'protagonist';
  }

  function createCharacterCardFromSelection() {
    addCharacterCard(getCharacterSelectedRole());
  }

  function refreshCharacterPanel() {
    loadCharacterData();
    renderCharacterList();
  }

  function renderCharacterList() {
    const container = document.getElementById('character-list');
    if (!container) return;

    if (characterData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; padding:20px; text-align:center;">登場人物がいません。<br>上のボタンから追加してください。</div>';
      updateCharacterCount();
      updateCharacterBulkButtons();
      return;
    }

    container.innerHTML = '';
    characterData.forEach((card, index) => {
      const div = createCharacterCardElement(card, index);
      container.appendChild(div);
    });
    updateCharacterCount();
    updateCharacterBulkButtons();
  }

  function createCharacterCardElement(card, index) {
    const div = document.createElement('div');
    div.className = `character-card role-${card.role} hide-labels`;
    const level = card.expandLevel || 0;
    if (level === 1) div.classList.add('expand-1');
    else if (level === 2) div.classList.add('expand-2');
    else if (level >= 3) div.classList.add('expand-3');
    if (card.color) {
      div.classList.add('has-custom-color');
      div.style.setProperty('--character-card-accent', card.color);
      div.style.setProperty('--character-card-bg', toRgba(card.color, 0.12));
    }
    div.dataset.id = card.id;
    div.draggable = true;

    const affiliationHtml = card.affiliationTags.length > 0
      ? card.affiliationTags.map(t => `<span class="character-affiliation-tag">${escapeHtml(t)}</span>`).join('')
      : '';
    const freeTagsHtml = card.freeTags.length > 0
      ? card.freeTags.map(t => `<span class="character-free-tag">${escapeHtml(t)}</span>`).join('')
      : '';

    const structureData = window.getStructureData ? window.getStructureData() : [];
    const worldData = window.getWorldData ? window.getWorldData() : [];
    const STRUCTURE_LEVEL_LABELS = { chapter: '章', episode: '話', scene: 'シーン' };
    const WORLD_LEVELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };

    const linkedStructuresHtml = (card.linkedStructures || []).map(sid => {
      const struct = structureData.find(s => s.id === sid);
      if (!struct) return '';
      const levelLabel = STRUCTURE_LEVEL_LABELS[struct.level] || struct.level || '';
      return `<span class="card-linked-item card-linked-structure" onclick="event.stopPropagation(); goToLinkedPanel('structure', ${sid})"><span class="card-linked-icon">📋</span><span class="card-linked-text">${escapeHtml(struct.title)}</span>${levelLabel ? `<span class="card-linked-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');

    const linkedWorldsHtml = (card.linkedWorlds || []).map(wid => {
      const world = worldData.find(w => w.id === wid);
      if (!world) return '';
      const levelLabel = WORLD_LEVELS[world.level] || world.level || '';
      return `<span class="card-linked-item card-linked-world" onclick="event.stopPropagation(); goToLinkedPanel('world', ${wid})"><span class="card-linked-icon">🌍</span><span class="card-linked-text">${escapeHtml(world.name)}</span>${levelLabel ? `<span class="card-linked-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');

    const linkedTermsHtml = (card.linkedTerms || []).map(tid => {
      const term = (window.getTermsData ? window.getTermsData() : []).find(t => t.id === tid);
      if (!term) return '';
      const label = (term.category ? `${escapeHtml(term.category)} / ` : '') + escapeHtml(term.name || '');
      return `<span class="card-linked-item card-linked-term" onclick="event.stopPropagation(); goToLinkedPanel('terms', ${tid})">📚 ${label}</span>`;
    }).join('');

    let tabLinkHtml = '';
    if (card.tabId && window.inputTabs) {
      const tab = window.inputTabs.find(t => t.id === card.tabId);
      if (tab) {
        tabLinkHtml = `<div class="character-field"><div class="character-field-label">📄</div><div style="color:#2563eb; cursor:pointer;" onclick="event.stopPropagation(); if(window.switchTab) window.switchTab(${card.tabId})">${escapeHtml(tab.name)}</div></div>`;
      }
    }

    const linkedSectionHtml = (linkedStructuresHtml || linkedWorldsHtml || linkedTermsHtml) ? `
      <div class="card-linked-section">
        ${linkedStructuresHtml ? `<div class="card-linked-label">構成</div><div class="card-linked-items">${linkedStructuresHtml}</div>` : ''}
        ${linkedWorldsHtml ? `<div class="card-linked-label" style="margin-top:6px;">世界観</div><div class="card-linked-items">${linkedWorldsHtml}</div>` : ''}
        ${linkedTermsHtml ? `<div class="card-linked-label" style="margin-top:6px;">用語</div><div class="card-linked-items">${linkedTermsHtml}</div>` : ''}
      </div>
    ` : '';

    // 展開レベルに応じたトグルアイコン
    const toggleSymbols = ['▶', '▽', '▼', '◆'];
    const toggleSymbol = toggleSymbols[Math.min(level, 3)];

    // 説明の1行目プレビュー
    const descPreview = card.description ? card.description.split('\n')[0].substring(0, 50) + (card.description.length > 50 ? '...' : '') : '';

    div.innerHTML = `
      <div class="character-card-header" onclick="toggleCharacterExpand(${card.id})">
        <input type="checkbox" class="character-select" ${card.selected ? 'checked' : ''} onclick="event.stopPropagation(); toggleCharacterSelect(${card.id})">
        <div class="character-move-group" onclick="event.stopPropagation();">
          <button class="character-move-btn" title="上へ移動" onclick="moveCharacterCard(${card.id}, -1)">↑</button>
          <button class="character-move-btn" title="下へ移動" onclick="moveCharacterCard(${card.id}, 1)">↓</button>
        </div>
        <span class="character-toggle">${toggleSymbol}</span>
        <span class="character-name">${escapeHtml(card.name)}</span>
        ${card.reading ? `<span class="character-reading">(${escapeHtml(card.reading)})</span>` : ''}
        <span class="character-role-badge">${escapeHtml(CHARACTER_ROLES[card.role] || card.role || '未設定')}</span>
      </div>
      <div class="character-card-body">
        ${affiliationHtml ? `<div class="character-field"><div class="character-field-label">🏷</div><div class="character-tags">${affiliationHtml}</div></div>` : ''}
        ${freeTagsHtml ? `<div class="character-field"><div class="character-field-label">🔖</div><div class="character-tags">${freeTagsHtml}</div></div>` : ''}
        ${descPreview ? `<div class="character-description-preview">${escapeHtml(descPreview)}</div>` : ''}
        ${card.description ? `<div class="character-field character-description"><div class="character-field-label">📝</div><div style="color:var(--text-color);">${escapeHtml(card.description)}</div></div>` : ''}
        ${tabLinkHtml}
        ${linkedSectionHtml}
        <div class="character-card-actions">
          <button onclick="openCharacterEditModal(${card.id})">✏️ 編集</button>
          <button onclick="duplicateCharacterCard(${card.id})">📋 複製</button>
          <button class="btn-delete" onclick="deleteCharacterCard(${card.id})">🗑 削除</button>
        </div>
      </div>
    `;

    div.addEventListener('dragstart', handleCharacterDragStart);
    div.addEventListener('dragend', handleCharacterDragEnd);
    div.addEventListener('dragover', handleCharacterDragOver);
    div.addEventListener('dragleave', handleCharacterDragLeave);
    div.addEventListener('drop', handleCharacterDrop);
    div.addEventListener('contextmenu', (e) => { e.preventDefault(); showCharacterContextMenu(e, card.id); });
    div.addEventListener('dblclick', (e) => {
      if (e.target.closest('button, input')) return;
      const nameEl = e.target.closest('.character-name');
      if (nameEl && typeof startInlineEdit === 'function') {
        e.stopPropagation();
        startInlineEdit(nameEl, card.name, (newName) => {
          card.name = newName;
          saveCharacterData();
        });
      } else {
        toggleCharacterExpand(card.id);
      }
    });

    return div;
  }

  function toRgba(color, alpha = 1) {
    if (!color) return `rgba(0,0,0,${alpha})`;
    if (color.startsWith('#')) {
      const hex = color.replace('#', '');
      const size = hex.length === 3 ? 1 : 2;
      const to255 = (idx) => {
        const part = hex.substr(idx, size);
        return parseInt(size === 1 ? part + part : part, 16);
      };
      return `rgba(${to255(0)}, ${to255(size)}, ${to255(size * 2)}, ${alpha})`;
    }
    return color;
  }

  // ========== 一括展開レベル（4段階）: 登場人物 ==========
  const CHARACTER_BULK_EXPAND_SYMBOLS = ['▶', '▽', '▼', '◆'];
  const CHARACTER_BULK_EXPAND_TITLES  = ['名前のみ', 'タグのみ', 'タグ+プレビュー', 'すべて表示'];

  function getUniformCharacterExpandLevel() {
    if (!Array.isArray(characterData) || characterData.length === 0) return { level: 0, mixed: false };
    const getLvl = (c) => (c && c.expandLevel !== undefined) ? (c.expandLevel || 0) : 0;
    const base = getLvl(characterData[0]);
    for (const c of characterData) {
      if (getLvl(c) !== base) return { level: base, mixed: true };
    }
    return { level: base, mixed: false };
  }

  function updateCharacterBulkButtons() {
    const upBtn = document.getElementById('btn-character-bulk-up');
    const downBtn = document.getElementById('btn-character-bulk-down');
    if (!upBtn || !downBtn) return;

    const info = getUniformCharacterExpandLevel();

    let sym, title;
    if (info.mixed) {
      sym = '≋';
      title = '混在';
    } else {
      const level = Math.min(Math.max(info.level || 0, 0), 3);
      sym = CHARACTER_BULK_EXPAND_SYMBOLS[level];
      title = CHARACTER_BULK_EXPAND_TITLES[level];
    }

    upBtn.textContent = `全展開 +${sym}`;
    downBtn.textContent = `全折畳 -${sym}`;

    if (info.mixed) {
      upBtn.title = '一括で表示段階を上げます（現在: 混在 / カードごとに段階が異なります）';
      downBtn.title = '一括で最小表示（名前のみ）にします（現在: 混在）';
    } else {
      upBtn.title = `一括で表示段階を上げます（現在: ${sym} ${title}）`;
      downBtn.title = `一括で最小表示（名前のみ）にします（現在: ${sym} ${title}）`;
    }
  }

  function updateCharacterCount() {
    const el = document.getElementById('character-count');
    if (el) el.textContent = characterData.length + '人';
  }

  function toggleCharacterExpand(cardId) {
    const card = characterData.find(c => c.id === cardId);
    if (card) {
      // 4段階展開: 0 → 1 → 2 → 3 → 0
      card.expandLevel = ((card.expandLevel || 0) + 1) % 4;
      saveCharacterData();
      renderCharacterList();
    }
  }

  function toggleCharacterSelect(cardId) {
    const card = characterData.find(c => c.id === cardId);
    if (card) {
      card.selected = !card.selected;
      renderCharacterList();
    }
  }

  function openCharacterEditModal(cardId) {
    const card = characterData.find(c => c.id === cardId);
    if (!card) return;
    editingCharacterId = cardId;

    document.getElementById('character-edit-name').value = card.name || '';
    document.getElementById('character-edit-reading').value = card.reading || '';

    // アウトラインレベル（新規フィールド、デフォルト1）
    const levelSelect = document.getElementById('character-edit-level');
    if (levelSelect) levelSelect.value = card.outlineLevel || '1';

    // 役割タグ（旧形式との互換性: enumをテキストに変換）
    const roleInput = document.getElementById('character-edit-role');
    if (roleInput) {
      const ROLE_LABELS = { protagonist: '主人公', heroine: 'ヒロイン', antagonist: '敵役', supporting: 'サブ', mob: 'モブ' };
      const roleValue = ROLE_LABELS[card.role] || card.role || '';
      roleInput.value = roleValue;
    }

    document.getElementById('character-edit-affiliation').value = (card.affiliationTags || []).join(', ');
    document.getElementById('character-edit-freetags').value = (card.freeTags || []).join(', ');
    document.getElementById('character-edit-description').value = card.description || '';
    updateCharacterDescriptionCount();

    const tabSelect = document.getElementById('character-edit-tab');
    if (tabSelect) {
      tabSelect.innerHTML = '<option value="">（なし）</option>';
      if (window.inputTabs) {
        window.inputTabs.forEach(tab => {
          const opt = document.createElement('option');
          opt.value = tab.id;
          opt.textContent = tab.name;
          if (card.tabId === tab.id) opt.selected = true;
          tabSelect.appendChild(opt);
        });
      }
    }

    // 関連する構成と世界観をチェックボックスで表示
    populateCharacterStructureCheckboxes(card.linkedStructures || []);
    populateCharacterWorldCheckboxes(card.linkedWorlds || []);
    populateCharacterTermCheckboxes(card.linkedTerms || []);

    document.getElementById('character-edit-modal').classList.add('show');
  }

  function populateCharacterStructureCheckboxes(selectedIds) {
    const container = document.getElementById('character-edit-structures');
    if (!container) return;

    const structureData = window.getStructureData ? window.getStructureData() : [];
    if (structureData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">構成パネルにカードを追加してください</div>';
      return;
    }

    const LEVEL_LABELS = { chapter: '章', episode: '話', scene: 'シーン' };
    container.innerHTML = structureData.map(s => {
      const selected = selectedIds.includes(s.id) ? 'selected' : '';
      const levelLabel = LEVEL_LABELS[s.level] || s.level || '';
      return `<span class="link-tag-item ${selected}" data-id="${s.id}" onclick="toggleCharacterStructureLink(${s.id})"><span class="link-tag-text"><span class="link-tag-text">${escapeHtml(s.title)}</span></span>${levelLabel ? `<span class="link-tag-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');
  }

  function toggleCharacterStructureLink(id) {
    console.log('[DEBUG] toggleCharacterStructureLink called with id:', id);
    const container = document.getElementById('character-edit-structures');
    console.log('[DEBUG] container:', container);
    const item = container?.querySelector(`[data-id="${id}"]`);
    console.log('[DEBUG] item:', item);
    if (item) {
      item.classList.toggle('selected');
      console.log('[DEBUG] item classes after toggle:', item.className);
    }
  }

  function populateCharacterWorldCheckboxes(selectedIds) {
    const container = document.getElementById('character-edit-worlds');
    if (!container) return;

    const worldData = window.getWorldData ? window.getWorldData() : [];
    if (worldData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">世界観パネルに設定を追加してください</div>';
      return;
    }

    const WORLD_LEVELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
    container.innerHTML = worldData.map(w => {
      const selected = selectedIds.includes(w.id) ? 'selected' : '';
      const levelLabel = WORLD_LEVELS[w.level] || w.level || '';
      return `<span class="link-tag-item ${selected}" data-id="${w.id}" onclick="toggleCharacterWorldLink(${w.id})"><span class="link-tag-text"><span class="link-tag-text">${escapeHtml(w.name)}</span></span>${levelLabel ? `<span class="link-tag-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');
  }


function populateCharacterTermCheckboxes(selectedIds){
  const container = document.getElementById('character-edit-terms');
  if (!container) return;
  const terms = window.getTermsData ? window.getTermsData() : [];
  if (!terms.length){
    container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">用語パネルにカードを追加してください</div>';
    return;
  }
  container.innerHTML = terms.map(t=>{
    const selected = selectedIds.includes(t.id) ? 'selected' : '';
    const label = (t.category ? `${escapeHtml(t.category)} / ` : '') + escapeHtml(t.name||'');
    return `<span class="link-tag-item ${selected}" data-id="${t.id}" onclick="toggleCharacterTermLink(${t.id})">${label}</span>`;
  }).join('');
}
function toggleCharacterTermLink(termId){
  const container = document.getElementById('character-edit-terms');
  if (!container) return;
  const tag = container.querySelector(`.link-tag-item[data-id="${termId}"]`);
  if (tag) tag.classList.toggle('selected');
}



  function toggleCharacterWorldLink(id) {
    const container = document.getElementById('character-edit-worlds');
    const item = container?.querySelector(`[data-id="${id}"]`);
    if (item) item.classList.toggle('selected');
  }

  function closeCharacterEditModal() {
    const modal = document.getElementById('character-edit-modal');
    if (modal) modal.classList.remove('show');
    if (editingCharacterId !== null) {
      const cardIndex = characterData.findIndex(c => c.id === editingCharacterId);
      const card = characterData[cardIndex];
      if (card && card.isNew) {
        characterData.splice(cardIndex, 1);
        saveCharacterData();
        renderCharacterList();
      }
    }
    editingCharacterId = null;
  }

  function saveCharacterCard() {
    if (editingCharacterId === null) return;
    const card = characterData.find(c => c.id === editingCharacterId);
    if (!card) return;

    const roleInputValue = document.getElementById('character-edit-role').value.trim();
    // 日本語ラベルをキーに変換（プリセット役割のみ）
    const LABEL_TO_KEY = { '主人公': 'protagonist', 'ヒロイン': 'heroine', '敵役': 'antagonist', 'サブ': 'supporting', 'モブ': 'mob' };
    const roleValue = LABEL_TO_KEY[roleInputValue] || roleInputValue;
    card.name = document.getElementById('character-edit-name').value.trim() || roleInputValue || '名前未設定';
    card.reading = document.getElementById('character-edit-reading').value.trim();
    card.outlineLevel = document.getElementById('character-edit-level')?.value || '1';
    card.role = roleValue || '未設定';
    card.affiliationTags = document.getElementById('character-edit-affiliation').value.split(',').map(t => t.trim()).filter(t => t);
    card.freeTags = document.getElementById('character-edit-freetags').value.split(',').map(t => t.trim()).filter(t => t);
    card.description = document.getElementById('character-edit-description').value.trim();
    const tabId = document.getElementById('character-edit-tab')?.value || '';
    card.tabId = tabId ? parseInt(tabId, 10) : null;

    // 関連する構成を取得（タグクリック形式）
    const structContainer = document.getElementById('character-edit-structures');
    if (structContainer) {
      const selectedStructs = structContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedStructures = Array.from(selectedStructs).map(el => parseInt(el.dataset.id));
    }

    // 関連する世界観を取得（タグクリック形式）
    const worldContainer = document.getElementById('character-edit-worlds');
    if (worldContainer) {
      const selectedWorlds = worldContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedWorlds = Array.from(selectedWorlds).map(el => parseInt(el.dataset.id));

// 関連する用語を取得（タグクリック形式）
const termContainer = document.getElementById('character-edit-terms');
if (termContainer) {
  const selectedTerms = termContainer.querySelectorAll('.link-tag-item.selected');
  card.linkedTerms = Array.from(selectedTerms).map(el => parseInt(el.dataset.id));
  window.__ccSyncTermsLinks('character', card.id, card.linkedTerms);
} else {
  card.linkedTerms = card.linkedTerms || [];
  window.__ccSyncTermsLinks('character', card.id, card.linkedTerms);
}

    }

    card.isNew = false;

    saveCharacterData();
    renderCharacterList();
    closeCharacterEditModalWithoutDelete();
  }

  function closeCharacterEditModalWithoutDelete() {
    const modal = document.getElementById('character-edit-modal');
    if (modal) modal.classList.remove('show');
    editingCharacterId = null;
  }

  function updateCharacterDescriptionCount() {
    const textarea = document.getElementById('character-edit-description');
    const count = document.getElementById('character-description-count');
    if (textarea && count) count.textContent = textarea.value.length;
  }

  function duplicateCharacterCard(cardId) {
    const card = characterData.find(c => c.id === cardId);
    if (!card) return;
    const newCard = { ...card, id: characterNextId++, name: card.name + ' (コピー)', selected: false };
    const idx = characterData.findIndex(c => c.id === cardId);
    characterData.splice(idx + 1, 0, newCard);
    saveCharacterData();
    renderCharacterList();
  }

  function deleteCharacterCard(cardId) {
    if (!confirm('このキャラクターを削除しますか？')) return;
    characterData = characterData.filter(c => c.id !== cardId);
    saveCharacterData();
    renderCharacterList();
  }

  function deleteSelectedCharacterCards() {
    const selected = characterData.filter(c => c.selected);
    if (selected.length === 0) { alert('選択されているキャラクターがありません'); return; }
    if (!confirm(`${selected.length}人のキャラクターを削除しますか？`)) return;
    characterData = characterData.filter(c => !c.selected);
    saveCharacterData();
    renderCharacterList();
  }

  function deleteAllCharacterCards() {
    if (characterData.length === 0) return;
    if (!confirm('すべてのキャラクターを削除しますか？')) return;
    characterData = [];
    characterNextId = 1;
    saveCharacterData();
    renderCharacterList();
  }

  // ドラッグ&ドロップ
  function handleCharacterDragStart(e) {
    draggingCharacterId = parseInt(e.currentTarget.dataset.id);
    e.currentTarget.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  }

  function handleCharacterDragEnd(e) {
    e.currentTarget.classList.remove('dragging');
    document.querySelectorAll('.character-card.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggingCharacterId = null;
  }

  function handleCharacterDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    e.currentTarget.classList.add('drag-over');
  }

  function handleCharacterDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
  }

  function handleCharacterDrop(e) {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');
    const targetId = parseInt(e.currentTarget.dataset.id);
    if (draggingCharacterId === null || draggingCharacterId === targetId) return;

    const dragIdx = characterData.findIndex(c => c.id === draggingCharacterId);
    const targetIdx = characterData.findIndex(c => c.id === targetId);
    if (dragIdx < 0 || targetIdx < 0) return;

    const [moved] = characterData.splice(dragIdx, 1);
    characterData.splice(targetIdx, 0, moved);
    saveCharacterData();
    renderCharacterList();
  }

  // コンテキストメニュー
  function showCharacterPanelContextMenu(e) {
    hideCharacterContextMenu();
    let menu = document.getElementById('character-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'character-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:160px;';
      document.body.appendChild(menu);
    }

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-item" data-action="bg-color">🎨 背景色の変更</div>
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'new-card') createCharacterCardFromSelection();
        if (action === 'bg-color' && window.openPanelBackgroundColorPicker) {
          window.openPanelBackgroundColorPicker('character');
        }
        hideCharacterContextMenu();
      };
    });

    if (typeof adjustContextMenuPosition === 'function') {
      adjustContextMenuPosition(menu, e.clientX, e.clientY);
    } else {
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      menu.style.display = 'block';
    }

    characterMenuClickHandler = () => hideCharacterContextMenu();
    setTimeout(() => document.addEventListener('click', characterMenuClickHandler), 0);
  }

  function showCharacterContextMenu(e, cardId) {
    hideCharacterContextMenu();
    let menu = document.getElementById('character-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'character-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:160px;';
      document.body.appendChild(menu);
    }

    const currentCard = characterData.find(c => c.id === cardId);
    const expandLevel = currentCard ? (currentCard.expandLevel || 0) : 0;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="edit">✏️ 編集</div>
      <div class="context-menu-item" data-action="duplicate">📋 複製</div>
      <div class="context-menu-item" data-action="toggle">↕ 次の展開レベル</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="expand-0" style="padding-left:24px;">▶ 名前のみ${expandLevel === 0 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-1" style="padding-left:24px;">▽ タグのみ${expandLevel === 1 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-2" style="padding-left:24px;">▼ タグ+プレビュー${expandLevel === 2 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-3" style="padding-left:24px;">◆ すべて表示${expandLevel === 3 ? ' ✓' : ''}</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="color">🎨 色を変更</div>
      <div class="context-menu-item" data-action="reset-color">↩ 色をリセット</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="move-up">⬆ 上へ</div>
      <div class="context-menu-item" data-action="move-down">⬇ 下へ</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="role-up">⬆ 役割を上げる</div>
      <div class="context-menu-item" data-action="role-down">⬇ 役割を下げる</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="delete" style="color:#dc2626;">🗑 削除</div>
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'new-card') createCharacterCardFromSelection();
        if (action === 'edit') openCharacterEditModal(cardId);
        if (action === 'duplicate') duplicateCharacterCard(cardId);
        if (action === 'toggle') {
          const target = characterData.find(c => c.id === cardId);
          if (target) { target.expandLevel = ((target.expandLevel || 0) + 1) % 4; saveCharacterData(); renderCharacterList(); }
        }
        if (action === 'expand-0' || action === 'expand-1' || action === 'expand-2' || action === 'expand-3') {
          const target = characterData.find(c => c.id === cardId);
          if (target) {
            target.expandLevel = parseInt(action.split('-')[1]);
            saveCharacterData();
            renderCharacterList();
          }
        }
        if (action === 'move-up') moveCharacterCard(cardId, -1);
        if (action === 'move-down') moveCharacterCard(cardId, 1);
        if (action === 'role-up') changeCharacterRole(cardId, -1);
        if (action === 'role-down') changeCharacterRole(cardId, 1);
        if (action === 'delete') deleteCharacterCard(cardId);
        if (action === 'color') openCharacterColorPicker(cardId);
        if (action === 'reset-color') resetCharacterColor(cardId);
        hideCharacterContextMenu();
      };
    });

    if (typeof adjustContextMenuPosition === 'function') {
      adjustContextMenuPosition(menu, e.clientX, e.clientY);
    } else {
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      menu.style.display = 'block';
    }

    characterMenuClickHandler = () => hideCharacterContextMenu();
    setTimeout(() => document.addEventListener('click', characterMenuClickHandler), 0);
  }

  function hideCharacterContextMenu() {
    const menu = document.getElementById('character-context-menu');
    if (menu) menu.style.display = 'none';
    if (characterMenuClickHandler) {
      document.removeEventListener('click', characterMenuClickHandler);
      characterMenuClickHandler = null;
    }
  }

  function setupCharacterPanelContextMenu() {
    const list = document.getElementById('character-list');
    if (!list) return;
    list.addEventListener('contextmenu', (e) => {
      if (e.target.closest('.character-card')) return;
      e.preventDefault();
      showCharacterPanelContextMenu(e);
    });
  }

  function openCharacterColorPicker(cardId) {
    const card = characterData.find(c => c.id === cardId);
    if (!card) return;

    let picker = document.getElementById('character-color-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'character-color-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
      document.body.appendChild(picker);
    }

    const currentColor = card.color || '#ec4899';
    const presetColors = ['#ec4899', '#f472b6', '#be185d', '#a855f7', '#8b5cf6', '#3b82f6', '#06b6d4', '#10b981', '#eab308', '#ef4444'];

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">カードの色</span>
        <button class="picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input type="color" id="char-color-input" value="${currentColor}" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px; cursor:pointer;">
        <input type="text" id="char-color-text" value="${currentColor}" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetColors.map(c => `<button class="char-color-preset" data-color="${c}" style="width:24px; height:24px; background:${c}; border:1px solid #ccc; border-radius:4px; cursor:pointer;${c === currentColor ? ' outline:2px solid #2563eb;' : ''}"></button>`).join('')}
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="char-picker-cancel">キャンセル</button>
        <button class="btn btn-save" id="char-picker-apply">適用</button>
      </div>
    `;

    picker.style.left = '50%';
    picker.style.top = '50%';
    picker.style.transform = 'translate(-50%, -50%)';
    picker.style.display = 'block';

    const colorInput = picker.querySelector('#char-color-input');
    const colorText = picker.querySelector('#char-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.char-color-preset').forEach(btn => {
      btn.onclick = () => {
        colorInput.value = btn.dataset.color;
        colorText.value = btn.dataset.color;
        picker.querySelectorAll('.char-color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    picker.querySelector('.picker-close').onclick = () => { picker.style.display = 'none'; };
    picker.querySelector('#char-picker-cancel').onclick = () => { picker.style.display = 'none'; };
    picker.querySelector('#char-picker-apply').onclick = () => {
      card.color = colorInput.value;
      saveCharacterData();
      renderCharacterList();
      picker.style.display = 'none';
    };
  }

  function resetCharacterColor(cardId) {
    const card = characterData.find(c => c.id === cardId);
    if (!card) return;
    card.color = null;
    saveCharacterData();
    renderCharacterList();
  }

  function exportCharacterText() {
    if (characterData.length === 0) { alert('エクスポートするキャラクターがありません'); return; }
    let text = '【登場人物一覧】\n\n';
    characterData.forEach(c => {
      text += `■ ${c.name}${c.reading ? ` (${c.reading})` : ''} [${CHARACTER_ROLES[c.role]}]\n`;
      if (c.affiliationTags.length > 0) text += `  所属: ${c.affiliationTags.join(', ')}\n`;
      if (c.freeTags.length > 0) text += `  タグ: ${c.freeTags.join(', ')}\n`;
      if (c.description) text += `  説明: ${c.description}\n`;
      text += '\n';
    });
    const blob = new Blob([text], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = '登場人物.txt';
    a.click();
  }

  // 上下移動
  function moveCharacterCard(cardId, direction) {
    const idx = characterData.findIndex(c => c.id === cardId);
    if (idx < 0) return;
    const newIdx = idx + direction;
    if (newIdx < 0 || newIdx >= characterData.length) return;
    const [card] = characterData.splice(idx, 1);
    characterData.splice(newIdx, 0, card);
    saveCharacterData();
    renderCharacterList();
  }

  // 役割の階層変更
  const ROLE_ORDER = ['protagonist', 'heroine', 'antagonist', 'supporting', 'mob'];
  function changeCharacterRole(cardId, direction) {
    const card = characterData.find(c => c.id === cardId);
    if (!card) return;
    const currentIdx = ROLE_ORDER.indexOf(card.role);
    const newIdx = currentIdx + direction;
    if (newIdx < 0 || newIdx >= ROLE_ORDER.length) return;
    card.role = ROLE_ORDER[newIdx];
    saveCharacterData();
    renderCharacterList();
  }

  // 全展開・全折畳
  let characterBulkExpandLevel = 0;

  function cycleCharacterBulkExpand(delta) {
    const info = getUniformCharacterExpandLevel();
    const base = info.mixed ? (typeof characterBulkExpandLevel === 'number' ? characterBulkExpandLevel : (info.level || 0)) : (info.level || 0);
    const next = (base + delta + 4) % 4;
    characterBulkExpandLevel = next;

    characterData.forEach(c => { c.expandLevel = next; });
    saveCharacterData();
    renderCharacterList();
  }

  function expandAllCharacter() {
    // 一括で最大展開（段階を回さず、常に最大へ）
    characterBulkExpandLevel = 3;
    characterData.forEach(c => { c.expandLevel = 3; });
    saveCharacterData();
    renderCharacterList();

  }

  function collapseAllCharacter() {
    // 一括で最小表示（名前のみ）にする
    characterBulkExpandLevel = 0;
    characterData.forEach(c => { c.expandLevel = 0; });
    saveCharacterData();
    renderCharacterList();
  }

  // リセット時初期化
  function initCharacterFromReset() {
    characterData = [];
    characterNextId = 1;
    localStorage.removeItem(CHARACTER_STORAGE_KEY);
    renderCharacterList();
  }

  // 既存タグを取得（サジェスト用）
  function getAllCharacterAffiliationTags() {
    const tags = new Set();
    characterData.forEach(c => c.affiliationTags.forEach(t => tags.add(t)));
    return Array.from(tags);
  }

  function getAllCharacterFreeTags() {
    const tags = new Set();
    characterData.forEach(c => c.freeTags.forEach(t => tags.add(t)));
    return Array.from(tags);
  }

  // 役割タグサジェスト表示切替（プリセット付き）
  function getAllCharacterRoles() {
    const roles = new Set();
    characterData.forEach(c => {
      if (c.role && typeof c.role === 'string' && c.role.trim()) {
        roles.add(c.role.trim());
      }
    });
    return Array.from(roles);
  }

  function toggleCharacterRoleSuggestions() {
    console.log('[DEBUG] toggleCharacterRoleSuggestions called');
    const container = document.getElementById('character-role-suggestions');
    console.log('[DEBUG] container:', container);
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      // プリセット: キー→日本語ラベルのマッピング
      const ROLE_PRESETS = [
        { key: 'protagonist', label: '主人公' },
        { key: 'heroine', label: 'ヒロイン' },
        { key: 'antagonist', label: '敵役' },
        { key: 'supporting', label: 'サブ' },
        { key: 'mob', label: 'モブ' }
      ];
      const presetKeys = ROLE_PRESETS.map(p => p.key);
      const presetLabels = ROLE_PRESETS.map(p => p.label);
      const existingRoles = getAllCharacterRoles().filter(r => !presetKeys.includes(r) && !presetLabels.includes(r));

      let html = ROLE_PRESETS.map(p =>
        `<span class="tag-item" style="background:#fef3c7; color:#92400e;" onclick="setCharacterRole('${p.key}')">${p.label}</span>`
      ).join('');

      if (existingRoles.length > 0) {
        html += existingRoles.map(r =>
          `<span class="tag-item" onclick="setCharacterRole('${r.replace(/'/g, "\\'")}')">${r}</span>`
        ).join('');
      }

      console.log('[DEBUG] html:', html);
      container.innerHTML = html;
      container.style.display = 'flex';
      console.log('[DEBUG] container.style.display set to flex');
    } else {
      container.style.display = 'none';
      console.log('[DEBUG] container hidden');
    }
  }

  function setCharacterRole(roleKeyOrLabel) {
    const input = document.getElementById('character-edit-role');
    if (input) {
      // キーが渡された場合はラベルに変換して表示
      const ROLE_LABELS = { protagonist: '主人公', heroine: 'ヒロイン', antagonist: '敵役', supporting: 'サブ', mob: 'モブ' };
      input.value = ROLE_LABELS[roleKeyOrLabel] || roleKeyOrLabel;
    }
    const container = document.getElementById('character-role-suggestions');
    if (container) container.style.display = 'none';
  }

  // タグサジェスト表示切替
  function toggleCharacterAffiliationSuggestions() {
    const container = document.getElementById('character-affiliation-suggestions');
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      const tags = getAllCharacterAffiliationTags();
      if (tags.length === 0) {
        container.innerHTML = '<span class="no-tags">まだタグがありません</span>';
      } else {
        container.innerHTML = tags.map(t => `<span class="tag-item" onclick="addCharacterAffiliationTag('${t.replace(/'/g, "\\'")}')">${t}</span>`).join('');
      }
      container.style.display = 'flex';
    } else {
      container.style.display = 'none';
    }
  }

  function toggleCharacterFreetagSuggestions() {
    const container = document.getElementById('character-freetag-suggestions');
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      const tags = getAllCharacterFreeTags();
      if (tags.length === 0) {
        container.innerHTML = '<span class="no-tags">まだタグがありません</span>';
      } else {
        container.innerHTML = tags.map(t => `<span class="tag-item" onclick="addCharacterFreeTag('${t.replace(/'/g, "\\'")}')">${t}</span>`).join('');
      }
      container.style.display = 'flex';
    } else {
      container.style.display = 'none';
    }
  }

  function addCharacterAffiliationTag(tag) {
    const input = document.getElementById('character-edit-affiliation');
    if (!input) return;
    const current = input.value.split(',').map(t => t.trim()).filter(t => t);
    if (!current.includes(tag)) {
      current.push(tag);
      input.value = current.join(', ');
    }
  }

  function addCharacterFreeTag(tag) {
    const input = document.getElementById('character-edit-freetags');
    if (!input) return;
    const current = input.value.split(',').map(t => t.trim()).filter(t => t);
    if (!current.includes(tag)) {
      current.push(tag);
      input.value = current.join(', ');
    }
  }

  // パネル制御
  function toggleCharacterPanel() {
    const panel = document.getElementById('character-panel');
    const checkbox = document.getElementById('check-character-dock');
    const container = document.getElementById('main-container');
    if (!panel || !checkbox) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;
    const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('character-panel'));

    if (isOpen && !isDocked) {
      // open floating
      if (!isFront) {
        if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
        if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
        if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
        return;
      }
      // front -> pin + collapse all others
      let __okDock = true;

      if (typeof window.__ccRequestDockWithLimit === 'function') { __okDock = window.__ccRequestDockWithLimit('character'); }

      else { checkbox.checked = true; toggleCharacterDock(); panel.classList.add('open'); __okDock = true; }

      if (!__okDock) {

        // 上限到達で入れ替えダイアログ表示中：ここでは何も畳まない

        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();

        return;

      }
} else if (!isOpen) {
      // closed -> open floating
      if (container) container.classList.remove('structure-right');
      panel.classList.add('open');
      if (checkbox.checked) { checkbox.checked = false; toggleCharacterDock(); }
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    } else {
      // docked -> close
      checkbox.checked = false;
      toggleCharacterDock();
      panel.classList.remove('open');
      panel.style.zIndex = '';
      if (window.__ccFrontPanelId === 'character-panel') window.__ccFrontPanelId = null;
    }

    const isDockedNow = checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
    if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
    if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
    if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
}

  let characterFullscreenListenerAttached = false;
  function setupCharacterFullscreenListener() {
    if (characterFullscreenListenerAttached) return;
    characterFullscreenListenerAttached = true;
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.body.classList.contains('character-fullscreen-mode')) {
        toggleCharacterFullscreen();
      }
    });
  }

  function toggleCharacterFullscreen() {
    const panel = document.getElementById('character-panel');
    if (!panel) return;
    document.body.classList.remove('structure-fullscreen-mode', 'world-fullscreen-mode');
    if (document.body.classList.contains('character-fullscreen-mode')) {
      document.body.classList.remove('character-fullscreen-mode');
      return;
    }
    panel.classList.add('open');
    document.body.classList.add('character-fullscreen-mode');
  }

  function toggleCharacterDock() {
    const checkbox = document.getElementById('check-character-dock');
    const container = document.getElementById('main-container');
    const panel = document.getElementById('character-panel');
    const swapBtn = document.getElementById('btn-character-swap');
    const pinBtn = document.getElementById('btn-character-pin');
    if (!checkbox || !container || !panel) return;

    if (checkbox.checked) {
      container.classList.add('character-docked');
if (swapBtn) swapBtn.classList.add('is-active');
      if (pinBtn) pinBtn.classList.add('pinned');
    } else {
      container.classList.remove('character-docked');
if (swapBtn) swapBtn.classList.remove('is-active');
      if (pinBtn) pinBtn.classList.remove('pinned');
    }

    if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses();
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    updateCharacterButtonState();
  }

  function toggleCharacterDockPin() {
    const checkbox = document.getElementById('check-character-dock');
    const panel = document.getElementById('character-panel');
    if (!checkbox) return;

    // Pin request
    if (!checkbox.checked) {
      if (typeof window.__ccRequestDockWithLimit === 'function') {
        window.__ccRequestDockWithLimit('character');
        return;
      }
      checkbox.checked = true;
      toggleCharacterDock();
      if (panel) panel.classList.add('open');
      return;
    }

    // Unpin (keep panel open as floating)
    checkbox.checked = false;
    toggleCharacterDock();
    if (panel) {
      panel.classList.add('open');
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    }
  }

  function swapCharacterSide() {
    if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('character');
  }


  function closeCharacterPanel(force) {
    const panel = document.getElementById('character-panel');
    const checkbox = document.getElementById('check-character-dock');
    const container = document.getElementById('main-container');
    if (!panel) return;

    document.body.classList.remove('character-fullscreen-mode');
    if (force || !checkbox || !checkbox.checked) {
      panel.classList.remove('open');
      if (checkbox) checkbox.checked = false;
      if (container) container.classList.remove('character-docked');
    } else {
      panel.classList.remove('open');
    }

    if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    updateCharacterButtonState();
  }

  function updateCharacterButtonState() {
    const panel = document.getElementById('character-panel');
    const checkbox = document.getElementById('check-character-dock');
    const btn = document.getElementById('btn-toggle-character');
    if (!btn || !panel) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox && checkbox.checked;
    const icon = btn.querySelector('.panel-state-icon');

    if (isDocked) {
      if (icon) icon.textContent = '📌';
    } else if (isOpen) {
      if (icon) icon.textContent = '▾';
    } else {
      if (icon) icon.textContent = '▾';
    }
  }

  // ========== エクスポート/インポート ==========
  function exportCharacterData() {
    if (characterData.length === 0) {
      alert('エクスポートする登場人物データがありません');
      return;
    }
    const exportData = {
      type: 'cc_character',
      version: 1,
      data: characterData.map(({ selected, isNew, ...rest }) => rest),
      nextId: characterNextId,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `登場人物_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function exportCharacterAsText() {
    if (characterData.length === 0) {
      alert('エクスポートする登場人物データがありません');
      return;
    }
    const CHARACTER_ROLES = { protagonist: '主人公', heroine: 'ヒロイン', antagonist: '敵役', supporting: 'サブ', mob: 'モブ' };
    const lines = [];
    characterData.forEach(card => {
      const roleLabel = CHARACTER_ROLES[card.role] || card.role;
      lines.push(`【${roleLabel}】${card.name}${card.reading ? ` (${card.reading})` : ''}`);
      if (card.description) lines.push(`　${card.description}`);
      if (card.affiliationTags && card.affiliationTags.length > 0) lines.push(`　所属: ${card.affiliationTags.join(', ')}`);
      if (card.freeTags && card.freeTags.length > 0) lines.push(`　タグ: ${card.freeTags.join(', ')}`);
      lines.push('');
    });
    const content = lines.join('\n');
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `登場人物_${new Date().toISOString().slice(0,10)}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }
  window.exportCharacterAsText = exportCharacterAsText;

  function importCharacterData(file, mode) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const imported = JSON.parse(e.target.result);
        if (imported.type !== 'cc_character' || !Array.isArray(imported.data)) {
          alert('有効な登場人物データファイルではありません');
          return;
        }
        if (mode === 'overwrite') {
          characterData = imported.data.map(card => ({
            ...card,
            selected: false,
            isNew: false,
            affiliationTags: card.affiliationTags || [],
            freeTags: card.freeTags || [],
            linkedStructures: card.linkedStructures || [],
            linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
            expandLevel: card.expandLevel || 0
          }));
          characterNextId = imported.nextId || (Math.max(...characterData.map(c => c.id), 0) + 1);
        } else {
          const maxId = Math.max(characterNextId, ...characterData.map(c => c.id), 0);
          let newId = maxId + 1;
          const newCards = imported.data.map(card => ({
            ...card,
            id: newId++,
            selected: false,
            isNew: false,
            affiliationTags: card.affiliationTags || [],
            freeTags: card.freeTags || [],
            linkedStructures: card.linkedStructures || [],
            linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
            expandLevel: card.expandLevel || 0
          }));
          characterData = [...characterData, ...newCards];
          characterNextId = newId;
        }
        saveCharacterData();
        renderCharacterList();
        alert(mode === 'overwrite' ? '登場人物データを読み込みました' : '登場人物データを追加しました');
      } catch (err) {
        console.error('登場人物インポートエラー:', err);
        alert('ファイルの読み込みに失敗しました');
      }
    };
    reader.readAsText(file);
  }

  // グローバル公開
  window.addCharacterCard = addCharacterCard;
  window.createCharacterCardFromSelection = createCharacterCardFromSelection;
  window.refreshCharacterPanel = refreshCharacterPanel;
  window.openCharacterEditModal = openCharacterEditModal;
  window.closeCharacterEditModal = closeCharacterEditModal;
  window.saveCharacterCard = saveCharacterCard;
  window.duplicateCharacterCard = duplicateCharacterCard;
  window.deleteCharacterCard = deleteCharacterCard;
  window.deleteSelectedCharacterCards = deleteSelectedCharacterCards;
  window.deleteAllCharacterCards = deleteAllCharacterCards;
  window.toggleCharacterExpand = toggleCharacterExpand;
  window.toggleCharacterSelect = toggleCharacterSelect;
  window.exportCharacterText = exportCharacterText;
  window.moveCharacterCard = moveCharacterCard;
  window.changeCharacterRole = changeCharacterRole;
  window.expandAllCharacter = expandAllCharacter;
  window.collapseAllCharacter = collapseAllCharacter;
  window.initCharacterFromReset = initCharacterFromReset;
  window.getAllCharacterAffiliationTags = getAllCharacterAffiliationTags;
  window.getAllCharacterFreeTags = getAllCharacterFreeTags;
  window.getCharacterData = function() { return characterData; };
  window.toggleCharacterAffiliationSuggestions = toggleCharacterAffiliationSuggestions;
  window.toggleCharacterFreetagSuggestions = toggleCharacterFreetagSuggestions;
  window.toggleCharacterRoleSuggestions = toggleCharacterRoleSuggestions;
  window.setCharacterRole = setCharacterRole;
  window.addCharacterAffiliationTag = addCharacterAffiliationTag;
  window.addCharacterFreeTag = addCharacterFreeTag;
  window.toggleCharacterStructureLink = toggleCharacterStructureLink;
  window.toggleCharacterWorldLink = toggleCharacterWorldLink;
  window.toggleCharacterPanel = toggleCharacterPanel;
  window.toggleCharacterFullscreen = toggleCharacterFullscreen;
  window.toggleCharacterDock = toggleCharacterDock;
  window.toggleCharacterDockPin = toggleCharacterDockPin;
  window.swapCharacterSide = swapCharacterSide;
  window.closeCharacterPanel = closeCharacterPanel;
  window.updateCharacterButtonState = updateCharacterButtonState;
  window.exportCharacterData = exportCharacterData;
  window.importCharacterData = importCharacterData;

  // 説明欄の文字数カウント
  const descEl = document.getElementById('character-edit-description');
  if (descEl) descEl.addEventListener('input', updateCharacterDescriptionCount);

  // 初期化
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initCharacter);
  } else {
    initCharacter();
  }
})();

// ========== 世界観パネル ==========
(function() {
  'use strict';

  const WORLD_STORAGE_KEY = 'cc_world_data';
  let worldData = [];
  let worldNextId = 1;
  let editingWorldId = null;
  let draggingWorldId = null;
  let worldMenuClickHandler = null;

  const WORLD_LEVELS = {
    major: '大カテゴリ',
    middle: '中カテゴリ',
    detail: '詳細項目'
  };

  function escapeHtml(str) {
    if (!str) return '';
    return String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function initWorld() {
    loadWorldData();
    renderWorldList();
    setupWorldFullscreenListener();
    setupWorldPanelContextMenu();
    if (window.loadPanelBackground) window.loadPanelBackground('world');
  }

  function loadWorldData() {
    try {
      const saved = localStorage.getItem(WORLD_STORAGE_KEY);
      if (saved) {
        const parsed = JSON.parse(saved);
        worldData = (parsed.data || []).map(card => ({
          ...card,
          selected: false,
          linkedCharacters: card.linkedCharacters || [],
          linkedTerms: card.linkedTerms || [],
          linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
          linkedStructures: card.linkedStructures || [],
          tabId: card.tabId ?? null,
          // expanded (boolean) から expandLevel (0,1,2) への移行対応
          expandLevel: card.expandLevel !== undefined ? card.expandLevel : (card.expanded ? 2 : 0)
        }));
        worldNextId = parsed.nextId || 1;
      }
    } catch (e) {
      console.warn('世界観データの読み込みに失敗:', e);
      worldData = [];
      worldNextId = 1;
    }
  }

  function saveWorldData() {
    try {
      const sanitized = worldData.map(({ selected, ...rest }) => rest);
      localStorage.setItem(WORLD_STORAGE_KEY, JSON.stringify({
        data: sanitized,
        nextId: worldNextId
      }));
    } catch (e) {
      console.warn('世界観データの保存に失敗:', e);
    }
  }

  function addWorldCard(level) {
    const count = worldData.filter(c => c.level === level).length;
    const newCard = {
      id: worldNextId++,
      name: WORLD_LEVELS[level] + (count + 1),
      level: level,
      termTags: [],
      linkedCharacters: [],
      linkedWorlds: [],
      linkedStructures: [],
      linkedTerms: [],
      description: '',
      color: null,
      expandLevel: 0,
      tabId: null,
      selected: false,
      isNew: true
    };
    worldData.push(newCard);
    saveWorldData();
    renderWorldList();
    openWorldEditModal(newCard.id);
  }

  function getWorldSelectedLevel() {
    const select = document.getElementById('world-add-level');
    return select?.value || 'major';
  }

  function createWorldCardFromSelection() {
    addWorldCard(getWorldSelectedLevel());
  }

  function refreshWorldPanel() {
    loadWorldData();
    renderWorldList();
  }

  function renderWorldList() {
    const container = document.getElementById('world-list');
    if (!container) return;

    if (worldData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; padding:20px; text-align:center;">世界観設定がありません。<br>上のボタンから追加してください。</div>';
      updateWorldCount();
      updateWorldBulkButtons();
      return;
    }

    container.innerHTML = '';
    worldData.forEach((card, index) => {
      const div = createWorldCardElement(card, index);
      container.appendChild(div);
    });
    updateWorldCount();
    updateWorldBulkButtons();
  }

  function createWorldCardElement(card, index) {
    const div = document.createElement('div');
    div.className = `world-card level-${card.level} hide-labels`;
    const expandLevel = card.expandLevel || 0;
    if (expandLevel === 1) div.classList.add('expand-1');
    else if (expandLevel === 2) div.classList.add('expand-2');
    else if (expandLevel >= 3) div.classList.add('expand-3');
    if (card.color) {
      div.classList.add('has-custom-color');
      div.style.setProperty('--world-card-accent', card.color);
      div.style.setProperty('--world-card-bg', toRgba(card.color, 0.12));
    }
    div.dataset.id = card.id;
    div.draggable = true;

    const termTagsHtml = card.termTags.length > 0
      ? card.termTags.map(t => `<span class="world-term-tag">${escapeHtml(t)}</span>`).join('')
      : '';

    const characterData = window.getCharacterData ? window.getCharacterData() : [];
    const structureData = window.getStructureData ? window.getStructureData() : [];
    const LEVEL_LABELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
    const STRUCTURE_LEVEL_LABELS = { chapter: '章', episode: '話', scene: 'シーン' };
    const ROLE_LABELS = { protagonist: '主人公', heroine: 'ヒロイン', antagonist: '敵役', supporting: 'サブ', mob: 'モブ' };

    const linkedCharactersHtml = (card.linkedCharacters || []).map(cid => {
      const char = characterData.find(c => c.id === cid);
      if (!char) return '';
      const roleLabel = ROLE_LABELS[char.role] || char.role || '';
      return `<span class="card-linked-item card-linked-character" onclick="event.stopPropagation(); goToLinkedPanel('character', ${cid})"><span class="card-linked-icon">👤</span><span class="card-linked-text">${escapeHtml(char.name)}</span>${roleLabel ? `<span class="card-linked-badge">${roleLabel}</span>` : ''}</span>`;
    }).join('');

    const linkedStructuresHtml = (card.linkedStructures || []).map(sid => {
      const struct = structureData.find(s => s.id === sid);
      if (!struct) return '';
      const levelLabel = STRUCTURE_LEVEL_LABELS[struct.level] || struct.level || '';
      return `<span class="card-linked-item card-linked-structure" onclick="event.stopPropagation(); goToLinkedPanel('structure', ${sid})"><span class="card-linked-icon">📋</span><span class="card-linked-text">${escapeHtml(struct.title)}</span>${levelLabel ? `<span class="card-linked-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');

    const linkedWorldsHtml = (card.linkedWorlds || []).map(wid => {
      const world = worldData.find(w => w.id === wid);
      if (!world) return '';
      const levelLabel = LEVEL_LABELS[world.level] || world.level || '';
      return `<span class="card-linked-item card-linked-world" onclick="event.stopPropagation(); goToLinkedPanel('world', ${wid})"><span class="card-linked-icon">🌍</span><span class="card-linked-text">${escapeHtml(world.name)}</span>${levelLabel ? `<span class="card-linked-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');

    const linkedTermsHtml = (card.linkedTerms || []).map(tid => {
      const term = (window.getTermsData ? window.getTermsData() : []).find(t => t.id === tid);
      if (!term) return '';
      const cat = term.category ? `<span class="card-linked-badge">${escapeHtml(term.category)}</span>` : '';
      return `<span class="card-linked-item card-linked-term" onclick="event.stopPropagation(); goToLinkedPanel('terms', ${tid})">` +
             `<span class="card-linked-icon">📚</span>` +
             `<span class="card-linked-text">${escapeHtml(term.name || '')}</span>` +
             `${cat}</span>`;
    }).join('');

    let tabLinkHtml = '';
    if (card.tabId && window.inputTabs) {
      const tab = window.inputTabs.find(t => t.id === card.tabId);
      if (tab) {
        tabLinkHtml = `<div class="world-field"><div class="world-field-label">📄</div><div style="color:#2563eb; cursor:pointer;" onclick="event.stopPropagation(); if(window.switchTab) window.switchTab(${card.tabId})">${escapeHtml(tab.name)}</div></div>`;
      }
    }


    const linkedSectionHtml = (linkedCharactersHtml || linkedStructuresHtml || linkedWorldsHtml || linkedTermsHtml) ? `
      <div class="card-linked-section">
        ${linkedCharactersHtml ? `<div class="card-linked-label">登場人物</div><div class="card-linked-items">${linkedCharactersHtml}</div>` : ''}
        ${linkedStructuresHtml ? `<div class="card-linked-label" style="margin-top:6px;">構成</div><div class="card-linked-items">${linkedStructuresHtml}</div>` : ''}
        ${linkedWorldsHtml ? `<div class="card-linked-label" style="margin-top:6px;">世界観</div><div class="card-linked-items">${linkedWorldsHtml}</div>` : ''}
        ${linkedTermsHtml ? `<div class="card-linked-label" style="margin-top:6px;">用語</div><div class="card-linked-items">${linkedTermsHtml}</div>` : ''}
      </div>
    ` : '';

    // 展開レベルに応じたトグルアイコン
    const toggleSymbols = ['▶', '▽', '▼', '◆'];
    const toggleSymbol = toggleSymbols[Math.min(expandLevel, 3)];

    // 説明の1行目プレビュー
    const descPreview = card.description ? card.description.split('\n')[0].substring(0, 50) + (card.description.length > 50 ? '...' : '') : '';

    div.innerHTML = `
      <div class="world-card-header" onclick="toggleWorldExpand(${card.id})">
        <input type="checkbox" class="world-select" ${card.selected ? 'checked' : ''} onclick="event.stopPropagation(); toggleWorldSelect(${card.id})">
        <div class="world-move-group" onclick="event.stopPropagation();">
          <button class="world-move-btn" title="上へ移動" onclick="moveWorldCard(${card.id}, -1)">↑</button>
          <button class="world-move-btn" title="下へ移動" onclick="moveWorldCard(${card.id}, 1)">↓</button>
        </div>
        <span class="world-toggle">${toggleSymbol}</span>
        <span class="world-name">${escapeHtml(card.name)}</span>
        <span class="world-level-badge">${escapeHtml(WORLD_LEVELS[card.level] || card.level || '未設定')}</span>
      </div>
      <div class="world-card-body">
        ${termTagsHtml ? `<div class="world-field"><div class="world-field-label">🏷</div><div class="world-tags">${termTagsHtml}</div></div>` : ''}
        ${descPreview ? `<div class="world-description-preview">${escapeHtml(descPreview)}</div>` : ''}
        ${card.description ? `<div class="world-field world-description"><div class="world-field-label">📝</div><div style="color:var(--text-color);">${escapeHtml(card.description)}</div></div>` : ''}
        ${tabLinkHtml}
        ${linkedSectionHtml}
        <div class="world-card-actions">
          <button onclick="openWorldEditModal(${card.id})">✏️ 編集</button>
          <button onclick="duplicateWorldCard(${card.id})">📋 複製</button>
          <button class="btn-delete" onclick="deleteWorldCard(${card.id})">🗑 削除</button>
        </div>
      </div>
    `;

    div.addEventListener('dragstart', handleWorldDragStart);
    div.addEventListener('dragend', handleWorldDragEnd);
    div.addEventListener('dragover', handleWorldDragOver);
    div.addEventListener('dragleave', handleWorldDragLeave);
    div.addEventListener('drop', handleWorldDrop);
    div.addEventListener('contextmenu', (e) => { e.preventDefault(); showWorldContextMenu(e, card.id); });
    div.addEventListener('dblclick', (e) => {
      if (e.target.closest('button, input')) return;
      const nameEl = e.target.closest('.world-name');
      if (nameEl && typeof startInlineEdit === 'function') {
        e.stopPropagation();
        startInlineEdit(nameEl, card.name, (newName) => {
          card.name = newName;
          saveWorldData();
        });
      } else {
        toggleWorldExpand(card.id);
      }
    });

    return div;
  }

  function toRgba(color, alpha = 1) {
    if (!color) return `rgba(0,0,0,${alpha})`;
    if (color.startsWith('#')) {
      const hex = color.replace('#', '');
      const size = hex.length === 3 ? 1 : 2;
      const to255 = (idx) => {
        const part = hex.substr(idx, size);
        return parseInt(size === 1 ? part + part : part, 16);
      };
      return `rgba(${to255(0)}, ${to255(size)}, ${to255(size * 2)}, ${alpha})`;
    }
    return color;
  }

  // ========== 一括展開レベル（4段階）: 世界観 ==========
  const WORLD_BULK_EXPAND_SYMBOLS = ['▶', '▽', '▼', '◆'];
  const WORLD_BULK_EXPAND_TITLES  = ['名前のみ', 'タグのみ', 'タグ+プレビュー', 'すべて表示'];

  function getUniformWorldExpandLevel() {
    if (!Array.isArray(worldData) || worldData.length === 0) return { level: 0, mixed: false };
    const getLvl = (c) => (c && c.expandLevel !== undefined) ? (c.expandLevel || 0) : 0;
    const base = getLvl(worldData[0]);
    for (const c of worldData) {
      if (getLvl(c) !== base) return { level: base, mixed: true };
    }
    return { level: base, mixed: false };
  }

  function updateWorldBulkButtons() {
    const upBtn = document.getElementById('btn-world-bulk-up');
    const downBtn = document.getElementById('btn-world-bulk-down');
    if (!upBtn || !downBtn) return;

    const info = getUniformWorldExpandLevel();

    let sym, title;
    if (info.mixed) {
      sym = '≋';
      title = '混在';
    } else {
      const level = Math.min(Math.max(info.level || 0, 0), 3);
      sym = WORLD_BULK_EXPAND_SYMBOLS[level];
      title = WORLD_BULK_EXPAND_TITLES[level];
    }

    upBtn.textContent = `全展開 +${sym}`;
    downBtn.textContent = `全折畳 -${sym}`;

    if (info.mixed) {
      upBtn.title = '一括で表示段階を上げます（現在: 混在 / カードごとに段階が異なります）';
      downBtn.title = '一括で最小表示（名前のみ）にします（現在: 混在）';
    } else {
      upBtn.title = `一括で表示段階を上げます（現在: ${sym} ${title}）`;
      downBtn.title = `一括で最小表示（名前のみ）にします（現在: ${sym} ${title}）`;
    }
  }

  function updateWorldCount() {
    const el = document.getElementById('world-count');
    if (el) el.textContent = worldData.length + '件';
  }

  function toggleWorldExpand(cardId) {
    const card = worldData.find(c => c.id === cardId);
    if (card) {
      // 4段階展開: 0 → 1 → 2 → 3 → 0
      card.expandLevel = ((card.expandLevel || 0) + 1) % 4;
      saveWorldData();
      renderWorldList();
    }
  }

  function toggleWorldSelect(cardId) {
    const card = worldData.find(c => c.id === cardId);
    if (card) {
      card.selected = !card.selected;
      renderWorldList();
    }
  }

  function openWorldEditModal(cardId) {
    const card = worldData.find(c => c.id === cardId);
    if (!card) return;
    editingWorldId = cardId;

    document.getElementById('world-edit-name').value = card.name || '';

    // アウトラインレベル（新規フィールド、デフォルト1）
    const outlineLevelSelect = document.getElementById('world-edit-outline-level');
    if (outlineLevelSelect) outlineLevelSelect.value = card.outlineLevel || '1';

    // カテゴリタグ（旧形式との互換性: enumをテキストに変換）
    const levelInput = document.getElementById('world-edit-level');
    if (levelInput) {
      const LEVEL_LABELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
      const levelValue = LEVEL_LABELS[card.level] || card.level || '';
      levelInput.value = levelValue;
    }

    document.getElementById('world-edit-termtags').value = (card.termTags || []).join(', ');
    document.getElementById('world-edit-description').value = card.description || '';
    updateWorldDescriptionCount();

    const tabSelect = document.getElementById('world-edit-tab');
    if (tabSelect) {
      tabSelect.innerHTML = '<option value="">（なし）</option>';
      if (window.inputTabs) {
        window.inputTabs.forEach(tab => {
          const opt = document.createElement('option');
          opt.value = tab.id;
          opt.textContent = tab.name;
          if (card.tabId === tab.id) opt.selected = true;
          tabSelect.appendChild(opt);
        });
      }
    }

    // 関連する登場人物と世界観をチェックボックスで表示
    populateWorldCharacterCheckboxes(card.linkedCharacters || []);
    populateWorldStructureCheckboxes(card.linkedStructures || []);
    populateWorldTermCheckboxes(card.linkedTerms || []);
    populateWorldWorldCheckboxes(card.id, card.linkedWorlds || []);

    document.getElementById('world-edit-modal').classList.add('show');
  }

  function populateWorldCharacterCheckboxes(selectedIds) {
    const container = document.getElementById('world-edit-characters');
    if (!container) return;

    const characterData = window.getCharacterData ? window.getCharacterData() : [];
    if (characterData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">登場人物パネルにキャラクターを追加してください</div>';
      return;
    }

    const CHARACTER_ROLES = { protagonist: '主人公', heroine: 'ヒロイン', antagonist: '敵役', supporting: 'サブ', mob: 'モブ' };
    container.innerHTML = characterData.map(c => {
      const selected = selectedIds.includes(c.id) ? 'selected' : '';
      const roleLabel = CHARACTER_ROLES[c.role] || c.role || '';
      return `<span class="link-tag-item ${selected}" data-id="${c.id}" onclick="toggleWorldCharacterLink(${c.id})"><span class="link-tag-text">${escapeHtml(c.name)}</span>${roleLabel ? `<span class="link-tag-badge">${roleLabel}</span>` : ''}</span>`;
    }).join('');
  }

  function toggleWorldCharacterLink(id) {
    const container = document.getElementById('world-edit-characters');
    const item = container?.querySelector(`[data-id="${id}"]`);
    if (item) item.classList.toggle('selected');
  }

  function populateWorldStructureCheckboxes(selectedIds) {
    const container = document.getElementById('world-edit-structures');
    if (!container) return;

    const structureData = window.getStructureData ? window.getStructureData() : [];
    if (structureData.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">構成パネルにカードを追加してください</div>';
      return;
    }

    const LEVEL_LABELS = { chapter: '章', episode: '話', scene: 'シーン' };
    container.innerHTML = structureData.map(s => {
      const selected = selectedIds.includes(s.id) ? 'selected' : '';
      const levelLabel = LEVEL_LABELS[s.level] || s.level || '';
      return `<span class="link-tag-item ${selected}" data-id="${s.id}" onclick="toggleWorldStructureLink(${s.id})"><span class="link-tag-text"><span class="link-tag-text">${escapeHtml(s.title)}</span></span>${levelLabel ? `<span class="link-tag-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');
  }


function populateWorldTermCheckboxes(selectedIds){
  const container = document.getElementById('world-edit-terms');
  if (!container) return;
  const terms = window.getTermsData ? window.getTermsData() : [];
  if (!terms.length){
    container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">用語パネルにカードを追加してください</div>';
    return;
  }
  container.innerHTML = terms.map(t=>{
    const selected = selectedIds.includes(t.id) ? 'selected' : '';
    const label = (t.category ? `${escapeHtml(t.category)} / ` : '') + escapeHtml(t.name||'');
    return `<span class="link-tag-item ${selected}" data-id="${t.id}" onclick="toggleWorldTermLink(${t.id})">${label}</span>`;
  }).join('');
}
function toggleWorldTermLink(termId){
  const container = document.getElementById('world-edit-terms');
  if (!container) return;
  const tag = container.querySelector(`.link-tag-item[data-id="${termId}"]`);
  if (tag) tag.classList.toggle('selected');
}



  function toggleWorldStructureLink(id) {
    const container = document.getElementById('world-edit-structures');
    const item = container?.querySelector(`[data-id="${id}"]`);
    if (item) item.classList.toggle('selected');
  }

  function populateWorldWorldCheckboxes(currentId, selectedIds) {
    const container = document.getElementById('world-edit-worlds');
    if (!container) return;

    // 自分自身以外の世界観を表示
    const otherWorlds = worldData.filter(w => w.id !== currentId);
    if (otherWorlds.length === 0) {
      container.innerHTML = '<div style="color:var(--text-muted); font-style:italic; font-size:0.8rem;">他の世界観設定がありません</div>';
      return;
    }

    const WORLD_LEVELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
    container.innerHTML = otherWorlds.map(w => {
      const selected = selectedIds.includes(w.id) ? 'selected' : '';
      const levelLabel = WORLD_LEVELS[w.level] || w.level || '';
      return `<span class="link-tag-item ${selected}" data-id="${w.id}" onclick="toggleWorldWorldLink(${w.id})"><span class="link-tag-text"><span class="link-tag-text">${escapeHtml(w.name)}</span></span>${levelLabel ? `<span class="link-tag-badge">${levelLabel}</span>` : ''}</span>`;
    }).join('');
  }

  function toggleWorldWorldLink(id) {
    const container = document.getElementById('world-edit-worlds');
    const item = container?.querySelector(`[data-id="${id}"]`);
    if (item) item.classList.toggle('selected');
  }

  function closeWorldEditModal() {
    const modal = document.getElementById('world-edit-modal');
    if (modal) modal.classList.remove('show');
    if (editingWorldId !== null) {
      const cardIndex = worldData.findIndex(c => c.id === editingWorldId);
      const card = worldData[cardIndex];
      if (card && card.isNew) {
        worldData.splice(cardIndex, 1);
        saveWorldData();
        renderWorldList();
      }
    }
    editingWorldId = null;
  }

  function saveWorldCard() {
    if (editingWorldId === null) return;
    const card = worldData.find(c => c.id === editingWorldId);
    if (!card) return;

    const levelInputValue = document.getElementById('world-edit-level').value.trim();
    // 日本語ラベルをキーに変換（プリセットカテゴリのみ）
    const LABEL_TO_KEY = { '大カテゴリ': 'major', '中カテゴリ': 'middle', '詳細': 'detail' };
    const levelValue = LABEL_TO_KEY[levelInputValue] || levelInputValue;
    card.name = document.getElementById('world-edit-name').value.trim() || levelInputValue || '名前未設定';
    card.outlineLevel = document.getElementById('world-edit-outline-level')?.value || '1';
    card.level = levelValue || '未設定';
    card.termTags = document.getElementById('world-edit-termtags').value.split(',').map(t => t.trim()).filter(t => t);
    card.description = document.getElementById('world-edit-description').value.trim();
    const tabId = document.getElementById('world-edit-tab')?.value || '';
    card.tabId = tabId ? parseInt(tabId, 10) : null;

    // 関連する登場人物を取得（タグクリック形式）
    const charContainer = document.getElementById('world-edit-characters');
    if (charContainer) {
      const selectedChars = charContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedCharacters = Array.from(selectedChars).map(el => parseInt(el.dataset.id));

// 関連する用語を取得（タグクリック形式）
const termContainer = document.getElementById('world-edit-terms');
if (termContainer) {
  const selectedTerms = termContainer.querySelectorAll('.link-tag-item.selected');
  card.linkedTerms = Array.from(selectedTerms).map(el => parseInt(el.dataset.id));
  window.__ccSyncTermsLinks('world', card.id, card.linkedTerms);
} else {
  card.linkedTerms = card.linkedTerms || [];
  window.__ccSyncTermsLinks('world', card.id, card.linkedTerms);
}

    }

    // 関連する構成を取得（タグクリック形式）
    const structureContainer = document.getElementById('world-edit-structures');
    if (structureContainer) {
      const selectedStructures = structureContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedStructures = Array.from(selectedStructures).map(el => parseInt(el.dataset.id));
    }

    // 関連する世界観を取得（タグクリック形式）
    const worldContainer = document.getElementById('world-edit-worlds');
    if (worldContainer) {
      const selectedWorlds = worldContainer.querySelectorAll('.link-tag-item.selected');
      card.linkedWorlds = Array.from(selectedWorlds).map(el => parseInt(el.dataset.id));
    }

    card.isNew = false;

    saveWorldData();
    renderWorldList();
    closeWorldEditModalWithoutDelete();
  }

  function closeWorldEditModalWithoutDelete() {
    const modal = document.getElementById('world-edit-modal');
    if (modal) modal.classList.remove('show');
    editingWorldId = null;
  }

  function updateWorldDescriptionCount() {
    const textarea = document.getElementById('world-edit-description');
    const count = document.getElementById('world-description-count');
    if (textarea && count) count.textContent = textarea.value.length;
  }

  function duplicateWorldCard(cardId) {
    const card = worldData.find(c => c.id === cardId);
    if (!card) return;
    const newCard = { ...card, id: worldNextId++, name: card.name + ' (コピー)', selected: false };
    const idx = worldData.findIndex(c => c.id === cardId);
    worldData.splice(idx + 1, 0, newCard);
    saveWorldData();
    renderWorldList();
  }

  function deleteWorldCard(cardId) {
    if (!confirm('この項目を削除しますか？')) return;
    worldData = worldData.filter(c => c.id !== cardId);
    saveWorldData();
    renderWorldList();
  }

  function deleteSelectedWorldCards() {
    const selected = worldData.filter(c => c.selected);
    if (selected.length === 0) { alert('選択されている項目がありません'); return; }
    if (!confirm(`${selected.length}件の項目を削除しますか？`)) return;
    worldData = worldData.filter(c => !c.selected);
    saveWorldData();
    renderWorldList();
  }

  function deleteAllWorldCards() {
    if (worldData.length === 0) return;
    if (!confirm('すべての世界観設定を削除しますか？')) return;
    worldData = [];
    worldNextId = 1;
    saveWorldData();
    renderWorldList();
  }

  // ドラッグ&ドロップ
  function handleWorldDragStart(e) {
    draggingWorldId = parseInt(e.currentTarget.dataset.id);
    e.currentTarget.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
  }

  function handleWorldDragEnd(e) {
    e.currentTarget.classList.remove('dragging');
    document.querySelectorAll('.world-card.drag-over').forEach(el => el.classList.remove('drag-over'));
    draggingWorldId = null;
  }

  function handleWorldDragOver(e) {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    e.currentTarget.classList.add('drag-over');
  }

  function handleWorldDragLeave(e) {
    e.currentTarget.classList.remove('drag-over');
  }

  function handleWorldDrop(e) {
    e.preventDefault();
    e.currentTarget.classList.remove('drag-over');
    const targetId = parseInt(e.currentTarget.dataset.id);
    if (draggingWorldId === null || draggingWorldId === targetId) return;

    const dragIdx = worldData.findIndex(c => c.id === draggingWorldId);
    const targetIdx = worldData.findIndex(c => c.id === targetId);
    if (dragIdx < 0 || targetIdx < 0) return;

    const [moved] = worldData.splice(dragIdx, 1);
    worldData.splice(targetIdx, 0, moved);
    saveWorldData();
    renderWorldList();
  }

  // コンテキストメニュー
  function showWorldPanelContextMenu(e) {
    hideWorldContextMenu();
    let menu = document.getElementById('world-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'world-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:160px;';
      document.body.appendChild(menu);
    }

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-item" data-action="bg-color">🎨 背景色の変更</div>
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'new-card') createWorldCardFromSelection();
        if (action === 'bg-color' && window.openPanelBackgroundColorPicker) {
          window.openPanelBackgroundColorPicker('world');
        }
        hideWorldContextMenu();
      };
    });

    if (typeof adjustContextMenuPosition === 'function') {
      adjustContextMenuPosition(menu, e.clientX, e.clientY);
    } else {
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      menu.style.display = 'block';
    }

    worldMenuClickHandler = () => hideWorldContextMenu();
    setTimeout(() => document.addEventListener('click', worldMenuClickHandler), 0);
  }

  function showWorldContextMenu(e, cardId) {
    hideWorldContextMenu();
    let menu = document.getElementById('world-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'world-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:160px;';
      document.body.appendChild(menu);
    }

    const currentCard = worldData.find(c => c.id === cardId);
    const expandLevel = currentCard ? (currentCard.expandLevel || 0) : 0;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="edit">✏️ 編集</div>
      <div class="context-menu-item" data-action="duplicate">📋 複製</div>
      <div class="context-menu-item" data-action="toggle">↕ 次の展開レベル</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="expand-0" style="padding-left:24px;">▶ 名前のみ${expandLevel === 0 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-1" style="padding-left:24px;">▽ タグのみ${expandLevel === 1 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-2" style="padding-left:24px;">▼ タグ+プレビュー${expandLevel === 2 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-3" style="padding-left:24px;">◆ すべて表示${expandLevel === 3 ? ' ✓' : ''}</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="color">🎨 色を変更</div>
      <div class="context-menu-item" data-action="reset-color">↩ 色をリセット</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="move-up">⬆ 上へ</div>
      <div class="context-menu-item" data-action="move-down">⬇ 下へ</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="level-up">⬆ レベルを上げる</div>
      <div class="context-menu-item" data-action="level-down">⬇ レベルを下げる</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="delete" style="color:#dc2626;">🗑 削除</div>
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;
        if (action === 'new-card') createWorldCardFromSelection();
        if (action === 'edit') openWorldEditModal(cardId);
        if (action === 'duplicate') duplicateWorldCard(cardId);
        if (action === 'toggle') {
          const target = worldData.find(c => c.id === cardId);
          if (target) { target.expandLevel = ((target.expandLevel || 0) + 1) % 4; saveWorldData(); renderWorldList(); }
        }
        if (action === 'expand-0' || action === 'expand-1' || action === 'expand-2' || action === 'expand-3') {
          const target = worldData.find(c => c.id === cardId);
          if (target) {
            target.expandLevel = parseInt(action.split('-')[1]);
            saveWorldData();
            renderWorldList();
          }
        }
        if (action === 'move-up') moveWorldCard(cardId, -1);
        if (action === 'move-down') moveWorldCard(cardId, 1);
        if (action === 'level-up') changeWorldLevel(cardId, -1);
        if (action === 'level-down') changeWorldLevel(cardId, 1);
        if (action === 'delete') deleteWorldCard(cardId);
        if (action === 'color') openWorldColorPicker(cardId);
        if (action === 'reset-color') resetWorldColor(cardId);
        hideWorldContextMenu();
      };
    });

    if (typeof adjustContextMenuPosition === 'function') {
      adjustContextMenuPosition(menu, e.clientX, e.clientY);
    } else {
      menu.style.left = e.clientX + 'px';
      menu.style.top = e.clientY + 'px';
      menu.style.display = 'block';
    }

    worldMenuClickHandler = () => hideWorldContextMenu();
    setTimeout(() => document.addEventListener('click', worldMenuClickHandler), 0);
  }

  function hideWorldContextMenu() {
    const menu = document.getElementById('world-context-menu');
    if (menu) menu.style.display = 'none';
    if (worldMenuClickHandler) {
      document.removeEventListener('click', worldMenuClickHandler);
      worldMenuClickHandler = null;
    }
  }

  function setupWorldPanelContextMenu() {
    const list = document.getElementById('world-list');
    if (!list) return;
    list.addEventListener('contextmenu', (e) => {
      if (e.target.closest('.world-card')) return;
      e.preventDefault();
      showWorldPanelContextMenu(e);
    });
  }

  function openWorldColorPicker(cardId) {
    const card = worldData.find(c => c.id === cardId);
    if (!card) return;

    let picker = document.getElementById('world-color-popup');
    if (!picker) {
      picker = document.createElement('div');
      picker.id = 'world-color-popup';
      picker.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10001; padding:12px; min-width:220px;';
      document.body.appendChild(picker);
    }

    const currentColor = card.color || '#10b981';
    const presetColors = ['#10b981', '#34d399', '#6ee7b7', '#059669', '#047857', '#3b82f6', '#8b5cf6', '#ec4899', '#eab308', '#ef4444'];

    picker.innerHTML = `
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
        <span style="font-weight:bold;">カードの色</span>
        <button class="picker-close" style="background:none; border:none; cursor:pointer; font-size:1rem; color:var(--text-muted);">✕</button>
      </div>
      <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px;">
        <input type="color" id="world-color-input" value="${currentColor}" style="width:50px; height:30px; border:1px solid var(--border-color); border-radius:4px; cursor:pointer;">
        <input type="text" id="world-color-text" value="${currentColor}" style="width:80px; padding:4px; border:1px solid var(--border-color); border-radius:4px;">
      </div>
      <div style="display:flex; gap:4px; flex-wrap:wrap; margin-bottom:12px;">
        ${presetColors.map(c => `<button class="world-color-preset" data-color="${c}" style="width:24px; height:24px; background:${c}; border:1px solid #ccc; border-radius:4px; cursor:pointer;${c === currentColor ? ' outline:2px solid #2563eb;' : ''}"></button>`).join('')}
      </div>
      <div style="display:flex; gap:8px; justify-content:flex-end;">
        <button class="btn" id="world-picker-cancel">キャンセル</button>
        <button class="btn btn-save" id="world-picker-apply">適用</button>
      </div>
    `;

    picker.style.left = '50%';
    picker.style.top = '50%';
    picker.style.transform = 'translate(-50%, -50%)';
    picker.style.display = 'block';

    const colorInput = picker.querySelector('#world-color-input');
    const colorText = picker.querySelector('#world-color-text');
    colorInput.oninput = () => { colorText.value = colorInput.value; };
    colorText.onchange = () => { colorInput.value = colorText.value; };

    picker.querySelectorAll('.world-color-preset').forEach(btn => {
      btn.onclick = () => {
        colorInput.value = btn.dataset.color;
        colorText.value = btn.dataset.color;
        picker.querySelectorAll('.world-color-preset').forEach(b => b.style.outline = '');
        btn.style.outline = '2px solid #2563eb';
      };
    });

    picker.querySelector('.picker-close').onclick = () => { picker.style.display = 'none'; };
    picker.querySelector('#world-picker-cancel').onclick = () => { picker.style.display = 'none'; };
    picker.querySelector('#world-picker-apply').onclick = () => {
      card.color = colorInput.value;
      saveWorldData();
      renderWorldList();
      picker.style.display = 'none';
    };
  }

  function resetWorldColor(cardId) {
    const card = worldData.find(c => c.id === cardId);
    if (!card) return;
    card.color = null;
    saveWorldData();
    renderWorldList();
  }

  function exportWorldText() {
    if (worldData.length === 0) { alert('エクスポートする項目がありません'); return; }
    let text = '【世界観設定】\n\n';
    worldData.forEach(c => {
      const indent = c.level === 'major' ? '' : (c.level === 'middle' ? '  ' : '    ');
      text += `${indent}■ ${c.name} [${WORLD_LEVELS[c.level]}]\n`;
      if (c.termTags.length > 0) text += `${indent}  用語: ${c.termTags.join(', ')}\n`;
      if (c.description) text += `${indent}  説明: ${c.description}\n`;
      text += '\n';
    });
    const blob = new Blob([text], { type: 'text/plain' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = '世界観設定.txt';
    a.click();
  }

  // カード範囲取得（子要素を含む）
  function getWorldCardRangeWithChildren(cardIdx) {
    const card = worldData[cardIdx];
    if (!card) return { start: cardIdx, end: cardIdx };
    let endIdx = cardIdx;
    if (card.level === 'major') {
      for (let i = cardIdx + 1; i < worldData.length; i++) {
        if (worldData[i].level === 'major') break;
        endIdx = i;
      }
    } else if (card.level === 'middle') {
      for (let i = cardIdx + 1; i < worldData.length; i++) {
        if (worldData[i].level === 'major' || worldData[i].level === 'middle') break;
        endIdx = i;
      }
    }
    return { start: cardIdx, end: endIdx };
  }

  // 上下移動（子要素と一緒に移動）
  function moveWorldCard(cardId, direction) {
    const idx = worldData.findIndex(c => c.id === cardId);
    if (idx < 0) return;
    const card = worldData[idx];
    const range = getWorldCardRangeWithChildren(idx);
    const count = range.end - range.start + 1;

    if (direction === -1) {
      if (idx <= 0) return;
      let targetIdx = idx - 1;
      while (targetIdx > 0) {
        const prevCard = worldData[targetIdx - 1];
        if (prevCard.level === 'major') break;
        if (prevCard.level === 'middle' && card.level === 'major') break;
        if (prevCard.level === card.level) break;
        targetIdx--;
      }
      const cardsToMove = worldData.splice(range.start, count);
      worldData.splice(targetIdx, 0, ...cardsToMove);
    } else if (direction === 1) {
      const nextIdx = range.end + 1;
      if (nextIdx >= worldData.length) return;
      const nextRange = getWorldCardRangeWithChildren(nextIdx);
      const cardsToMove = worldData.splice(range.start, count);
      const insertPos = nextRange.end - count + 1;
      worldData.splice(insertPos, 0, ...cardsToMove);
    }
    saveWorldData();
    renderWorldList();
  }

  // レベル変更
  const LEVEL_ORDER = ['major', 'middle', 'detail'];
  function changeWorldLevel(cardId, direction) {
    const card = worldData.find(c => c.id === cardId);
    if (!card) return;
    const currentIdx = LEVEL_ORDER.indexOf(card.level);
    const newIdx = currentIdx + direction;
    if (newIdx < 0 || newIdx >= LEVEL_ORDER.length) return;
    card.level = LEVEL_ORDER[newIdx];
    saveWorldData();
    renderWorldList();
  }

  // 全展開・全折畳
  let worldBulkExpandLevel = 0;

  function cycleWorldBulkExpand(delta) {
    const info = getUniformWorldExpandLevel();
    const base = info.mixed ? (typeof worldBulkExpandLevel === 'number' ? worldBulkExpandLevel : (info.level || 0)) : (info.level || 0);
    const next = (base + delta + 4) % 4;
    worldBulkExpandLevel = next;

    worldData.forEach(c => { c.expandLevel = next; });
    saveWorldData();
    renderWorldList();
  }

  function expandAllWorld() {
    // 一括で最大展開（段階を回さず、常に最大へ）
    worldBulkExpandLevel = 3;
    worldData.forEach(w => { w.expandLevel = 3; });
    saveWorldData();
    renderWorldList();

  }

  function collapseAllWorld() {
    // 一括で最小表示（名前のみ）にする
    worldBulkExpandLevel = 0;
    worldData.forEach(c => { c.expandLevel = 0; });
    saveWorldData();
    renderWorldList();
  }

  // リセット時初期化
  function initWorldFromReset() {
    worldData = [];
    worldNextId = 1;
    localStorage.removeItem(WORLD_STORAGE_KEY);
    renderWorldList();
  }

  // 既存タグを取得（サジェスト用）
  function getAllWorldTermTags() {
    const tags = new Set();
    worldData.forEach(c => c.termTags.forEach(t => tags.add(t)));
    return Array.from(tags);
  }

  // カテゴリタグサジェスト表示切替（プリセット付き）
  function getAllWorldLevels() {
    const levels = new Set();
    worldData.forEach(c => {
      if (c.level && typeof c.level === 'string' && c.level.trim()) {
        levels.add(c.level.trim());
      }
    });
    return Array.from(levels);
  }

  function toggleWorldLevelSuggestions() {
    console.log('[DEBUG] toggleWorldLevelSuggestions called');
    const container = document.getElementById('world-level-suggestions');
    console.log('[DEBUG] container:', container);
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      // プリセット: キー→日本語ラベルのマッピング
      const LEVEL_PRESETS = [
        { key: 'major', label: '大カテゴリ' },
        { key: 'middle', label: '中カテゴリ' },
        { key: 'detail', label: '詳細' }
      ];
      const presetKeys = LEVEL_PRESETS.map(p => p.key);
      const presetLabels = LEVEL_PRESETS.map(p => p.label);
      const existingLevels = getAllWorldLevels().filter(l => !presetKeys.includes(l) && !presetLabels.includes(l));

      let html = LEVEL_PRESETS.map(p =>
        `<span class="tag-item" style="background:#d1fae5; color:#065f46;" onclick="setWorldLevel('${p.key}')">${p.label}</span>`
      ).join('');

      if (existingLevels.length > 0) {
        html += existingLevels.map(l =>
          `<span class="tag-item" onclick="setWorldLevel('${l.replace(/'/g, "\\'")}')">${l}</span>`
        ).join('');
      }

      console.log('[DEBUG] html:', html);
      container.innerHTML = html;
      container.style.display = 'flex';
      console.log('[DEBUG] container.style.display set to flex');
    } else {
      container.style.display = 'none';
      console.log('[DEBUG] container hidden');
    }
  }

  function setWorldLevel(levelKeyOrLabel) {
    const input = document.getElementById('world-edit-level');
    if (input) {
      // キーが渡された場合はラベルに変換して表示
      const LEVEL_LABELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
      input.value = LEVEL_LABELS[levelKeyOrLabel] || levelKeyOrLabel;
    }
    const container = document.getElementById('world-level-suggestions');
    if (container) container.style.display = 'none';
  }

  // タグサジェスト表示切替
  function toggleWorldTermtagSuggestions() {
    const container = document.getElementById('world-termtag-suggestions');
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display) {
      const tags = getAllWorldTermTags();
      if (tags.length === 0) {
        container.innerHTML = '<span class="no-tags">まだタグがありません</span>';
      } else {
        container.innerHTML = tags.map(t => `<span class="tag-item" style="background:#d1fae5; color:#065f46; border-color:#6ee7b7;" onclick="addWorldTermTag('${t.replace(/'/g, "\\'")}')">${t}</span>`).join('');
      }
      container.style.display = 'flex';
    } else {
      container.style.display = 'none';
    }
  }

  function addWorldTermTag(tag) {
    const input = document.getElementById('world-edit-termtags');
    if (!input) return;
    const current = input.value.split(',').map(t => t.trim()).filter(t => t);
    if (!current.includes(tag)) {
      current.push(tag);
      input.value = current.join(', ');
    }
  }

  // パネル制御
  function toggleWorldPanel() {
    const panel = document.getElementById('world-panel');
    const checkbox = document.getElementById('check-world-dock');
    const container = document.getElementById('main-container');
    if (!panel || !checkbox) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;
    const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('world-panel'));

    if (isOpen && !isDocked) {
      // open floating
      if (!isFront) {
        if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
        if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
        if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
        if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
        return;
      }
      // front -> pin + collapse all others
      let __okDock = true;

      if (typeof window.__ccRequestDockWithLimit === 'function') { __okDock = window.__ccRequestDockWithLimit('world'); }

      else { checkbox.checked = true; toggleWorldDock(); panel.classList.add('open'); __okDock = true; }

      if (!__okDock) {

        // 上限到達で入れ替えダイアログ表示中：ここでは何も畳まない

        if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();

        return;

      }
} else if (!isOpen) {
      // closed -> open floating
      if (container) container.classList.remove('structure-right');
      panel.classList.add('open');
      if (checkbox.checked) { checkbox.checked = false; toggleWorldDock(); }
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    } else {
      // docked -> close
      checkbox.checked = false;
      toggleWorldDock();
      panel.classList.remove('open');
      panel.style.zIndex = '';
      if (window.__ccFrontPanelId === 'world-panel') window.__ccFrontPanelId = null;
    }

    const isDockedNow = checkbox.checked;
    if (panel.classList.contains('open')) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, isDockedNow);
    } else {
      panel.style.zIndex = '';
    }

    if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
    if (typeof updateStructureButtonState === 'function') updateStructureButtonState();
        if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
    if (typeof updateCharacterButtonState === 'function') updateCharacterButtonState();
    if (typeof updateWorldButtonState === 'function') updateWorldButtonState();
}

  let worldFullscreenListenerAttached = false;
  function setupWorldFullscreenListener() {
    if (worldFullscreenListenerAttached) return;
    worldFullscreenListenerAttached = true;
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && document.body.classList.contains('world-fullscreen-mode')) {
        toggleWorldFullscreen();
      }
    });
  }

  function toggleWorldFullscreen() {
    const panel = document.getElementById('world-panel');
    if (!panel) return;
    document.body.classList.remove('structure-fullscreen-mode', 'character-fullscreen-mode');
    if (document.body.classList.contains('world-fullscreen-mode')) {
      document.body.classList.remove('world-fullscreen-mode');
      return;
    }
    panel.classList.add('open');
    document.body.classList.add('world-fullscreen-mode');
  }

  function toggleWorldDock() {
    const checkbox = document.getElementById('check-world-dock');
    const container = document.getElementById('main-container');
    const panel = document.getElementById('world-panel');
    const swapBtn = document.getElementById('btn-world-swap');
    const pinBtn = document.getElementById('btn-world-pin');
    if (!checkbox || !container || !panel) return;

    if (checkbox.checked) {
      container.classList.add('world-docked');
if (swapBtn) swapBtn.classList.add('is-active');
      if (pinBtn) pinBtn.classList.add('pinned');
    } else {
      container.classList.remove('world-docked');
if (swapBtn) swapBtn.classList.remove('is-active');
      if (pinBtn) pinBtn.classList.remove('pinned');
    }

    if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses();
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    updateWorldButtonState();
  }

  function toggleWorldDockPin() {
    const checkbox = document.getElementById('check-world-dock');
    const panel = document.getElementById('world-panel');
    if (!checkbox) return;

    // Pin request
    if (!checkbox.checked) {
      if (typeof window.__ccRequestDockWithLimit === 'function') {
        window.__ccRequestDockWithLimit('world');
        return;
      }
      checkbox.checked = true;
      toggleWorldDock();
      if (panel) panel.classList.add('open');
      return;
    }

    // Unpin (keep panel open as floating)
    checkbox.checked = false;
    toggleWorldDock();
    if (panel) {
      panel.classList.add('open');
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    }
  }

  function swapWorldSide() {
    if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('world');
  }


  function closeWorldPanel(force) {
    const panel = document.getElementById('world-panel');
    const checkbox = document.getElementById('check-world-dock');
    const container = document.getElementById('main-container');
    if (!panel) return;

    document.body.classList.remove('world-fullscreen-mode');
    if (force || !checkbox || !checkbox.checked) {
      panel.classList.remove('open');
      if (checkbox) checkbox.checked = false;
      if (container) container.classList.remove('world-docked');
    } else {
      panel.classList.remove('open');
    }

    if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
    updateWorldButtonState();
  }

  function updateWorldButtonState() {
    const panel = document.getElementById('world-panel');
    const checkbox = document.getElementById('check-world-dock');
    const btn = document.getElementById('btn-toggle-world');
    if (!btn || !panel) return;

    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox && checkbox.checked;
    const icon = btn.querySelector('.panel-state-icon');

    if (isDocked) {
      if (icon) icon.textContent = '📌';
    } else if (isOpen) {
      if (icon) icon.textContent = '▾';
    } else {
      if (icon) icon.textContent = '▾';
    }
  }

  // ========== エクスポート/インポート ==========
  function exportWorldData() {
    if (worldData.length === 0) {
      alert('エクスポートする世界観データがありません');
      return;
    }
    const exportData = {
      type: 'cc_world',
      version: 1,
      data: worldData.map(({ selected, isNew, ...rest }) => rest),
      nextId: worldNextId,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `世界観_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  function exportWorldAsText() {
    if (worldData.length === 0) {
      alert('エクスポートする世界観データがありません');
      return;
    }
    const WORLD_LEVELS = { major: '大カテゴリ', middle: '中カテゴリ', detail: '詳細' };
    const lines = [];
    worldData.forEach(card => {
      const levelLabel = WORLD_LEVELS[card.level] || card.level;
      lines.push(`【${levelLabel}】${card.name}`);
      if (card.description) lines.push(`　${card.description}`);
      if (card.termTags && card.termTags.length > 0) lines.push(`　用語: ${card.termTags.join(', ')}`);
      lines.push('');
    });
    const content = lines.join('\n');
    const blob = new Blob([content], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `世界観_${new Date().toISOString().slice(0,10)}.txt`;
    a.click();
    URL.revokeObjectURL(url);
  }
  window.exportWorldAsText = exportWorldAsText;

  function importWorldData(file, mode) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const imported = JSON.parse(e.target.result);
        if (imported.type !== 'cc_world' || !Array.isArray(imported.data)) {
          alert('有効な世界観データファイルではありません');
          return;
        }
        if (mode === 'overwrite') {
          worldData = imported.data.map(card => ({
            ...card,
            selected: false,
            isNew: false,
            termTags: card.termTags || [],
            linkedCharacters: card.linkedCharacters || [],
          linkedTerms: card.linkedTerms || [],
            linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
            linkedStructures: card.linkedStructures || [],
            expandLevel: card.expandLevel || 0
          }));
          worldNextId = imported.nextId || (Math.max(...worldData.map(c => c.id), 0) + 1);
        } else {
          const maxId = Math.max(worldNextId, ...worldData.map(c => c.id), 0);
          let newId = maxId + 1;
          const newCards = imported.data.map(card => ({
            ...card,
            id: newId++,
            selected: false,
            isNew: false,
            termTags: card.termTags || [],
            linkedCharacters: card.linkedCharacters || [],
          linkedTerms: card.linkedTerms || [],
            linkedWorlds: card.linkedWorlds || [],
          linkedTerms: card.linkedTerms || [],
            linkedStructures: card.linkedStructures || [],
            expandLevel: card.expandLevel || 0
          }));
          worldData = [...worldData, ...newCards];
          worldNextId = newId;
        }
        saveWorldData();
        renderWorldList();
        alert(mode === 'overwrite' ? '世界観データを読み込みました' : '世界観データを追加しました');
      } catch (err) {
        console.error('世界観インポートエラー:', err);
        alert('ファイルの読み込みに失敗しました');
      }
    };
    reader.readAsText(file);
  }

  // グローバル公開
  window.addWorldCard = addWorldCard;
  window.createWorldCardFromSelection = createWorldCardFromSelection;
  window.refreshWorldPanel = refreshWorldPanel;
  window.openWorldEditModal = openWorldEditModal;
  window.closeWorldEditModal = closeWorldEditModal;
  window.saveWorldCard = saveWorldCard;
  window.duplicateWorldCard = duplicateWorldCard;
  window.deleteWorldCard = deleteWorldCard;
  window.deleteSelectedWorldCards = deleteSelectedWorldCards;
  window.deleteAllWorldCards = deleteAllWorldCards;
  window.toggleWorldExpand = toggleWorldExpand;
  window.toggleWorldSelect = toggleWorldSelect;
  window.exportWorldText = exportWorldText;
  window.moveWorldCard = moveWorldCard;
  window.changeWorldLevel = changeWorldLevel;
  window.expandAllWorld = expandAllWorld;
  window.collapseAllWorld = collapseAllWorld;
  window.initWorldFromReset = initWorldFromReset;
  window.getAllWorldTermTags = getAllWorldTermTags;
  window.getWorldData = function() { return worldData; };
  window.toggleWorldLevelSuggestions = toggleWorldLevelSuggestions;
  window.setWorldLevel = setWorldLevel;
  window.toggleWorldTermtagSuggestions = toggleWorldTermtagSuggestions;
  window.addWorldTermTag = addWorldTermTag;
  window.toggleWorldTermLink = toggleWorldTermLink;
  window.toggleWorldCharacterLink = toggleWorldCharacterLink;
  window.toggleWorldStructureLink = toggleWorldStructureLink;
  window.toggleWorldWorldLink = toggleWorldWorldLink;
  window.toggleWorldPanel = toggleWorldPanel;
  window.toggleWorldFullscreen = toggleWorldFullscreen;
  window.toggleWorldDock = toggleWorldDock;
  window.toggleWorldDockPin = toggleWorldDockPin;
  window.swapWorldSide = swapWorldSide;
  window.closeWorldPanel = closeWorldPanel;
  window.updateWorldButtonState = updateWorldButtonState;
  window.exportWorldData = exportWorldData;
  window.importWorldData = importWorldData;

  // 説明欄の文字数カウント
  const descEl = document.getElementById('world-edit-description');
  if (descEl) descEl.addEventListener('input', updateWorldDescriptionCount);

  // 初期化
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initWorld);
  } else {
    initWorld();
  }
})();

// ========== パネルインポートダイアログ ==========
(function() {
  'use strict';

  let currentImportTarget = null; // 'structure', 'character', 'world', 'memo'
  let fileInput = null;

  function showImportDialog(target, title) {
    currentImportTarget = target;
    const dialog = document.getElementById('panel-import-dialog');
    const titleEl = document.getElementById('panel-import-title');
    if (!dialog) return;
    if (titleEl) titleEl.textContent = title;
    dialog.style.display = 'flex';
    // デフォルトで上書きを選択
    const overwriteOption = dialog.querySelector('.import-option[data-value="overwrite"]');
    const mergeOption = dialog.querySelector('.import-option[data-value="merge"]');
    if (overwriteOption) overwriteOption.classList.add('selected');
    if (mergeOption) mergeOption.classList.remove('selected');
    const radioOverwrite = dialog.querySelector('input[value="overwrite"]');
    if (radioOverwrite) radioOverwrite.checked = true;
  }

  function closePanelImportDialog() {
    const dialog = document.getElementById('panel-import-dialog');
    if (dialog) dialog.style.display = 'none';
    currentImportTarget = null;
  }

  function executeImport() {
    if (!currentImportTarget) return;
    const mode = document.querySelector('input[name="import-mode"]:checked')?.value || 'overwrite';

    if (!fileInput) {
      fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.accept = '.json';
      fileInput.style.display = 'none';
      document.body.appendChild(fileInput);
    }

    fileInput.onchange = function(e) {
      const file = e.target.files[0];
      if (!file) return;
      switch (currentImportTarget) {
        case 'structure':
          if (window.importStructureData) window.importStructureData(file, mode);
          break;
        case 'character':
          if (window.importCharacterData) window.importCharacterData(file, mode);
          break;
        case 'world':
          if (window.importWorldData) window.importWorldData(file, mode);
          break;
                case 'terms':
          if (window.importTermsData) window.importTermsData(file, mode);
          break;
case 'memo':
          importMemoData(file, mode);
          break;
      }
      closePanelImportDialog();
      fileInput.value = '';
    };
    fileInput.click();
  }

  // メモのインポート
  function importMemoData(file, mode) {
    const reader = new FileReader();
    reader.onload = function(e) {
      try {
        const imported = JSON.parse(e.target.result);
        if (imported.type !== 'cc_memo' || !Array.isArray(imported.data)) {
          alert('有効なメモデータファイルではありません');
          return;
        }
        if (mode === 'overwrite') {
          // メモパネルのデータを上書き
          const memoTabsData = imported.data;
          if (typeof window.setMemoTabsData === 'function') {
            window.setMemoTabsData(memoTabsData);
            alert('メモデータを読み込みました');
          }
        } else {
          // 追加モード
          if (typeof window.appendMemoTabsData === 'function') {
            window.appendMemoTabsData(imported.data);
            alert('メモデータを追加しました');
          }
        }
      } catch (err) {
        console.error('メモインポートエラー:', err);
        alert('ファイルの読み込みに失敗しました');
      }
    };
    reader.readAsText(file);
  }

  // メモのエクスポート
  function exportMemoData() {
    const memoData = typeof window.getMemoTabsData === 'function' ? window.getMemoTabsData() : [];
    if (memoData.length === 0) {
      alert('エクスポートするメモデータがありません');
      return;
    }
    const exportData = {
      type: 'cc_memo',
      version: 1,
      data: memoData,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `メモ_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // インポートダイアログの選択肢をクリックで切り替え
  document.addEventListener('click', function(e) {
    const option = e.target.closest('.import-option');
    if (option && option.closest('#panel-import-dialog')) {
      const dialog = document.getElementById('panel-import-dialog');
      dialog.querySelectorAll('.import-option').forEach(o => o.classList.remove('selected'));
      option.classList.add('selected');
      const radio = option.querySelector('input[type="radio"]');
      if (radio) radio.checked = true;
    }
  });

  // グローバル公開
  window.openStructureImportDialog = function() { showImportDialog('structure', '📂 構成データを開く'); };
  window.openCharacterImportDialog = function() { showImportDialog('character', '📂 登場人物データを開く'); };
  window.openWorldImportDialog = function() { showImportDialog('world', '📂 世界観データを開く'); };
    window.openTermsImportDialog = function() { showImportDialog('terms', '📂 用語データを開く'); };
window.openMemoImportDialog = function() { showImportDialog('memo', '📂 メモデータを開く'); };
  window.closePanelImportDialog = closePanelImportDialog;
  window.executeImport = executeImport;
  window.exportMemoData = exportMemoData;

})();

/* ===== 用語パネル（Terms） ===== */
(function(){
  const TERMS_KEY = 'cc_terms_data';
  let termsData = [];
  let termsNextId = 1;
  let editingTermId = null;

  function loadTermsData(){
    try{
      const saved = localStorage.getItem(TERMS_KEY);
      if(saved){
        const parsed = JSON.parse(saved);
        termsData = (parsed.data || []).map(t => ({
          ...t,
          linkedCharacters: t.linkedCharacters || [],
          linkedWorlds: t.linkedWorlds || [],
          linkedStructures: t.linkedStructures || [],
          tabId: t.tabId ?? null,
          selected: false,
          expandLevel: (typeof t.expandLevel === 'number' ? t.expandLevel : 1),
          bgColor: t.bgColor || ''
        }));
        termsNextId = parsed.nextId || 1;
      } else {
        termsData = [];
        termsNextId = 1;
      }
    }catch(e){
      console.warn('用語データの読み込みに失敗:', e);
      termsData = [];
      termsNextId = 1;
    }
  }
  function saveTermsData(){
    try{
      localStorage.setItem(TERMS_KEY, JSON.stringify({ data: termsData, nextId: termsNextId }));
    }catch(e){
      console.warn('用語データの保存に失敗:', e);
    }
  }
  window.getTermsData = function(){ return termsData; };

  function escapeHtml(s){
    return String(s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function renderTermsList(){
    const list = document.getElementById('terms-list');
    if(!list) return;
    list.innerHTML = '';
    if(!termsData.length){
      const empty = document.createElement('div');
      empty.style.color = 'var(--text-muted)';
      empty.style.fontSize = '0.85rem';
      empty.textContent = 'まだ用語がありません。右上の「＋ 用語」から追加できます。';
      list.appendChild(empty);
      return;
    }

    const charData = window.getCharacterData ? window.getCharacterData() : [];
    const worldData = window.getWorldData ? window.getWorldData() : [];
    const structData = window.getStructureData ? window.getStructureData() : [];

    termsData.forEach(term => {
      const card = document.createElement('div');
      card.className = 'terms-card';
      if (term.bgColor) card.style.background = term.bgColor;
      card.dataset.id = term.id;

      const lv = Number.isInteger(term.expandLevel) ? term.expandLevel : (term.expandLevel ? 3 : 0);
      term.expandLevel = Math.max(0, Math.min(3, lv));

      card.classList.add('lv'+term.expandLevel);

      const head = document.createElement('div');
      head.className = 'terms-card-title';
      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.alignItems = 'center';
      left.style.gap = '8px';

      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.checked = !!term.selected;
      cb.onchange = () => { term.selected = cb.checked; saveTermsData(); updateTermsCount(); };
      left.appendChild(cb);

      
      const lvBadge = document.createElement('span');
      lvBadge.className = 'expand-level-badge';
      const lvIcons = ['▶','▽','▼','◆'];
      lvBadge.textContent = lvIcons[term.expandLevel] || '◆';
      lvBadge.title = '展開レベル（クリックで変更）';
      lvBadge.style.cursor = 'pointer';
      const advanceExpandLevel = () => {
        const curLv = Number.isInteger(term.expandLevel) ? term.expandLevel : (term.expandLevel ? 3 : 0);
        term.expandLevel = (curLv + 1) % 4;
        saveTermsData();
        renderTermsList();
      };
      lvBadge.onclick = (ev) => {
        ev.stopPropagation();
        advanceExpandLevel();
      };
      left.appendChild(lvBadge);
const nameSpan = document.createElement('span');
      nameSpan.textContent = term.name || '';
      nameSpan.style.fontWeight = 'bold';
      nameSpan.style.minWidth = '0';
      nameSpan.style.overflow = 'hidden';
      nameSpan.style.textOverflow = 'ellipsis';
      nameSpan.style.whiteSpace = 'nowrap';
      left.appendChild(nameSpan);

      const right = document.createElement('span');
      right.style.display = 'flex';
      right.style.gap = '6px';
      right.style.flexWrap = 'wrap';

      const btnEdit = document.createElement('button');
      btnEdit.className = 'btn';
      btnEdit.style.fontSize = '0.75rem';
      btnEdit.style.padding = '4px 8px';
      btnEdit.textContent = '編集';
      btnEdit.onclick = () => openTermEditModal(term.id);

      const btnDel = document.createElement('button');
      btnDel.className = 'btn';
      btnDel.style.fontSize = '0.75rem';
      btnDel.style.padding = '4px 8px';
      btnDel.textContent = '削除';
      btnDel.onclick = () => deleteTermCard(term.id);

      right.appendChild(btnEdit);
      right.appendChild(btnDel);

      head.style.display = 'flex';
      head.style.justifyContent = 'space-between';
      head.style.alignItems = 'center';
      head.appendChild(left);
      head.appendChild(right);
      head.onclick = (ev) => {
        if (ev.target.closest('button, input')) return;
        advanceExpandLevel();
      };

      card.appendChild(head);

      // right-click menu (same feel as other panels)
      card.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showTermsContextMenu(e, term.id);
      });

      // Double click toggles expand
      card.ondblclick = () => {
        advanceExpandLevel();
      };
const meta = document.createElement('div');
      meta.className = 'terms-card-meta';
      meta.textContent = term.category ? `カテゴリ：${term.category}` : '';
      card.appendChild(meta);

      const desc = document.createElement('div');
      desc.className = 'terms-card-desc';
      desc.textContent = term.desc || '';
      card.appendChild(desc);

      if (term.tabId && window.inputTabs) {
        const tab = window.inputTabs.find(t => t.id === term.tabId);
        if (tab) {
          const tabField = document.createElement('div');
          tabField.className = 'terms-card-desc';
          tabField.innerHTML = `<span style="color:#2563eb; cursor:pointer;" onclick="event.stopPropagation(); if(window.switchTab) window.switchTab(${term.tabId})">📄 ${escapeHtml(tab.name)}</span>`;
          card.appendChild(tabField);
        }
      }

      const linkedWrap = document.createElement('div');
      linkedWrap.className = 'terms-linked-section';

      function addLinkChip(icon, label, onClick){
        const chip = document.createElement('span');
        chip.className = 'terms-linked-item';
        chip.title = label;
        chip.innerHTML = `<span>${icon}</span><span style="min-width:0; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;">${escapeHtml(label)}</span>`;
        chip.onclick = onClick;
        linkedWrap.appendChild(chip);
      }

      (term.linkedCharacters || []).forEach(cid => {
        const c = charData.find(x => x.id === cid);
        if(!c) return;
        addLinkChip('👤', c.name || `#${cid}`, () => ccGotoLinkedItem('character', cid));
      });
      (term.linkedWorlds || []).forEach(wid => {
        const w = worldData.find(x => x.id === wid);
        if(!w) return;
        addLinkChip('🌍', w.name || `#${wid}`, () => ccGotoLinkedItem('world', wid));
      });
      (term.linkedStructures || []).forEach(sid => {
        const s = structData.find(x => x.id === sid);
        if(!s) return;
        addLinkChip('📋', s.title || s.name || `#${sid}`, () => ccGotoLinkedItem('structure', sid));
      });

      if (linkedWrap.children.length) {
        card.appendChild(linkedWrap);
      }

      list.appendChild(card);
    });
  
    const countEl = document.getElementById('terms-count');
    if (countEl) countEl.textContent = `${termsData.length}語`;
}

  function buildLinkTags(container, items, getId, getLabel, selectedIds, onToggle){
    if(!container) return;
    container.innerHTML = '';
    items.forEach(item => {
      const id = getId(item);
      const label = getLabel(item);
      const tag = document.createElement('span');
      tag.className = 'link-tag-item';
      const isOn = selectedIds.includes(id);
      tag.classList.toggle('selected', isOn);
      tag.textContent = label;
      tag.onclick = () => {
        const now = selectedIds.includes(id);
        if(now) selectedIds.splice(selectedIds.indexOf(id),1);
        else selectedIds.push(id);
        tag.classList.toggle('selected', !now);
        if(typeof onToggle === 'function') onToggle(id, !now);
      };
      container.appendChild(tag);
    });
  }

  
  function getAllTermsCategorySuggestions(){
    const tags = new Set();
    try{ loadTermsData(); }catch(e){}
    (termsData||[]).forEach(t=>{
      const c = (t.category||'').trim();
      if (c) tags.add(c);
    });
    // (terms only)
    // normalize + sort
    return Array.from(tags).map(s=>String(s).trim()).filter(Boolean).sort((a,b)=>a.localeCompare(b,'ja'));
  }

  function populateTermsCategoryDatalist(){
    const dl = document.getElementById('terms-category-datalist');
    if (!dl) return;
    const tags = getAllTermsCategorySuggestions();
    dl.innerHTML = tags.map(t => `<option value="${escapeHtml(t)}"></option>`).join('');
  }

  window.toggleTermsCategorySuggestions = function(){
    const container = document.getElementById('terms-category-suggestions');
    if (!container) return;
    if (container.style.display === 'none' || !container.style.display){
      const tags = getAllTermsCategorySuggestions();
      if (tags.length === 0){
        container.innerHTML = '<span class="no-tags">まだタグがありません</span>';
      } else {
        container.innerHTML = tags.map(t => `<span class="tag-item" onclick="addTermsCategory('${t.replace(/'/g, "\\'")}')">${escapeHtml(t)}</span>`).join('');
      }
      container.style.display = 'flex';
    } else {
      container.style.display = 'none';
    }
  };

  window.addTermsCategory = function(tag){
    const input = document.getElementById('terms-edit-category');
    if (input) input.value = tag;
    const container = document.getElementById('terms-category-suggestions');
    if (container) container.style.display = 'none';
  };
window.openTermEditModal = function(id){
    const modal = document.getElementById('terms-edit-modal');
    if(!modal) return;
    loadTermsData();
    editingTermId = id;
    const term = id ? termsData.find(t => t.id === id) : null;
    document.getElementById('terms-edit-title').textContent = id ? '用語を編集' : '用語を追加';
    document.getElementById('terms-edit-name').value = term?.name || '';
    document.getElementById('terms-edit-category').value = term?.category || '';
    document.getElementById('terms-edit-desc').value = term?.desc || '';

    const tabSelect = document.getElementById('terms-edit-tab');
    if (tabSelect) {
      tabSelect.innerHTML = '<option value="">（なし）</option>';
      if (window.inputTabs) {
        window.inputTabs.forEach(tab => {
          const opt = document.createElement('option');
          opt.value = tab.id;
          opt.textContent = tab.name;
          if (term?.tabId === tab.id) opt.selected = true;
          tabSelect.appendChild(opt);
        });
      }
    }

    // category suggestions
    try{ populateTermsCategoryDatalist(); }catch(e){}
    const sug = document.getElementById('terms-category-suggestions');
    if (sug) sug.style.display = 'none';

    const selChars = (term?.linkedCharacters || []).slice();
    const selWorlds = (term?.linkedWorlds || []).slice();
    const selStructs = (term?.linkedStructures || []).slice();

    modal.__selChars = selChars;
    modal.__selWorlds = selWorlds;
    modal.__selStructs = selStructs;

    const charData = window.getCharacterData ? window.getCharacterData() : [];
    const worldData = window.getWorldData ? window.getWorldData() : [];
    const structData = window.getStructureData ? window.getStructureData() : [];

    buildLinkTags(document.getElementById('terms-link-characters'), charData, x=>x.id, x=>`👤 ${x.name||''}`, selChars);
    buildLinkTags(document.getElementById('terms-link-worlds'), worldData, x=>x.id, x=>`🌍 ${x.name||''}`, selWorlds);
    buildLinkTags(document.getElementById('terms-link-structures'), structData, x=>x.id, x=>`📋 ${x.title||x.name||''}`, selStructs);

    modal.style.display = 'flex';
  };

  window.closeTermEditModal = function(){
    const modal = document.getElementById('terms-edit-modal');
    if(modal) modal.style.display = 'none';
    editingTermId = null;
  };

  window.saveTermCard = function(){
    const modal = document.getElementById('terms-edit-modal');
    const name = (document.getElementById('terms-edit-name').value || '').trim();
    const category = (document.getElementById('terms-edit-category').value || '').trim();
    const desc = (document.getElementById('terms-edit-desc').value || '').trim();
    const tabIdValue = (document.getElementById('terms-edit-tab')?.value || '').trim();
    const tabId = tabIdValue ? parseInt(tabIdValue, 10) : null;
    if(!name){
      alert('用語名を入力してください');
      return;
    }
    
    // remember last used category
    try{ localStorage.setItem('cc_terms_last_category', category); }catch(e){}
loadTermsData();
    const selChars = (modal && modal.__selChars) ? modal.__selChars : [];
    const selWorlds = (modal && modal.__selWorlds) ? modal.__selWorlds : [];
    const selStructs = (modal && modal.__selStructs) ? modal.__selStructs : [];

    if(editingTermId){
      const t = termsData.find(x => x.id === editingTermId);
      if(t){
        t.name = name;
        t.category = category;
        t.desc = desc;
        t.tabId = tabId;
        t.linkedCharacters = selChars.slice();
        t.linkedWorlds = selWorlds.slice();
        t.linkedStructures = selStructs.slice();
      }
    } else {
      const newTerm = {
        id: termsNextId++,
        name, category, desc,
        tabId,
        linkedCharacters: selChars.slice(),
        linkedWorlds: selWorlds.slice(),
        linkedStructures: selStructs.slice(),
        selected: false,
        expandLevel: 3,
        bgColor: ''
      };
      termsData.unshift(newTerm);
    }

    saveTermsData();
    renderTermsList();
    closeTermEditModal();
    if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
  };

  window.deleteTermCard = function(id){
    if(!confirm('この用語を削除しますか？')) return;
    loadTermsData();
    termsData = termsData.filter(t => t.id !== id);
    saveTermsData();
    renderTermsList();
  };

  window.exportTermsTxt = function(){
    loadTermsData();
    const lines = [];
    termsData.forEach(t => {
      lines.push(`■ ${t.name}${t.category ? ' ['+t.category+']' : ''}`);
      if (t.desc) lines.push(t.desc);
      lines.push('');
    });
    const blob = new Blob([lines.join('\n')], {type:'text/plain;charset=utf-8'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `terms_${new Date().toISOString().slice(0,10)}.txt`;
    a.click();
  };

  // fix5: JSON export / import (same UX as other panels)
  window.exportTermsData = function(){
    loadTermsData();
    const exportData = {
      type: 'cc_terms',
      version: 1,
      nextId: termsNextId,
      data: termsData,
      exportedAt: new Date().toISOString()
    };
    const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `用語_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  window.importTermsData = function(file, mode){
    const reader = new FileReader();
    reader.onload = function(e){
      try{
        const imported = JSON.parse(e.target.result);
        if (imported.type !== 'cc_terms' || !Array.isArray(imported.data)) {
          alert('有効な用語データファイルではありません');
          return;
        }
        if (mode === 'overwrite') {
          termsData = imported.data.map(t => ({
            id: t.id,
            name: t.name || '',
            category: t.category || '',
            desc: t.desc || '',
            tabId: t.tabId ?? null,
            linkedStructures: Array.isArray(t.linkedStructures) ? t.linkedStructures : [],
            linkedCharacters: Array.isArray(t.linkedCharacters) ? t.linkedCharacters : [],
            linkedWorlds: Array.isArray(t.linkedWorlds) ? t.linkedWorlds : []
          }));
          termsNextId = imported.nextId || (Math.max(0, ...termsData.map(x => x.id || 0)) + 1);
        } else {
          const maxId = Math.max(termsNextId, ...termsData.map(t => t.id || 0), 0);
          let newId = maxId + 1;
          const mapped = imported.data.map(t => {
            const nt = {
              ...t,
              id: newId++,
              name: t.name || '',
              category: t.category || '',
              desc: t.desc || '',
              tabId: t.tabId ?? null,
              linkedStructures: Array.isArray(t.linkedStructures) ? t.linkedStructures : [],
              linkedCharacters: Array.isArray(t.linkedCharacters) ? t.linkedCharacters : [],
              linkedWorlds: Array.isArray(t.linkedWorlds) ? t.linkedWorlds : []
            };
            return nt;
          });
          termsData = termsData.concat(mapped);
          termsNextId = newId;
        }
        saveTermsData();
        renderTermsList();
        alert('用語データを読み込みました');
      } catch(err){
        console.error(err);
        alert('読み込みに失敗しました（JSON形式を確認してください）');
      }
    };
    reader.readAsText(file);
  };


  function initTermsPanel(){
    loadTermsData();
    renderTermsList();
    if (window.loadPanelBackground) window.loadPanelBackground('terms');
  }

  // init on DOM ready
  document.addEventListener('DOMContentLoaded', () => {
    try{ initTermsPanel(); }catch(e){}
  });

  // Ensure terms card right-click works everywhere (including inner buttons)
  document.addEventListener('contextmenu', (e)=>{
    const card = e.target.closest('.terms-card');
    if (!card) return;
    if (!card.closest('#terms-panel')) return;
    const id = Number(card.dataset.id || card.getAttribute('data-id'));
    if (Number.isNaN(id)) return;
    e.preventDefault();
    e.stopPropagation();
    try{ showTermsContextMenu(e, id); }catch(err){}
  }, true);




  // ===== Toolbar / Bulk actions =====
  function createTermsCard(){
    // Always use modal (same UX as other panels)
    loadTermsData();
    const baseName = '用語';
    const nextLabel = baseName + String((termsData||[]).length + 1);

    const modal = document.getElementById('terms-edit-modal');
    if (!modal || typeof window.openTermEditModal !== 'function') {
      alert('用語の編集ウィンドウを開けませんでした。');
      return;
    }
    window.openTermEditModal(null);

    const nameEl = document.getElementById('terms-edit-name');
    if (nameEl && !nameEl.value) {
      nameEl.value = nextLabel;
      nameEl.focus();
      try { nameEl.select(); } catch(e){}
    }
    const catEl = document.getElementById('terms-edit-category');
    if (catEl && !catEl.value) {
      try {
        const last = localStorage.getItem('cc_terms_last_category') || '';
        if (last) catEl.value = last;
      } catch(e){}
    }
  }
  window.createTermsCard = createTermsCard;

  window.refreshTermsPanel = function(){
    loadTermsData();
    renderTermsList();
  };

  window.expandAllTerms = function(){
    loadTermsData();
    termsData.forEach(t => { t.expandLevel = 1; });
    saveTermsData();
    renderTermsList();
  };

  window.collapseAllTerms = function(){
    loadTermsData();
    termsData.forEach(t => { t.expandLevel = 0; });
    saveTermsData();
    renderTermsList();
  };

  window.deleteSelectedTerms = function(){
    loadTermsData();
    const before = termsData.length;
    termsData = termsData.filter(t => !t.selected);
    if (termsData.length === before) return;
    saveTermsData();
    renderTermsList();
  };

  window.deleteAllTerms = function(){
    if (!confirm('用語をすべて削除します。よろしいですか？')) return;
    termsData = [];
    termsNextId = 1;
    saveTermsData();
    renderTermsList();
  };

  window.toggleTermsFullscreen = function(){
    document.body.classList.toggle('terms-fullscreen-mode');
    const panel = document.getElementById('terms-panel');
    if (panel) panel.classList.add('open');
  };

  // ===== Card context menu (match other panels' feel) =====
  function hideTermsContextMenu(){
    const menu = document.getElementById('terms-context-menu');
    if (menu) menu.style.display = 'none';
  }
  window.hideTermsContextMenu = hideTermsContextMenu;

  function duplicateTermCard(cardId){
    const src = termsData.find(t => t.id === cardId);
    if (!src) return;
    const copy = JSON.parse(JSON.stringify(src));
    copy.id = termsNextId++;
    copy.name = (src.name || '用語') + '（複製）';
    copy.selected = false;
    termsData.splice(termsData.indexOf(src) + 1, 0, copy);
    saveTermsData();
    renderTermsList();
  }

  function moveTermCard(cardId, delta){
      const idx = termsData.findIndex(t => t.id === cardId);
      if (idx < 0) return;
      const ni = idx + delta;
      if (ni < 0 || ni >= termsData.length) return;
      const tmp = termsData[idx];
      termsData[idx] = termsData[ni];
      termsData[ni] = tmp;
      saveTermsData();
      renderTermsList();
  }
  window.moveTermCard = moveTermCard;


  function openTermsBgColorPicker(cardId){
    const term = termsData.find(t => t.id === cardId);
    if (!term) return;

    let input = document.getElementById('terms-color-input-hidden');
    if (!input){
      input = document.createElement('input');
      input.type = 'color';
      input.id = 'terms-color-input-hidden';
      input.style.position = 'fixed';
      input.style.left = '-1000px';
      input.style.top = '-1000px';
      document.body.appendChild(input);
    }
    input.value = term.bgColor || '#ffffff';
    input.onchange = () => {
      term.bgColor = input.value;
      saveTermsData();
      renderTermsList();
    };
    input.click();
  }

  function showTermsContextMenu(e, cardId) {
    hideTermsContextMenu();
    let menu = document.getElementById('terms-context-menu');
    if (!menu) {
      menu = document.createElement('div');
      menu.id = 'terms-context-menu';
      menu.className = 'context-menu';
      menu.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:10000; padding:4px 0; min-width:220px;';
      document.body.appendChild(menu);
    }

    const term = termsData.find(t => t.id === cardId);
    if (!term) return;

    // normalize expand level to 0-3
    let expandLevel = Number.isInteger(term.expandLevel) ? term.expandLevel : (term.expandLevel ? 3 : 0);
    if (expandLevel < 0) expandLevel = 0;
    if (expandLevel > 3) expandLevel = 3;

    menu.innerHTML = `
      <div class="context-menu-item" data-action="new-card">＋新しいカード</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="edit">✏️ 編集</div>
      <div class="context-menu-item" data-action="duplicate">📋 複製</div>
      <div class="context-menu-item" data-action="toggle">↕ 次の展開レベル</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="expand-0" style="padding-left:24px;">▶ 名前のみ${expandLevel === 0 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-1" style="padding-left:24px;">▽ タグのみ${expandLevel === 1 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-2" style="padding-left:24px;">▼ タグ+プレビュー${expandLevel === 2 ? ' ✓' : ''}</div>
      <div class="context-menu-item" data-action="expand-3" style="padding-left:24px;">◆ すべて表示${expandLevel === 3 ? ' ✓' : ''}</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="card-color">🎨 カード色を変更</div>
      <div class="context-menu-item" data-action="reset-color">↩ 色をリセット</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="move-up">⬆ 上へ</div>
      <div class="context-menu-item" data-action="move-down">⬇ 下へ</div>
      <div class="context-menu-separator" style="height:1px; background:var(--border-color); margin:4px 0;"></div>
      <div class="context-menu-item" data-action="delete" style="color:#ef4444;">削除</div>
    `;

    menu.querySelectorAll('.context-menu-item').forEach(item => {
      item.onclick = (ev) => {
        ev.stopPropagation();
        const action = item.dataset.action;

        if (action === 'new-card') {
          createTermsCard();
        } else if (action === 'edit') {
          openTermEditModal(cardId);
        } else if (action === 'duplicate') {
          duplicateTermCard(cardId);
        } else if (action === 'toggle') {
          term.expandLevel = (expandLevel + 1) % 4;
          saveTermsData(); renderTermsList();
        } else if (action && action.startsWith('expand-')) {
          const lv = parseInt(action.split('-')[1], 10);
          if (!Number.isNaN(lv)) {
            term.expandLevel = lv;
            saveTermsData(); renderTermsList();
          }
        } else if (action === 'card-color') {
          openTermsBgColorPicker(cardId);
        } else if (action === 'reset-color') {
          term.bgColor = '';
          saveTermsData(); renderTermsList();
        } else if (action === 'move-up') {
          moveTermCard(cardId, -1);
        } else if (action === 'move-down') {
          moveTermCard(cardId, +1);
        } else if (action === 'delete') {
          deleteTermCard(cardId);
        }

        hideTermsContextMenu();
      };
    });

    const x = e.clientX, y = e.clientY;
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    requestAnimationFrame(() => {
      const rect = menu.getBoundingClientRect();
      let nx = x, ny = y;
      if (rect.right > window.innerWidth - 8) nx = Math.max(8, window.innerWidth - rect.width - 8);
      if (rect.bottom > window.innerHeight - 8) ny = Math.max(8, window.innerHeight - rect.height - 8);
      menu.style.left = nx + 'px';
      menu.style.top = ny + 'px';
    });

    setTimeout(() => {
      document.addEventListener('mousedown', (ev)=>{ if(ev.button!==0) return; if(ev.target && ev.target.closest && ev.target.closest('#terms-context-menu')) return; hideTermsContextMenu(); }, { once: true });
    }, 0);
}


  // hide on click elsewhere
  document.addEventListener('mousedown', (ev)=>{ if(ev.button!==0) return; if(ev.target && ev.target.closest && ev.target.closest('#terms-context-menu')) return; hideTermsContextMenu(); });
})();

/* ===== 用語パネルの開閉・固定・左右入替 ===== */
function swapTermsSide() {
  if (typeof window.__ccTogglePanelSide === 'function') window.__ccTogglePanelSide('terms');
}

function closeTermsPanel(force) {
  const panel = document.getElementById('terms-panel');
  const checkbox = document.getElementById('check-terms-dock');
  const container = document.getElementById('main-container');
  if (!panel || !checkbox) return;
  panel.classList.remove('open');
  checkbox.checked = false;
  if (container) container.classList.remove('terms-docked');
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
}

function toggleTermsDockPin() {
  const checkbox = document.getElementById('check-terms-dock');
  const panel = document.getElementById('terms-panel');
  if (!checkbox) return;

  // Pin request
  if (!checkbox.checked) {
    if (typeof window.__ccRequestDockWithLimit === 'function') {
      window.__ccRequestDockWithLimit('terms');
      return;
    }
    checkbox.checked = true;
    toggleTermsDock();
    if (panel) panel.classList.add('open');
    return;
  }

  // Unpin (keep panel open as floating)
  checkbox.checked = false;
  toggleTermsDock();
  if (panel) {
    panel.classList.add('open');
    if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
  }
}


function toggleTermsDock() {
  const checkbox = document.getElementById('check-terms-dock');
  const container = document.getElementById('main-container');
  const panel = document.getElementById('terms-panel');
  const swapBtn = document.getElementById('btn-terms-swap');
  const pinBtn = document.getElementById('btn-terms-pin');
  if (!checkbox || !container || !panel) return;

  if (checkbox.checked) {
    container.classList.add('terms-docked');
    if (swapBtn) swapBtn.classList.add('is-active');
    if (pinBtn) pinBtn.classList.add('pinned');
  } else {
    container.classList.remove('terms-docked');
    if (swapBtn) swapBtn.classList.remove('is-active');
    if (pinBtn) pinBtn.classList.remove('pinned');
  }

  if (typeof window.__ccApplyPanelSideClasses === 'function') window.__ccApplyPanelSideClasses();
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
}


function toggleTermsPanel() {
  const panel = document.getElementById('terms-panel');
  const checkbox = document.getElementById('check-terms-dock');
  const container = document.getElementById('main-container');
  if (!panel || !checkbox) return;

  const isOpen = panel.classList.contains('open');
  const isDocked = checkbox.checked;
  const isFront = (!isDocked && typeof window.__ccIsPanelFront === 'function' && window.__ccIsPanelFront('terms-panel'));

  if (isOpen && !isDocked) {
    // open floating
    if (!isFront) {
      if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
      if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
      return;
    }
    // front -> pin (respect pinned-limit manager)
    let __okDock = true;
    if (typeof window.__ccRequestDockWithLimit === 'function') {
      __okDock = window.__ccRequestDockWithLimit('terms');
    } else {
      checkbox.checked = true;
      toggleTermsDock();
      panel.classList.add('open');
      __okDock = true;
    }
    if (!__okDock) {
      if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
      return;
    }
    if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
    return;
  }

  if (isOpen && isDocked) {
    // docked -> close (fold)
    closeTermsPanel(true);
    return;
  }

  // closed -> open floating
  panel.classList.add('open');
  if (checkbox.checked) {
    toggleTermsDock();
  } else {
    if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
    if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  }
  if (typeof updateTermsButtonState === 'function') updateTermsButtonState();
}


function updateTermsButtonState() {
  const btn = document.getElementById('btn-toggle-terms');
  const panel = document.getElementById('terms-panel');
  const cb = document.getElementById('check-terms-dock');
  if (!btn || !panel || !cb) return;
  const isOpen = panel.classList.contains('open');
  const isDocked = cb.checked;
  btn.classList.toggle('active', isOpen);
  btn.classList.toggle('docked', isDocked);
  const icon = btn.querySelector('.panel-state-icon');
  if (icon) icon.textContent = isOpen ? '▾' : '▸';
}

/* ===== リンク移動（用語も含む） ===== */
function ccGotoLinkedItem(type, itemId){
  if (type === 'character') {
    if (typeof window.toggleCharacterPanel === 'function') {
      const panel = document.getElementById('character-panel');
      if (!panel || !panel.classList.contains('open')) window.toggleCharacterPanel();
      else if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      setTimeout(() => {
        const card = document.querySelector(`#character-list .character-card[data-id="${itemId}"]`);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          card.style.boxShadow = '0 0 0 3px #f472b6';
          setTimeout(() => card.style.boxShadow = '', 2000);
        }
      }, 300);
    }
    return;
  }
  if (type === 'structure') {
    if (typeof window.toggleStructurePanel === 'function') {
      const panel = document.getElementById('structure-panel');
      if (!panel || !panel.classList.contains('open')) window.toggleStructurePanel();
      else if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      setTimeout(() => {
        const card = document.querySelector(`#structure-list .structure-card[data-id="${itemId}"]`);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          card.style.boxShadow = '0 0 0 3px #60a5fa';
          setTimeout(() => card.style.boxShadow = '', 2000);
        }
      }, 300);
    }
    return;
  }
  if (type === 'world') {
    if (typeof window.toggleWorldPanel === 'function') {
      const panel = document.getElementById('world-panel');
      if (!panel || !panel.classList.contains('open')) window.toggleWorldPanel();
      else if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      setTimeout(() => {
        const card = document.querySelector(`#world-list .world-card[data-id="${itemId}"]`);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          card.style.boxShadow = '0 0 0 3px #34d399';
          setTimeout(() => card.style.boxShadow = '', 2000);
        }
      }, 300);
    }
    return;
  }
  if (type === 'terms') {
    if (typeof window.toggleTermsPanel === 'function') {
      const panel = document.getElementById('terms-panel');
      if (!panel || !panel.classList.contains('open')) window.toggleTermsPanel();
      else if (window.bringPanelToFront) window.bringPanelToFront(panel, false);
      setTimeout(() => {
        const card = document.querySelector(`#terms-list .terms-card[data-id="${itemId}"]`);
        if (card) {
          card.scrollIntoView({ behavior: 'smooth', block: 'center' });
          card.style.boxShadow = '0 0 0 3px #22d3ee';
          setTimeout(() => card.style.boxShadow = '', 2000);
        }
      }, 300);
    }
    return;
  }
}


/* ===== Docked panel reorder by dragging title bars (ALL panels incl. memo/outline) ===== */
(function(){
  const container = document.getElementById('main-container');
  if (!container) return;

  const KEYS = ['memo','outline','search','world','character','structure','terms'];
  const LS_LEFT = 'cc_dock_order_left_v1';
  const LS_RIGHT = 'cc_dock_order_right_v1';

  function isDocked(key){
    return container.classList.contains(key + '-docked');
  }
  function isRight(key){
    return container.classList.contains(key + '-right');
  }
  function setRight(key, right){
    container.classList.toggle(key + '-right', !!right);
  }
  function getVisibleKeys(side){
    const arr = [];
    KEYS.forEach(k=>{
      if (!isDocked(k)) return;
      const p = document.getElementById(k+'-panel');
      if (!p) return;
      // include even if not open: order is retained; open state controls display
      if (side === 'right' ? isRight(k) : !isRight(k)) arr.push(k);
    });
    return arr;
  }
  function loadOrder(side){
    const key = side === 'right' ? LS_RIGHT : LS_LEFT;
    try{
      const raw = localStorage.getItem(key);
      if (!raw) return null;
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return parsed;
      return null;
    }catch(e){ return null; }
  }
  function saveOrder(side, list){
    const key = side === 'right' ? LS_RIGHT : LS_LEFT;
    try{ localStorage.setItem(key, JSON.stringify(list)); }catch(e){}
  }

  function normalizeOrder(side){
    const current = getVisibleKeys(side);
    const saved = loadOrder(side) || [];
    const merged = saved.filter(k => current.includes(k));
    current.forEach(k=>{ if (!merged.includes(k)) merged.push(k); });
    saveOrder(side, merged);
    return merged;
  }

  function applyOrders(){
    const left = normalizeOrder('left');
    const right = normalizeOrder('right');
    const leftBase = -1000;
    const rightBase = 1000;

    left.forEach((k, i)=>{
      const p = document.getElementById(k+'-panel');
      const r = document.getElementById('resizer-'+k);
      const po = leftBase + i*2;
      if (p) p.style.order = String(po);
      if (r) r.style.order = String(po+1);
    });
    right.forEach((k, i)=>{
      const p = document.getElementById(k+'-panel');
      const r = document.getElementById('resizer-'+k);
      const po = rightBase + i*2;
      if (p) p.style.order = String(po);
      if (r) r.style.order = String(po+1);
    });

    // keep pane-stack centered
    const ps = document.getElementById('pane-stack');
    if (ps) ps.style.order = '0';

    try { if (typeof window.__ccUpdateDockResizers === 'function') window.__ccUpdateDockResizers(); } catch(e){}
  }

  function getPaneKeyFromHeader(headerEl){
    const pid = headerEl?.dataset?.panelId || '';
    if (!pid.endsWith('-panel')) return null;
    return pid.replace('-panel','');
  }

  // init
  applyOrders();

  // Drag events
  let dragKey = null;

  document.querySelectorAll('.panel-drag-handle[draggable="true"]').forEach(h=>{
    h.addEventListener('dragstart', (e)=>{
      const k = getPaneKeyFromHeader(h);
      if (!k) return;
      dragKey = k;
      e.dataTransfer.setData('text/plain', k);
      e.dataTransfer.effectAllowed = 'move';
    });
  });

  document.addEventListener('dragover', (e)=>{
    const header = e.target.closest('.panel-drag-handle[draggable="true"]');
    if (!header) return;
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
  });

  document.addEventListener('drop', (e)=>{
    const header = e.target.closest('.panel-drag-handle[draggable="true"]');
    if (!header) return;
    const targetKey = getPaneKeyFromHeader(header);
    const k = dragKey || e.dataTransfer.getData('text/plain');
    dragKey = null;
    if (!k || !targetKey || k === targetKey) return;

    // only for docked panels
    if (!isDocked(k) || !isDocked(targetKey)) return;

    const targetSide = isRight(targetKey) ? 'right' : 'left';
    const srcSide = isRight(k) ? 'right' : 'left';

    // move across side if needed
    if (srcSide !== targetSide){
      setRight(k, targetSide === 'right');
    }

    const list = normalizeOrder(targetSide);
    const srcList = normalizeOrder(srcSide);

    // remove from both lists
    const removeFrom = (arr, key) => {
      const idx = arr.indexOf(key);
      if (idx >= 0) arr.splice(idx, 1);
    };
    removeFrom(list, k);
    removeFrom(srcList, k);

    const targetIdx = list.indexOf(targetKey);
    const insertIdx = targetIdx >= 0 ? targetIdx : list.length;
    list.splice(insertIdx, 0, k);

    saveOrder('left', normalizeOrder('left'));
    saveOrder('right', normalizeOrder('right'));
    applyOrders();
  });

})();

  // ===== Save format chooser (JSON / TXT) =====
  let __ccSaveFormatMenuEl = null;

  function hideSaveFormatMenu(){
    if (__ccSaveFormatMenuEl) __ccSaveFormatMenuEl.style.display = 'none';
  }
  window.hideSaveFormatMenu = hideSaveFormatMenu;

  function showSaveFormatMenu(ev, panelKey){
    try{
      if (!ev) ev = window.event;
      ev.preventDefault();
      ev.stopPropagation();
    }catch(e){}
    hideSaveFormatMenu();

    if (!__ccSaveFormatMenuEl){
      __ccSaveFormatMenuEl = document.createElement('div');
      __ccSaveFormatMenuEl.id = 'cc-save-format-menu';
      __ccSaveFormatMenuEl.className = 'context-menu';
      __ccSaveFormatMenuEl.style.cssText = 'position:fixed; background:var(--panel-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 4px 12px rgba(0,0,0,0.15); z-index:12000; padding:4px 0; min-width:180px; display:none;';
      document.body.appendChild(__ccSaveFormatMenuEl);

      // close on any click outside
      document.addEventListener('click', () => hideSaveFormatMenu());
      document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideSaveFormatMenu(); });
      window.addEventListener('blur', () => hideSaveFormatMenu());
    }

    const actions = {
      memo:      { json: ()=>exportMemoData(),      txt: ()=>showMemoSaveDialog() },
      structure: { json: ()=>exportStructureData(), txt: ()=>exportStructureAsText() },
      character: { json: ()=>exportCharacterData(), txt: ()=>exportCharacterAsText() },
      world:     { json: ()=>exportWorldData(),     txt: ()=>exportWorldAsText() },
      terms:     { json: ()=>exportTermsData(),     txt: ()=>exportTermsTxt() },
    };

    const act = actions[panelKey] || null;

    __ccSaveFormatMenuEl.innerHTML = `
      <div class="context-menu-item" data-fmt="json">💾 JSONで保存</div>
      <div class="context-menu-item" data-fmt="txt">📄 TXTで保存</div>
    `;

    __ccSaveFormatMenuEl.querySelectorAll('.context-menu-item').forEach(item=>{
      item.onclick = (e)=>{
        e.stopPropagation();
        const fmt = item.dataset.fmt;
        try{
          if (act && fmt === 'json') act.json();
          else if (act && fmt === 'txt') act.txt();
        }catch(err){ console.error(err); }
        hideSaveFormatMenu();
      };
    });

    // Position near button
    let x = 20, y = 20;
    try{
      const btn = ev && ev.currentTarget ? ev.currentTarget : (ev && ev.target ? ev.target : null);
      if (btn && btn.getBoundingClientRect){
        const r = btn.getBoundingClientRect();
        x = r.left;
        y = r.bottom + 4;
      }else{
        x = ev.clientX || x;
        y = ev.clientY || y;
      }
    }catch(e){}

    __ccSaveFormatMenuEl.style.left = x + 'px';
    __ccSaveFormatMenuEl.style.top = y + 'px';
    __ccSaveFormatMenuEl.style.display = 'block';

    requestAnimationFrame(()=>{
      const rect = __ccSaveFormatMenuEl.getBoundingClientRect();
      let nx = x, ny = y;
      if (rect.right > window.innerWidth - 8) nx = Math.max(8, window.innerWidth - rect.width - 8);
      if (rect.bottom > window.innerHeight - 8) ny = Math.max(8, window.innerHeight - rect.height - 8);
      __ccSaveFormatMenuEl.style.left = nx + 'px';
      __ccSaveFormatMenuEl.style.top = ny + 'px';
    });
  }
  window.showSaveFormatMenu = showSaveFormatMenu;

</script>
</body>
</html>
