<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ⓒエディタ（更新テスト）</title>
<!-- favicon: ローカルに icons/ が無い場合の ERR_FILE_NOT_FOUND を避けるため、SVG を埋め込み -->
<link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Crect width='64' height='64' rx='12' fill='%232563eb'/%3E%3Ctext x='32' y='42' font-size='34' text-anchor='middle' fill='white' font-family='system-ui,Segoe UI'%3Ec%3C/text%3E%3C/svg%3E">
<link rel="apple-touch-icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 180 180'%3E%3Crect width='180' height='180' rx='32' fill='%232563eb'/%3E%3Ctext x='90' y='122' font-size='96' text-anchor='middle' fill='white' font-family='system-ui,Segoe UI'%3Ec%3C/text%3E%3C/svg%3E">
<link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho&family=Noto+Sans+JP&family=Zen+Old+Mincho&family=M+PLUS+Rounded+1c&family=Yuji+Syuku&display=swap" rel="stylesheet">

<style>
    :root {
        --active-tab-bg: #fff59d;
        --active-tab-border: #f59e0b;
        --active-tab-text: var(--text-color);
        --bg-color: #f3f4f6; --panel-bg: #ffffff; --border-color: #e5e7eb;
        --preview-bg-color: #fdfcf0; --text-color: #1f2937; --text-muted: #6b7280;
        --header-bg: #f3f4f6; --pane-header-bg: #f9fafb;
        --col-zen-bg: #dbeafe; --col-zen-tx: #2563eb;
        --col-han-bg: #d1fae5; --col-han-tx: #059669;
        --col-mute-bg: transparent; --col-mute-tx: #d1d5db;
        --col-sym-bg: #ede9fe; --col-sym-tx: #7c3aed;
        --layout-padding: 6px;
        --layout-gap: 0px;
        --dock-top: 46px;
        --divider-size: 2px;
        --divider-hit-area: 10px;
    }
    body.theme-dark {
        --bg-color: #1f2937; --panel-bg: #374151; --border-color: #4b5563;
        --preview-bg-color: #2d3748; --text-color: #f3f4f6; --text-muted: #9ca3af;
        --header-bg: #111827; --pane-header-bg: #4b5563;
        --col-zen-bg: #1e3a5f; --col-zen-tx: #93c5fd;
        --col-han-bg: #14532d; --col-han-tx: #86efac;
        --col-mute-bg: transparent; --col-mute-tx: #6b7280;
        --col-sym-bg: #4c1d95; --col-sym-tx: #c4b5fd;
    }
    body.theme-sepia {
        --bg-color: #f5f0e1; --panel-bg: #faf6eb; --border-color: #d4c4a8;
        --preview-bg-color: #fdf8e8; --text-color: #5c4b37; --text-muted: #8b7355;
        --header-bg: #ebe3d0; --pane-header-bg: #f0e8d8;
    }
    body.theme-blue {
        --bg-color: #e0f2fe; --panel-bg: #f0f9ff; --border-color: #7dd3fc;
        --preview-bg-color: #f0f9ff; --text-color: #0c4a6e; --text-muted: #0369a1;
        --header-bg: #bae6fd; --pane-header-bg: #e0f2fe;
    }
    body.theme-green {
        --bg-color: #dcfce7; --panel-bg: #f0fdf4; --border-color: #86efac;
        --preview-bg-color: #f0fdf4; --text-color: #14532d; --text-muted: #166534;
        --header-bg: #bbf7d0; --pane-header-bg: #dcfce7;
    }
    * { box-sizing: border-box; }
    body {
        margin: 0; padding: 0; font-family: "Helvetica Neue", Arial, sans-serif;
        background: var(--bg-color); color: var(--text-color);
        height: 100vh; overflow: hidden; display: flex; flex-direction: column;
    }
    body.scroll-mode { height: auto; overflow-y: auto; display: block; }
    body.allow-scroll { height: auto; overflow-y: auto; }
    body.focus-mode header, body.focus-mode .controls-wrapper, body.focus-mode .pane-header,
    body.focus-mode .pane-subheader, body.focus-mode .pane-footer, body.focus-mode #outline-panel { display: none !important; }
    body.focus-mode .main-container { padding: 0; }
    body.focus-mode .pane { border-radius: 0; border: none; }
    .focus-exit-hint {
        position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
        background: rgba(0,0,0,0.7); color: white; padding: 8px 16px;
        border-radius: 20px; font-size: 0.8rem; z-index: 9999; display: none;
    }
    body.focus-mode .focus-exit-hint { display: block; }

    header {
        background: var(--header-bg); padding: 8px 10px;
        display: flex; justify-content: space-between; align-items: center;
        flex-shrink: 0; min-height: 46px; border-bottom: 1px solid var(--border-color);
        z-index: 100; flex-wrap: wrap; gap: 4px;
    }
    body.scroll-mode header { position: sticky; top: 0; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
    h1 { margin: 0; font-size: 1.0rem; color: var(--text-color); margin-right: 15px; }
    .header-left, .header-right { display: flex; align-items: center; flex-wrap: wrap; gap: 4px; }

    .btn {
        background: var(--panel-bg); border: 1px solid var(--border-color); padding: 4px 10px;
        cursor: pointer; border-radius: 4px; font-size: 0.8rem; color: var(--text-color);
        transition: all 0.2s; display: inline-flex; align-items: center; gap: 4px;
        height: 28px; white-space: nowrap;
    }
    .btn:hover { background: var(--pane-header-bg); border-color: #9ca3af; }
    .btn.active { background: #e5e7eb; font-weight: bold; border-color: #6b7280; }
    body.theme-dark .btn.active { background: #4b5563; }
    .btn-update { background: #e0f2fe; color: #0369a1; border-color: #7dd3fc; font-weight: bold; }
    .btn-update:hover { background: #bae6fd; }
    .btn-sync { background: #fef9c3; color: #854d0e; border-color: #fde047; font-weight: bold; }
    .btn-sync:hover { background: #fef08a; }
    .btn-save { background: #2563eb; color: white; border: 1px solid #1d4ed8; }
    .btn-save:hover { background: #1d4ed8; color: white; }
    .btn-reset-input {
        background: #fee2e2; color: #b91c1c; border: 1px solid #fecaca;
        font-weight: bold; padding: 4px 8px;
    }
    .btn-reset-input:hover { background: #fecaca; color: #991b1b; }
    .btn-undo { background: #f3e8ff; color: #7c3aed; border-color: #d8b4fe; }
    .btn-undo:hover { background: #ede9fe; }
    .btn-apply { background: #dcfce7; color: #166534; border-color: #86efac; font-size: 0.7rem; padding: 2px 6px; height: 22px; }
    .btn-apply:hover { background: #bbf7d0; }
    .btn-apply-all { background: #fef3c7; color: #92400e; border-color: #fcd34d; font-weight: bold; }
    .btn-apply-all:hover { background: #fde68a; }
    .btn-focus { background: #fce7f3; color: #be185d; border-color: #f9a8d4; }
    .btn-focus:hover { background: #fbcfe8; }
    .btn-focus.active { background: #be185d; color: white; }
    .btn-analysis { background: #dbeafe; color: #1d4ed8; border-color: #93c5fd; font-weight: bold; }
    .btn-analysis:hover { background: #bfdbfe; }
    .btn-export { background: #fef3c7; color: #92400e; border-color: #fcd34d; font-size: 0.7rem; padding: 2px 6px; }
    .btn-import { background: #e0e7ff; color: #3730a3; border-color: #a5b4fc; font-size: 0.7rem; padding: 2px 6px; }
    #file-input, #settings-file-input { display: none; }

    .dropdown { position: relative; display: inline-block; }
    .dropdown-btn { background: #fef3c7; color: #92400e; border-color: #fcd34d; }
    .dropdown-content {
        display: none; position: absolute; top: 100%; left: 0;
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        z-index: 300; min-width: 160px;
    }
    .dropdown-content.show { display: block; }
    .dropdown-content button {
        display: block; width: 100%; padding: 8px 12px; border: none;
        background: transparent; text-align: left; cursor: pointer;
        font-size: 0.85rem; color: var(--text-color);
    }
    .dropdown-content button:hover { background: #e0f2fe; }
    .dropdown-content a {
        display: block; width: 100%; padding: 8px 12px; border: none;
        background: transparent; text-align: left; cursor: pointer;
        font-size: 0.85rem; color: var(--text-color); text-decoration: none;
    }
    .dropdown-content a:hover { background: #e0f2fe; }
    .sync-dropdown:hover .sync-dropdown-content { display: block; }

    .controls-wrapper { padding: var(--layout-padding) var(--layout-padding) 0 var(--layout-padding); display: flex; flex-direction: column; gap: 6px; flex-shrink: 0; }
    .control-panel {
        background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px;
        padding: 8px 12px; font-size: 0.85rem; display: none;
        box-shadow: 0 1px 2px rgba(0,0,0,0.05); position: relative;
    }
    .control-panel.open { display: flex; animation: slideDown 0.2s ease-out; }
    @keyframes slideDown { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }
    .panel-action-buttons {
        position: absolute; top: 4px; right: 8px; display: flex; align-items: center;
        gap: 6px; z-index: 2;
    }
    .panel-close-btn,
    .panel-pin-btn {
        background: transparent; border: none; color: var(--text-muted); cursor: pointer;
        font-size: 1rem; padding: 4px 6px; line-height: 1; min-width: 22px;
    }
    .panel-close-btn:hover { color: #dc2626; }
    .panel-pin-btn { font-size: 0.9rem; opacity: 0.7; }
    .panel-pin-btn:hover { opacity: 1; }
    .panel-pin-btn.pinned { color: #dc2626; opacity: 1; }

    #search-bar { flex-wrap: wrap; gap: 8px; align-items: center; background: #f0fdf4; border-color: #bbf7d0; padding-right: 48px; order: 2; }
    body.theme-dark #search-bar { background: #14532d; border-color: #166534; }
    #search-bar input { padding: 4px 8px; border: 1px solid #d1d5db; border-radius: 4px; font-size: 0.8rem; }
    #search-match-info { font-weight: bold; color: #15803d; min-width: 60px; text-align: center; }
    .btn-search-exec { background: #dcfce7; color: #166534; border-color: #86efac; font-weight: bold; }

    #help-bar { background: #fffbeb; border: 1px solid #fcd34d; color: #92400e; line-height: 1.8; flex-direction: column; padding-right: 48px; order: 1; }
    #help-bar.open { display: flex; }
    body.theme-dark #help-bar { background: #451a03; border-color: #854d0e; color: #fcd34d; }
    .help-section { margin-bottom: 12px; }
    .help-section:last-child { margin-bottom: 0; }
    .help-title { font-weight: bold; font-size: 0.9rem; margin-bottom: 4px; border-bottom: 1px dashed #fcd34d; padding-bottom: 2px; }

    #settings-bar { margin-bottom: 0; flex-wrap: wrap; gap: 12px; font-size: 0.8rem; padding: 8px 10px; padding-right: 14px; order: 3; }
    #settings-bar .panel-action-buttons { right: 2px; }
    .setting-group { display: flex; flex-direction: column; gap: 4px; border-right: 1px solid var(--border-color); padding-right: 12px; }
    .setting-group:last-child { border-right: none; }
    .setting-title { font-weight: bold; color: var(--text-muted); margin-bottom: 2px; font-size: 0.75rem; display: flex; align-items: center; gap: 6px; }
    .setting-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    .setting-row.vertical { flex-direction: column; align-items: flex-start; gap: 6px; }
    input[type="number"] { width: 50px; }
    .settings-actions {
        border-right: none; margin-left: auto; display: flex; flex-direction: column;
        align-items: flex-end; gap: 8px; align-self: stretch; justify-content: flex-end;
        text-align: right;
    }
    .settings-actions-row {
        display: flex; gap: 8px; flex-direction: column;
        align-items: flex-end; justify-content: flex-end;
    }
    .settings-actions-row .btn-apply-all { margin-top: auto; }
    .settings-action-btn { min-width: 140px; justify-content: center; }

    .main-container { display: flex; flex: 1; gap: var(--layout-gap); overflow: hidden; padding: var(--layout-padding); position: relative; max-width: 100vw; width: 100%; box-sizing: border-box; }
    .pane-stack { display: flex; flex: 1; min-width: 0; min-height: 0; gap: 0; }
    /* .pane-stack.reverse-row uses order property for swapping */
    body.scroll-mode .main-container { overflow: visible; height: auto; max-height: none; width: 100%; max-width: 100vw; }
    body.scroll-mode .pane-stack { flex-direction: column; width: 100%; }
    body.scroll-mode .pane-stack.reverse-col { flex-direction: column-reverse; }

    .pane {
        flex: 1 1 auto; display: flex; flex-direction: column;
        background: var(--panel-bg); border: 1px solid var(--border-color); border-radius: 6px;
        min-width: 0; min-height: 0; overflow: hidden; position: relative;
    }
    #pane-input { order: 1; }
    #pane-preview { order: 3; }
    .pane-resizer { order: 2; }
    .pane-stack.reverse-row #pane-input { order: 3; }
    .pane-stack.reverse-row #pane-preview { order: 1; }
    .pane.hidden { display: none !important; }
    body.scroll-mode .pane-stack .pane { flex: none; margin-bottom: 15px; min-height: 240px; width: 100%; max-width: 100%; }
    body.scroll-mode .pane-stack .pane:last-child { margin-bottom: 0; }

    /* Pane Resizer */
    .pane-resizer {
        width: var(--divider-hit-area); cursor: col-resize;
        position: relative; flex-shrink: 0; z-index: 10;
        margin: 0 calc(-1 * (var(--divider-hit-area) / 2));
        display: flex; align-items: center; justify-content: center;
        background: transparent;
    }
    .pane-resizer::before {
        content: "";
        width: var(--divider-size);
        height: 100%;
        background: var(--border-color);
        border-radius: 999px;
    }
    .pane-resizer:hover::before,
    .pane-resizer.resizing::before { background: #3b82f6; }
    body.scroll-mode .pane-stack .pane-resizer {
        width: 100%;
        height: var(--divider-hit-area);
        cursor: row-resize;
        margin: calc(-1 * (var(--divider-hit-area) / 2)) 0;
    }
    body.scroll-mode .pane-stack .pane-resizer::before {
        width: 100%;
        height: var(--divider-size);
    }

    .dock-resizer {
        width: var(--divider-hit-area); cursor: col-resize;
        position: relative; flex-shrink: 0; z-index: 10;
        margin: 0 calc(-1 * (var(--divider-hit-area) / 2));
        display: none; align-items: center; justify-content: center;
        background: transparent;
    }
    .dock-resizer::before {
        content: "";
        width: var(--divider-size);
        height: 100%;
        background: var(--border-color);
        border-radius: 999px;
    }
    .dock-resizer:hover::before,
    .dock-resizer.resizing::before { background: #3b82f6; }

    /* ドック境界の誤操作を減らす（プレビュー｜メモ の境界を優先） */
    #resizer-memo { z-index: 20; }
    #resizer-memo-outline { z-index: 8; width: calc(var(--divider-hit-area) - 6px); }


    .pane-header {
        background: var(--pane-header-bg); padding: 0 10px; color: var(--text-muted); height: 28px;
        display: flex; justify-content: space-between; align-items: center;
        border-bottom: 1px solid var(--border-color); flex-shrink: 0;
    }
    .pane-title { display: flex; align-items: center; gap: 8px; min-width: 0; }
    .pane-header h2 { margin: 0; font-size: 0.8rem; font-weight: bold; }
    .novel-title-name {
        font-weight: bold; color: var(--text-color);
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 4px; padding: 1px 6px;
        cursor: text;
    }
    .pane-total-stats {
        font-size: 0.7rem; color: var(--text-muted);
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 999px; padding: 1px 6px; white-space: nowrap;
    }

    /* プレビュー上部（タイトル/タブバー）を羊皮紙っぽい色へ */
    #pane-preview .pane-header,
    #pane-preview .tabs-scroll-wrap {
        background: var(--preview-bg-color);
    }



    /* Tabs Scroll Buttons (Input/Preview/Memo) */
    .tabs-scroll-wrap {
        display: flex; align-items: stretch;
        background: var(--pane-header-bg);
        border-bottom: 1px solid var(--border-color);
        flex-shrink: 0;
        min-height: 32px;
        min-width: 0;
    }
    /* Memo toolbar already has its own background/border */
    .tabs-scroll-wrap.memo-tabs-wrap {
        background: transparent;
        border-bottom: none;
        min-height: auto;
        padding: 0;
    }
    /* メモタブが枠外へはみ出さないように */
    .memo-toolbar { overflow: hidden; }
    .tabs-scroll-wrap.memo-tabs-wrap { width: 100%; }
    .tabs-scroll-wrap.memo-tabs-wrap .memo-tabs { overflow-x: auto; overflow-y: hidden; }

    .tab-scroll-btn {
        width: 26px;
        flex: 0 0 26px;
        border: none;
        background: transparent;
        cursor: pointer;
        color: var(--text-muted);
        display: none;
        align-items: center;
        justify-content: center;
        user-select: none;
    }
    .tab-scroll-btn:hover { background: var(--panel-bg); color: var(--text-color); }
    .tab-scroll-btn:active { transform: translateY(1px); }
    .tab-scroll-btn.show { display: flex; }
    .tabs-scroll-wrap .input-tabs-container,
    .tabs-scroll-wrap .preview-tabs-container,
    .tabs-scroll-wrap .memo-tabs {
        flex: 1 1 auto;
        min-width: 0;
    }

    /* Input Tabs */
    .input-tabs-container {
        display: flex; align-items: center;
        overflow-x: auto;
        flex: 1 1 auto;
        min-height: 32px;
        min-width: 0;
        background: transparent;
    }
    .input-tabs-container::-webkit-scrollbar { height: 3px; }
    .input-tabs-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
    .input-tab {
        padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border: none;
        background: transparent; color: var(--text-muted); white-space: nowrap;
        border-right: 1px solid var(--border-color); display: flex; align-items: center; gap: 6px;
        transition: all 0.2s;
    }
    .input-tab:hover { background: var(--panel-bg); }
    .input-tab.active { background: var(--active-tab-bg); color: var(--active-tab-text); font-weight: bold; border-bottom: 2px solid var(--active-tab-border); }
    .input-tab .tab-close {
        font-size: 0.7rem; color: var(--text-muted); cursor: pointer;
        padding: 0 2px; border-radius: 2px; line-height: 1;
    }
    .input-tab .tab-close:hover { background: #fee2e2; color: #dc2626; }
    .input-tab-add {
        padding: 4px 10px; font-size: 1rem; cursor: pointer; border: none;
        background: transparent; color: var(--text-muted); line-height: 1;
    }
    .input-tab-add:hover { color: #2563eb; background: #e0f2fe; }
    .tab-name-input {
        font-size: 0.75rem; padding: 2px 4px; border: 1px solid #2563eb;
        border-radius: 2px; width: 80px; background: var(--panel-bg);
    }
    .novel-title-input {
        font-size: 0.8rem; padding: 2px 4px; border: 1px solid #2563eb;
        border-radius: 2px; width: 160px; background: var(--panel-bg);
    }
    .pane-close-btn {
        background: transparent; border: none; color: var(--text-muted); cursor: pointer;
        font-size: 1rem; padding: 0 4px; line-height: 1;
    }
    .pane-close-btn:hover { color: #dc2626; }
    .pane-actions { display: inline-flex; align-items: center; gap: 4px; }
    .pane-layout-btn {
        background: #e0f2fe; border: 1px solid #bae6fd; color: #0c4a6e;
        cursor: pointer; font-size: 0.65rem; padding: 2px 6px; border-radius: 4px;
    }
    .pane-layout-btn:hover { background: #bae6fd; }
    .pane-subheader {
        background: #f0f9ff; color: #0369a1; font-size: 0.75rem; padding: 2px 10px;
        border-bottom: 1px solid #e0f2fe; text-align: right; font-family: monospace; flex-shrink: 0;
    }
    body.theme-dark .pane-subheader { background: #1e3a5f; color: #93c5fd; border-color: #1e40af; }
    .pane-body { flex: 1; overflow: hidden; position: relative; min-height: 0; }
    #pane-preview .pane-body { background-color: var(--preview-bg-color); }
    .pane-footer {
        padding: 0 8px; font-size: 0.7rem; color: var(--text-muted);
        text-align: right; border-top: 1px solid var(--border-color); background: var(--panel-bg);
        display: flex; justify-content: flex-end; align-items: center; gap: 10px; min-height: 24px;
        flex-wrap: wrap; flex-shrink: 0; row-gap: 4px;
    }
    .net-count { font-weight: bold; color: var(--text-color); background: var(--pane-header-bg); padding: 0 4px; border-radius: 3px; }
    .timestamp { font-family: monospace; color: #059669; }
    .goal-display { font-weight: bold; }
    .goal-0-24 { color: #1f2937; } .goal-25-49 { color: #16a34a; } .goal-50-74 { color: #2563eb; }
    .goal-75-99 { color: #ec4899; } .goal-100 { color: #06b6d4; }
    body.theme-dark .goal-0-24 { color: #f3f4f6; }
    .today-goal { font-weight: bold; color: #f97316; }
    .today-goal.achieved { color: #10b981; }
    .writing-time { color: #8b5cf6; font-weight: bold; }

    .selection-overlay {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        background: rgba(37, 99, 235, 0.9); color: white; padding: 6px 16px;
        border-radius: 20px; font-size: 0.85rem; font-weight: bold; z-index: 50;
        pointer-events: none; display: none; box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        width: max-content; text-align: center;
    }
    .selection-overlay.show { display: block; }

    /* Quick Insert Popup */
    .quick-insert-popup {
        position: fixed; display: none; z-index: 1000;
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        padding: 4px; gap: 2px;
    }
    .quick-insert-popup.show { display: flex; }
    .quick-insert-popup button {
        padding: 6px 12px; border: none; background: transparent;
        cursor: pointer; font-size: 0.8rem; border-radius: 4px;
        color: var(--text-color); white-space: nowrap;
    }
    .quick-insert-popup button:hover { background: #e0f2fe; }
    .quick-insert-popup .qip-ruby { color: #dc2626; }
    .quick-insert-popup .qip-bouten { color: #7c3aed; }

    textarea {
        width: 100%; height: 100%; border: none; outline: none; resize: none;
        padding: 20px; background: transparent; font-family: inherit; line-height: inherit; font-size: inherit;
        white-space: pre-wrap; word-wrap: break-word; z-index: 2; position: relative; color: var(--text-color);
        overflow: auto; box-sizing: border-box;
    }
    textarea::selection { background-color: #bae6fd; color: #000; }
    .vertical-mode textarea { overflow-x: auto; overflow-y: hidden; }
    #input-mirror-container {
        position: absolute; top: 0; left: 0; right: 0; bottom: 0;
        visibility: hidden; pointer-events: none;
        white-space: pre-wrap; word-wrap: break-word; overflow: hidden; padding: 20px; box-sizing: border-box;
    }
    .vertical-mode textarea, .vertical-mode #input-mirror-container { writing-mode: vertical-rl; text-orientation: upright; }

    #preview-scroll { width: 100%; height: 100%; padding: 20px; scroll-behavior: smooth; overflow-x: auto; overflow-y: auto; box-sizing: border-box; min-width: 0; position: relative; }
    #preview-scroll.vertical-mode { overflow-x: auto !important; overflow-y: hidden !important; height: 100%; width: 100%; max-width: 100%; }
    #preview-scroll.vertical-mode #preview-content { writing-mode: vertical-rl; text-orientation: upright; min-height: 100%; width: max-content; max-width: none; }
    #preview-content { word-wrap: break-word; overflow-wrap: break-word; word-break: break-word; color: var(--text-color); max-width: 100%; min-width: 0; box-sizing: border-box; }
    body.scroll-mode #preview-scroll { height: 100%; overflow-y: auto; }
    body.scroll-mode #preview-scroll.vertical-mode { overflow-x: auto !important; }
    #pane-preview .pane-body { overflow: auto; }

    /* Preview Tabs */
    .preview-tabs-container {
        display: flex; align-items: center;
        overflow-x: auto;
        flex: 1 1 auto;
        min-height: 32px;
        min-width: 0;
        background: transparent;
    }
    .preview-tabs-container::-webkit-scrollbar { height: 3px; }
    .preview-tabs-container::-webkit-scrollbar-thumb { background: var(--border-color); border-radius: 3px; }
    .preview-tab {
        padding: 6px 12px; font-size: 0.75rem; cursor: pointer; border: none;
        background: transparent; color: var(--text-muted); white-space: nowrap;
        border-right: 1px solid var(--border-color); transition: all 0.2s;
    }
    .preview-tab:hover { background: var(--panel-bg); }
    .preview-tab.active { background: var(--panel-bg); color: var(--text-color); font-weight: bold; border-bottom: 2px solid #16a34a; }
    #pane-preview .pane-title h2 { color: var(--text-color); font-weight: 700; }
    #pane-preview .preview-tab { color: var(--text-color); }
    #pane-preview .preview-tab:not(.active) { opacity: 0.75; }

    ruby { ruby-align: space-between; ruby-position: over; }
    rt { color: #555; user-select: none; font-size: 0.5em; }
    body.theme-dark rt { color: #aaa; }
    .bouten-ruby rt { font-size: 0.8em; font-weight: bold; color: #333; transform: translateY(10%); }
    body.theme-dark .bouten-ruby rt { color: #eee; }
    .space-zen, .space-han { display: inline-block; font-family: monospace; color: var(--col-mute-tx); background-color: var(--col-mute-bg); }
    .space-han { min-width: 0.3em; text-align: center; }
    .highlight-active .space-zen { background-color: var(--col-zen-bg); color: var(--col-zen-tx); }
    .highlight-active .space-han { background-color: var(--col-han-bg); color: var(--col-han-tx); }
    .symbol-hl { background-color: var(--col-sym-bg); color: var(--col-sym-tx); font-weight: bold; }
    .bracket-blue { color: #2563eb; font-weight: bold; }
    .bracket-green { color: #059669; font-weight: bold; }
    .underline-text { text-decoration: underline; text-decoration-color: #dc2626; text-underline-offset: 2px; }
    .highlight-text { background: linear-gradient(transparent 60%, #fef08a 60%); }
    body.theme-dark .highlight-text { background: linear-gradient(transparent 60%, #854d0e 60%); }

    /* Memo Panel */
    #memo-panel {
        position: fixed; top: var(--dock-top); left: 0; bottom: 0; width: 260px;
        background: #fefce8; border-right: 1px solid #fcd34d;
        box-shadow: 2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(-100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    body.theme-dark #memo-panel { background: #422006; border-color: #854d0e; }
    #memo-panel.open { transform: translateX(0); }
    .main-container.memo-docked #memo-panel {
        position: relative; top: auto; left: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 260px;
        border-right: 1px solid #fcd34d; border-left: none;
        order: -10; /* デフォルトで左側 */
    }
    .main-container.memo-docked #memo-panel.open { display: flex; }
    .main-container.memo-docked.memo-right #memo-panel { order: 10; border-right: none; border-left: 1px solid #fcd34d; }
    .main-container.memo-docked #memo-panel.open ~ #resizer-memo { display: flex; }
    .main-container.memo-docked.memo-right #resizer-memo { order: 9; }
    .main-container.memo-docked:not(.memo-right) #resizer-memo { order: -9; }
    .memo-header {
        padding: 8px 10px; background: #fef3c7; border-bottom: 1px solid #fcd34d;
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
    }
    body.theme-dark .memo-header { background: #713f12; border-color: #854d0e; }
    .memo-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .memo-controls label { display: inline-flex; align-items: center; gap: 4px; }
    .memo-toolbar {
        display: flex; justify-content: space-between; align-items: center;
        padding: 4px 8px; background: #fef3c7; border-bottom: 1px solid #fcd34d;
        gap: 4px;
        overflow: hidden;
    }
    body.theme-dark .memo-toolbar { background: #713f12; border-color: #854d0e; }
    body.theme-dark .memo-tab { background: #a16207; border-color: #d97706; color: #fef3c7; }
    body.theme-dark .memo-tab.active { background: #1f2937; border-bottom-color: #1f2937; }
    body.theme-dark .memo-tab-add { border-color: #f59e0b; color: #fbbf24; }
    .memo-tabs {
        display: flex; gap: 4px; flex: 1; overflow-x: auto;
        align-items: flex-end; padding: 2px 2px 0; min-height: 24px; min-width: 0;
    }
    .memo-tabs::-webkit-scrollbar { height: 3px; }
    .memo-tabs::-webkit-scrollbar-thumb { background: #fcd34d; border-radius: 3px; }
    .memo-tab {
        padding: 2px 8px; font-size: 0.75rem; background: #fff3b3; border: 1px solid #f59e0b;
        border-radius: 4px 4px 0 0; cursor: pointer; white-space: nowrap;
        display: inline-flex; align-items: center; gap: 4px;
    }
    .memo-tab.active { background: #ffffff; border-bottom-color: #ffffff; }
    .memo-tab-add { background: transparent; border: 1px dashed #f59e0b; color: #92400e; }
    .memo-tab .tab-close {
        margin-left: 2px; padding: 0 4px; border-radius: 4px; font-size: 0.65rem;
    }
    .memo-tab .tab-close:hover { background: #fee2e2; color: #dc2626; }
    .memo-tab.dragging, .input-tab.dragging { opacity: 0.5; }
    .memo-file-btns { display: flex; gap: 2px; }
    #memo-area {
        flex: 1; width: 100%; padding: 12px; border: none; resize: none;
        font-size: 0.9rem; line-height: 1.6; background: transparent;
        font-family: inherit; color: var(--text-color); box-sizing: border-box;
    }
    #memo-area:focus { outline: none; }
    .memo-footer {
        padding: 4px 10px; background: #fef3c7; border-top: 1px solid #fcd34d;
        text-align: right;
    }
    body.theme-dark .memo-footer { background: #713f12; border-color: #854d0e; }
    body.focus-mode #memo-panel { display: none !important; }

    #outline-panel {
        position: fixed; top: var(--dock-top); right: 0; bottom: 0; width: 260px;
        background: var(--panel-bg); border-left: 1px solid var(--border-color);
        box-shadow: -2px 0 5px rgba(0,0,0,0.1);
        z-index: 200; transform: translateX(100%); transition: transform 0.3s ease;
        display: flex; flex-direction: column;
    }
    #outline-panel.open { transform: translateX(0); }
    .main-container.outline-docked #outline-panel {
        position: relative; top: auto; right: auto; bottom: auto;
        transform: none; box-shadow: none; z-index: 1; display: none;
        flex: 0 0 auto; overflow: auto;
        min-width: 0; max-width: 45vw; width: 260px;
        border-left: 1px solid var(--border-color); border-right: none;
        order: 10; /* デフォルトで右側 */
    }
    .main-container.outline-docked #outline-panel.open { display: flex; }
    .main-container.outline-docked.outline-left #outline-panel { order: -10; border-left: none; border-right: 1px solid var(--border-color); }
    .main-container.outline-docked #outline-panel.open + #resizer-outline { display: flex; }
    .main-container.outline-docked.outline-left #resizer-outline { order: -9; }
    .main-container.outline-docked:not(.outline-left) #resizer-outline { order: 9; }

    .outline-header {
        padding: 8px 10px; background: var(--pane-header-bg); border-bottom: 1px solid var(--border-color);
        font-weight: bold; display: flex; justify-content: space-between; align-items: center;
        font-size: 0.85rem; flex-wrap: wrap; gap: 4px;
    }
    .outline-controls { display: flex; align-items: center; gap: 6px; flex-wrap: wrap; }
    .outline-controls label { display: inline-flex; align-items: center; gap: 4px; }
    .panel-swap-btn {
        display: inline-flex; align-items: center; justify-content: center;
        padding: 2px 6px; font-size: 0.7rem; min-width: 60px;
        opacity: 0; pointer-events: none; visibility: hidden;
    }
    .panel-swap-btn.is-active { opacity: 1; pointer-events: auto; visibility: visible; }
    .dock-pin-checkbox { display: none; }
    .main-container.dock-split-right #resizer-memo-outline,
    .main-container.dock-split-left #resizer-memo-outline { display: flex; }
    .main-container.dock-split-right #resizer-outline,
    .main-container.dock-split-left #resizer-outline { display: none; }
    .main-container.dock-split-right #memo-panel { order: 10; }
    .main-container.dock-split-right #resizer-memo-outline { order: 11; }
    .main-container.dock-split-right #outline-panel { order: 12; }
    .main-container.dock-split-left #memo-panel { order: -12; }
    .main-container.dock-split-left #resizer-memo-outline { order: -11; }
    .main-container.dock-split-left #outline-panel { order: -10; }
    .outline-tabs { display: flex; border-bottom: 1px solid var(--border-color); }
    .outline-tab {
        flex: 1; padding: 8px; text-align: center; cursor: pointer;
        background: var(--pane-header-bg); border: none; font-size: 0.8rem;
        color: var(--text-muted); transition: all 0.2s;
    }
    .outline-tab:hover { background: var(--panel-bg); }
    .outline-tab.active { background: var(--panel-bg); color: var(--text-color); font-weight: bold; border-bottom: 2px solid #2563eb; }
    .outline-content { flex: 1; overflow: auto; padding: 10px; }
    .outline-tab-content { display: none; }
    .outline-tab-content.active { display: block; }
    .outline-item {
        padding: 6px 8px; border-bottom: 1px solid var(--border-color); cursor: pointer;
        color: var(--text-color); font-size: 0.85rem; display: flex; align-items: center;
        white-space: nowrap; min-width: 0; width: 100%;
    }
    .outline-item:hover { background: #e0f2fe; color: #0284c7; }
    body.theme-dark .outline-item:hover { background: #1e3a5f; }
    .outline-level-1 { font-weight: bold; background: var(--pane-header-bg); border-left: 4px solid #6b7280; }
    .outline-level-2 { padding-left: 20px; border-left: 3px solid #9ca3af; }
    .outline-level-3 { padding-left: 35px; border-left: 2px solid #d1d5db; font-size: 0.8rem; }
    .outline-toggle { cursor: pointer; margin-right: 6px; font-size: 0.7rem; width: 14px; text-align: center; color: var(--text-muted); flex-shrink: 0; }
    .outline-toggle:hover { color: #2563eb; }
    .outline-text { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .outline-tab-label { font-size: 0.7rem; color: var(--text-muted); margin-right: 6px; }
    .outline-char-count { margin-left: auto; font-size: 0.7rem; color: var(--text-muted); background: var(--pane-header-bg); padding: 1px 6px; border-radius: 10px; flex-shrink: 0; }
    .outline-empty { color: var(--text-muted); font-style: italic; }
    .outline-hidden { display: none !important; }
    .outline-summary { padding: 8px 10px; background: #f0f9ff; border-top: 1px solid var(--border-color); font-size: 0.75rem; color: #0369a1; }
    body.theme-dark .outline-summary { background: #1e3a5f; color: #93c5fd; }

    .bookmark-item { padding: 8px; border-bottom: 1px solid var(--border-color); cursor: pointer; display: flex; align-items: center; gap: 8px; font-size: 0.85rem; min-width: 0; width: 100%; }
    .bookmark-item:hover { background: #fef3c7; }
    .bookmark-text { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .panel-state-icon { font-size: 0.75rem; opacity: 0.7; margin-left: 4px; }
    .bookmark-delete { color: #dc2626; cursor: pointer; font-size: 0.8rem; }
    .bookmark-delete:hover { color: #b91c1c; }
    .bookmark-add-btn { width: 100%; padding: 8px; background: #fef3c7; border: 1px dashed #fcd34d; border-radius: 4px; cursor: pointer; font-size: 0.8rem; margin-bottom: 10px; }
    .bookmark-add-btn:hover { background: #fde68a; }
    #bookmark-list { overflow-x: auto; }

    .modal-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 1000;
        display: none; justify-content: center; align-items: center;
    }
    .modal-overlay.show { display: flex; }
    .modal-content {
        background: var(--panel-bg); border-radius: 8px; padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 600px; width: 90%;
        max-height: 80vh; overflow-y: auto; color: var(--text-color);
    }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; }
    .modal-header h3 { margin: 0; font-size: 1.2rem; }
    .modal-close { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-muted); }
    .modal-close:hover { color: #dc2626; }
    .analysis-section { margin-bottom: 20px; padding: 15px; background: var(--pane-header-bg); border-radius: 6px; }
    .analysis-section h4 { margin: 0 0 10px 0; font-size: 0.95rem; color: #2563eb; }
    .analysis-row { display: flex; justify-content: space-between; padding: 4px 0; border-bottom: 1px dotted var(--border-color); }
    .analysis-row:last-child { border-bottom: none; }
    .analysis-bar { height: 20px; background: #e5e7eb; border-radius: 10px; overflow: hidden; margin: 5px 0; }
    .analysis-bar-fill { height: 100%; border-radius: 10px; transition: width 0.3s; }
    .freq-list { display: flex; flex-wrap: wrap; gap: 8px; }
    .freq-item { background: #dbeafe; color: #1d4ed8; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; }
    .warning-text { color: #dc2626; font-size: 0.85rem; margin-top: 8px; }

    /* Heatmap styles */
    .heatmap-container { margin: 10px 0; }
    .heatmap-title { font-size: 0.85rem; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; }
    .heatmap-legend { font-size: 0.7rem; color: #666; }
    .heatmap-grid { display: flex; flex-wrap: wrap; gap: 2px; }
    .heatmap-cell { width: 20px; height: 20px; border-radius: 3px; cursor: pointer; position: relative; transition: transform 0.1s; }
    .heatmap-cell:hover { transform: scale(1.3); z-index: 10; }
    .heatmap-cell[data-tooltip]:hover::after { content: attr(data-tooltip); position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); background: #333; color: #fff; padding: 3px 6px; border-radius: 3px; font-size: 0.7rem; white-space: nowrap; z-index: 100; }
    .heatmap-tabs { display: flex; gap: 5px; margin-bottom: 10px; flex-wrap: wrap; }
    .heatmap-tab { padding: 5px 10px; border: 1px solid var(--border-color); border-radius: 4px; cursor: pointer; font-size: 0.8rem; background: var(--bg-color); }
    .heatmap-tab.active { background: #3b82f6; color: #fff; border-color: #3b82f6; }

    .jump-dialog {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: var(--panel-bg); border: 1px solid var(--border-color);
        border-radius: 8px; padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        z-index: 1001; display: none;
    }
    .jump-dialog.show { display: block; }
    .jump-dialog h4 { margin: 0 0 15px 0; }
    .jump-dialog input { width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; font-size: 1rem; margin-bottom: 10px; }
    .jump-dialog-buttons { display: flex; gap: 10px; justify-content: flex-end; }

    /* Celebration Fireworks */
    .celebration-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        pointer-events: none; z-index: 9998; overflow: hidden;
    }
    .celebration-message {
        position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white; padding: 20px 40px; border-radius: 16px;
        font-size: 1.5rem; font-weight: bold; text-align: center;
        box-shadow: 0 10px 40px rgba(102, 126, 234, 0.5);
        z-index: 9999; animation: celebrationPop 0.5s ease-out;
        display: none;
    }
    .celebration-message.show { display: block; }
    .celebration-message .emoji { font-size: 2rem; display: block; margin-bottom: 10px; }
    .celebration-message .sub { font-size: 0.9rem; font-weight: normal; margin-top: 8px; opacity: 0.9; }
    @keyframes celebrationPop {
        0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .firework {
        position: absolute; width: 6px; height: 6px; border-radius: 50%;
        animation: fireworkBurst 1.5s ease-out forwards;
    }
    @keyframes fireworkBurst {
        0% { transform: translate(0, 0) scale(1); opacity: 1; }
        100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }
    .firework-trail {
        position: absolute; width: 4px; height: 4px; border-radius: 50%;
        animation: fireworkTrail 0.8s ease-out forwards;
    }
    @keyframes fireworkTrail {
        0% { transform: translateY(0); opacity: 1; }
        100% { transform: translateY(var(--rise)); opacity: 0; }
    }

    .save-dialog-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.5); z-index: 1000;
        display: flex; justify-content: center; align-items: center;
    }
    .save-dialog {
        background: var(--panel-bg); border-radius: 8px; padding: 20px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.3); min-width: 300px;
    }
    .save-dialog h3 { margin: 0 0 15px 0; color: var(--text-color); }
    .save-dialog-buttons { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
    .save-dialog-buttons button { padding: 10px 20px; font-size: 1rem; }

    .autosave-toast {
        position: fixed; top: 16px; right: 16px; z-index: 1200;
        background: #fef9c3; color: #92400e; border: 1px solid #fcd34d;
        padding: 8px 14px; border-radius: 12px; font-weight: bold;
        box-shadow: 0 6px 16px rgba(0,0,0,0.15); display: none;
    }
    .autosave-toast.show { display: block; }
    .autosave-error-overlay {
        position: fixed; inset: 0; background: rgba(0,0,0,0.35);
        display: none; align-items: center; justify-content: center; z-index: 1300;
    }
    .autosave-error-overlay.show { display: flex; }
    .autosave-error {
        background: var(--panel-bg); border: 2px solid #fca5a5;
        padding: 20px 26px; border-radius: 14px; text-align: center;
        font-weight: bold; color: #b91c1c; box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    }
    .autosave-error button {
        margin-top: 12px; background: #fee2e2; border: 1px solid #fecaca;
        color: #991b1b; padding: 6px 14px; border-radius: 8px; cursor: pointer;
    }

    

    .btn-view { background: #ecfeff; color: #0e7490; border-color: #a5f3fc; font-weight: bold; }
    .btn-view:hover { background: #cffafe; }

    /* Reader (All Tabs) Fullscreen */
    #reader-overlay {
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: var(--bg-color);
        z-index: 5000;
        display: none;
        flex-direction: column;
    }
    #reader-overlay.show { display: flex; }
    #reader-header {
        display: flex; align-items: center; justify-content: space-between;
        padding: 10px 12px;
        background: var(--pane-header-bg);
        border-bottom: 1px solid var(--border-color);
        gap: 10px;
    }
    #reader-title { font-weight: bold; font-size: 0.95rem; display:flex; align-items:center; gap:8px; }
    #reader-controls { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; }
    #reader-scroll {
        flex: 1;
        overflow: auto;
        padding: 14px 16px;
        background: var(--preview-bg);
    }
    #reader-scroll.vertical-mode #reader-content {
        writing-mode: vertical-rl;
        text-orientation: upright;
        min-height: 100%;
        width: max-content;
        max-width: none;
    }
    #reader-content {
        word-wrap: break-word;
        overflow-wrap: break-word;
        word-break: break-word;
        color: var(--text-color);
        max-width: 100%;
        min-width: 0;
        box-sizing: border-box;
        line-height: 1.85;
        font-size: 16px;
    }
    .reader-section { margin-bottom: 18px; }
    .reader-marker {
        display: inline-block;
        padding: 6px 10px;
        margin: 0 0 10px 0;
        border-radius: 10px;
        border: 1px solid var(--border-color);
        background: #f0f9ff;
        font-weight: bold;
        color: #0369a1;
    }
    body.theme-dark .reader-marker { background: #0b2a3a; color: #7dd3fc; }
    .reader-hint { font-size: 0.8rem; color: var(--text-muted); }

@media print {
        header, .controls-wrapper, .pane-subheader, .pane-footer, #outline-panel, #pane-input, .selection-overlay { display: none !important; }
        body, body.scroll-mode { height: auto; overflow: visible; background: white; }
        .main-container { padding: 0; display: block; }
        .pane-stack { display: block; }
        .pane { border: none; box-shadow: none; height: auto !important; }
        #pane-preview { display: block !important; }
        #pane-preview .pane-header { display: none; }
        #pane-preview .pane-body { overflow: visible; }
        #preview-scroll { padding: 0; height: auto; overflow: visible; }
        #preview-content { font-size: 10.5pt; line-height: 1.8; }
        .vertical-mode #preview-content { writing-mode: horizontal-tb; }
    }

    .input-tab .tab-meta { font-size: 0.70rem; opacity: .85; margin-left: 6px; white-space: nowrap; }
    .input-tab .tab-meta.positive { opacity: 1; font-weight: 700; }

    .search-hits { margin-top: 8px; max-height: 220px; overflow: auto; border: 1px solid var(--border-color); border-radius: 10px; background: var(--panel-bg); padding: 6px; }
    .search-hit { padding: 6px 8px; border-radius: 8px; cursor: pointer; font-size: 0.85rem; }
    .search-hit:hover { background: rgba(59,130,246,.10); }
    .search-hit code { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 0.82rem; }

    #tab-context-menu { position: fixed; z-index: 9999; display: none; min-width: 180px; background: var(--panel-bg); color: var(--text-color);
        border: 1px solid var(--border-color); border-radius: 12px; box-shadow: 0 10px 24px rgba(0,0,0,.18); padding: 6px; }
    #tab-context-menu button { width: 100%; text-align: left; padding: 8px 10px; border: none; border-radius: 10px; background: transparent; color: inherit; cursor: pointer; }
    #tab-context-menu button:hover { background: rgba(59,130,246,.10); }
    #tab-context-menu hr { border: none; border-top: 1px solid var(--border-color); margin: 6px 0; }

    #ruby-modal { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10000; background: rgba(0,0,0,.35); }
    #ruby-modal .ruby-box { width: min(520px, 92vw); background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color);
        border-radius: 14px; box-shadow: 0 12px 26px rgba(0,0,0,.22); padding: 14px; }
    #ruby-modal .ruby-header { display:flex; align-items:center; justify-content: space-between; gap: 8px; margin-bottom: 10px; }
    #ruby-modal .ruby-header h3 { margin: 0; font-size: 1rem; }
    #ruby-modal .ruby-close { width: 32px; height: 32px; border-radius: 10px; border: 1px solid var(--border-color); background: transparent; cursor: pointer; }
    #ruby-modal .ruby-close:hover { background: rgba(239,68,68,.12); border-color: rgba(239,68,68,.35); }
    #ruby-modal .ruby-target { font-size: .9rem; color: var(--text-muted); margin-bottom: 8px; }
    #ruby-modal input { width: 100%; padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border-color); background: var(--pane-header-bg); color: var(--text-color); }
    #ruby-modal .ruby-actions { display:flex; justify-content:flex-end; gap: 8px; margin-top: 10px; }

    #focus-overlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10001; background: rgba(0,0,0,.45); }
    #focus-overlay .focus-box { width: min(980px, 96vw); background: var(--panel-bg); color: var(--text-color); border: 1px solid var(--border-color);
        border-radius: 16px; box-shadow: 0 14px 28px rgba(0,0,0,.25); padding: 14px; }
    #focus-overlay .focus-header { display:flex; align-items:center; justify-content: space-between; gap: 10px; margin-bottom: 10px; }
    #focus-overlay .focus-header h3 { margin:0; font-size: 1rem; }
    #focus-overlay .focus-body { max-height: 76vh; overflow: auto; border: 1px solid var(--border-color); border-radius: 12px; background: var(--preview-bg-color); padding: 10px; }


/* ===== v0.98 nav unified tabs (outline/search/proof/memo) ===== */
#outline-tab-search #search-bar{ position:static; box-shadow:none; margin:0; }
#outline-tab-memo #memo-panel{ position:static; width:100%; height:100%; max-height:none; transform:none; box-shadow:none; border:none; }
#outline-tab-memo #memo-panel .memo-header{ display:none !important; }
#outline-tab-memo #memo-panel .panel-close-btn{ display:none !important; }
#outline-tab-memo #memo-panel .panel-pin-btn,
#outline-tab-memo #memo-panel .dock-pin-checkbox,
#outline-tab-memo #memo-panel .panel-swap-btn{ display:none !important; }
.proofread-embedded{ background:transparent; }
.proofread-embedded #proofread-results{ max-height: 55vh; overflow:auto; }

    /* Nav jump history buttons */
    .nav-jump-controls{display:flex;gap:4px;align-items:center;}
    .nav-jump-btn{height:26px;min-width:26px;padding:0 6px;border:1px solid var(--border-color);background:var(--panel-bg);color:var(--text-color);border-radius:8px;cursor:pointer;font-size:12px;line-height:1;}
    .nav-jump-btn:disabled{opacity:.4;cursor:not-allowed;}

    /* Jump flash */
    @keyframes ccJumpFlash{0%{box-shadow:0 0 0 0 rgba(250,204,21,0);}20%{box-shadow:0 0 0 6px rgba(250,204,21,.65);}100%{box-shadow:0 0 0 0 rgba(250,204,21,0);}}
    .cc-jump-flash{animation:ccJumpFlash .8s ease;}

    /* Sync mode menu */
    #sync-menu{position:fixed;z-index:9999;display:none;min-width:180px;background:var(--panel-bg);border:1px solid var(--border-color);border-radius:12px;box-shadow:0 12px 30px rgba(0,0,0,.18);overflow:hidden;}
    #sync-menu button{width:100%;text-align:left;padding:10px 12px;border:none;background:transparent;color:var(--text-color);cursor:pointer;font-size:14px;}
    #sync-menu button:hover{background:rgba(59,130,246,.08);}
    #sync-menu .sync-menu-note{padding:8px 12px;font-size:12px;color:var(--text-muted);border-top:1px solid var(--border-color);}

    /* Proof ignore modal */
    #proof-ignore-overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.35);z-index:9999;}
    #proof-ignore-modal{width:min(720px,92vw);max-height:82vh;overflow:auto;background:var(--panel-bg);border:1px solid var(--border-color);border-radius:16px;box-shadow:0 16px 50px rgba(0,0,0,.25);padding:14px;}
    #proof-ignore-modal h3{margin:0 0 10px;font-size:16px;}
    .proof-ignore-row{display:flex;gap:8px;align-items:center;border-bottom:1px solid var(--border-color);padding:8px 0;}
    .proof-ignore-row .msg{flex:1;font-size:13px;line-height:1.4;}
    .proof-ignore-row button{border:1px solid var(--border-color);background:transparent;color:var(--text-color);border-radius:10px;padding:6px 10px;cursor:pointer;}
    .proof-ignore-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:10px;}

</style>

<!-- ===== v0.96 hotfix (reader/search/bookmark, active tab color, tab context menu, per-tab stats, focus shortcuts) ===== -->
<style>
  /* アクティブタブ色を入力/プレビュー/メモで統一（設定色を反映） */
  .memo-tab.active,
  .preview-tab.active,
  .pv-tab.active {
    background: var(--active-tab-bg) !important;
    color: var(--active-tab-text) !important;
    font-weight: bold !important;
    border-top: 2px solid var(--active-tab-border) !important;
  }

  /* タブの字数表示 */
  .tab-meta {
    margin-left: 8px;
    font-size: 0.75rem;
    opacity: 0.85;
    white-space: nowrap;
  }
  .tab-meta .today {
    margin-left: 6px;
    font-weight: 600;
  }

  /* 集中モードの一時表示（オーバーレイ） */
  #focus-overlay {
    position: fixed;
    inset: 0;
    z-index: 99999;
    background: rgba(0,0,0,0.55);
    display: none;
    align-items: center;
    justify-content: center;
  }
  #focus-overlay.show { display: flex; }
  #focus-overlay .fo-box {
    width: min(1100px, calc(100vw - 24px));
    height: min(85vh, calc(100vh - 24px));
    background: var(--panel-bg);
    border: 1px solid var(--border-color);
    border-radius: 14px;
    overflow: hidden;
    box-shadow: 0 20px 60px rgba(0,0,0,0.35);
    display: flex;
    flex-direction: column;
  }
  #focus-overlay .fo-head {
    display:flex;
    align-items:center;
    justify-content: space-between;
    padding: 10px 12px;
    background: var(--header-bg);
    border-bottom: 1px solid var(--border-color);
    gap: 10px;
  }
  #focus-overlay .fo-title { font-weight: 700; }
  #focus-overlay .fo-body {
    flex: 1;
    overflow: auto;
    padding: 12px;
    background: var(--panel-bg);
    color: var(--text-color);
  }
  #focus-overlay .fo-body.vertical-mode { writing-mode: vertical-rl; }
  #focus-overlay pre {
    white-space: pre-wrap;
    word-break: break-word;
    margin: 0;
    font: inherit;
  }

  /* 閲覧検索ハイライト */
  mark.reader-hit {
    padding: 0 2px;
    border-radius: 4px;
    background: rgba(255, 230, 0, 0.55);
  }
  mark.reader-hit.active {
    outline: 2px solid rgba(255, 140, 0, 0.9);
    background: rgba(255, 200, 0, 0.85);
  }
</style>

<script>
// ===== v0.96 hotfix JS =====
(function(){
  'use strict';

  // -----------------------------
  // 0) 安全ユーティリティ
  // -----------------------------
  function clamp(n, min, max){ return Math.min(Math.max(n, min), max); }
  function parseTimeToMinutes(hhmm){
    if (!hhmm || typeof hhmm !== 'string') return 0;
    const m = hhmm.trim().match(/^(\d{1,2}):(\d{2})$/);
    if (!m) return 0;
    const h = clamp(parseInt(m[1],10)||0, 0, 23);
    const mi = clamp(parseInt(m[2],10)||0, 0, 59);
    return h*60 + mi;
  }
  function shadeHex(hex, percent){
    // percent: -1..1 (negative darker)
    if (!hex) return '#fff59d';
    const m = hex.trim().match(/^#?([0-9a-fA-F]{6})$/);
    if (!m) return hex;
    const n = parseInt(m[1],16);
    let r = (n>>16)&255, g=(n>>8)&255, b=n&255;
    const t = percent<0 ? 0 : 255;
    const p = Math.abs(percent);
    r = Math.round((t-r)*p + r);
    g = Math.round((t-g)*p + g);
    b = Math.round((t-b)*p + b);
    return '#' + ((1<<24) + (r<<16) + (g<<8) + b).toString(16).slice(1);
  }

  // -----------------------------
  // 1) 「今日」開始時刻を反映：getTodayDateStrを論理日付に置換
  // -----------------------------
  const DAY_START_LS_KEY = 'cc_day_start_hhmm';
  function getDayStartHHMM(){
    const el = document.getElementById('st-day-start');
    const v = (el && el.value) ? el.value : (localStorage.getItem(DAY_START_LS_KEY) || '00:00');
    return v || '00:00';
  }
  function saveDayStartHHMM(v){
    if (!v) return;
    localStorage.setItem(DAY_START_LS_KEY, v);
  }

  // 既存関数を上書き（以後の「今日」計算はこの論理日付を使う）
  window.getTodayDateStr = function(){
    const now = new Date();
    const offsetMin = parseTimeToMinutes(getDayStartHHMM());
    const adj = new Date(now.getTime() - offsetMin*60*1000);
    const y = adj.getFullYear();
    const m = String(adj.getMonth()+1).padStart(2,'0');
    const d = String(adj.getDate()).padStart(2,'0');
    return `${y}-${m}-${d}`;
  };

  // UIから変更 → 保存＆再計算
  function hookDayStartUI(){
    const el = document.getElementById('st-day-start');
    if (!el) return;
    // ローカル保存値を優先して反映
    const saved = localStorage.getItem(DAY_START_LS_KEY);
    if (saved && !el.value) el.value = saved;
    if (saved && el.value !== saved) el.value = saved;
    el.addEventListener('change', () => {
      saveDayStartHHMM(el.value || '00:00');
      // 「今日」基準が変わるので、今日開始文字数を再読込して表示更新
      try { loadTodayStart(); } catch(e) {}
      try { updateInputStats(); } catch(e) {}
      try { updatePreview(); } catch(e) {}
      try { updateTabMetaLabels(); } catch(e) {}
    });
  }

  // -----------------------------
  // 2) アクティブタブ色設定
  // -----------------------------
  const ACTIVE_TAB_COLOR_KEY = 'cc_active_tab_color';
  function applyActiveTabColor(hex){
    const root = document.documentElement;
    const bg = hex || '#fff59d';
    root.style.setProperty('--active-tab-bg', bg);
    root.style.setProperty('--active-tab-border', shadeHex(bg, -0.35));
    root.style.setProperty('--active-tab-text', 'var(--text-color)');
  }
  function hookActiveTabColorUI(){
    const el = document.getElementById('st-active-tab-color');
    if (!el) return;
    const saved = localStorage.getItem(ACTIVE_TAB_COLOR_KEY);
    if (saved) {
      el.value = saved;
      applyActiveTabColor(saved);
    } else {
      applyActiveTabColor(el.value);
    }
    el.addEventListener('input', () => {
      applyActiveTabColor(el.value);
    });
    el.addEventListener('change', () => {
      localStorage.setItem(ACTIVE_TAB_COLOR_KEY, el.value);
      try { if (typeof saveSettingsToStorage==='function') saveSettingsToStorage(); } catch(e) {}
    });
  }

  // -----------------------------
  // 3) 閲覧（Reader）：検索＆しおりを実装
  // -----------------------------
  let readerMatches = [];
  let readerMatchIndex = -1;
  const READER_BM_KEY = 'cc_reader_bookmarks_v1';
  let readerBookmarks = [];

  function readerGetEls(){
    return {
      overlay: document.getElementById('reader-overlay'),
      scroll: document.getElementById('reader-scroll'),
      content: document.getElementById('reader-content'),
      input: document.getElementById('reader-search-input'),
      info: document.getElementById('reader-search-info'),
      select: document.getElementById('reader-bookmark-select')
    };
  }

  function clearReaderHighlights(){
    const {content, info} = readerGetEls();
    if (!content) return;
    // unwrap marks
    content.querySelectorAll('mark.reader-hit').forEach(m => {
      const parent = m.parentNode;
      while (m.firstChild) parent.insertBefore(m.firstChild, m);
      parent.removeChild(m);
      parent.normalize();
    });
    readerMatches = [];
    readerMatchIndex = -1;
    if (info) info.textContent = '0/0';
  }

  function highlightReaderQuery(q){
    const {content} = readerGetEls();
    if (!content) return;
    if (!q) return;
    const query = q;
    const walker = document.createTreeWalker(content, NodeFilter.SHOW_TEXT, {
      acceptNode(node){
        if (!node.nodeValue) return NodeFilter.FILTER_REJECT;
        const p = node.parentNode;
        if (!p) return NodeFilter.FILTER_REJECT;
        if (p.closest && p.closest('script, style')) return NodeFilter.FILTER_REJECT;
        return node.nodeValue.includes(query) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
    });

    const nodes = [];
    while (walker.nextNode()) nodes.push(walker.currentNode);

    nodes.forEach(node => {
      const text = node.nodeValue;
      let idx = text.indexOf(query);
      if (idx === -1) return;
      const frag = document.createDocumentFragment();
      let last = 0;
      while (idx !== -1) {
        if (idx > last) frag.appendChild(document.createTextNode(text.slice(last, idx)));
        const mark = document.createElement('mark');
        mark.className = 'reader-hit';
        mark.textContent = text.slice(idx, idx + query.length);
        frag.appendChild(mark);
        readerMatches.push(mark);
        last = idx + query.length;
        idx = text.indexOf(query, last);
      }
      if (last < text.length) frag.appendChild(document.createTextNode(text.slice(last)));
      node.parentNode.replaceChild(frag, node);
    });
  }

  function setReaderActiveHit(i){
    const {scroll, info} = readerGetEls();
    if (!scroll) return;
    readerMatches.forEach(m => m.classList.remove('active'));
    if (readerMatches.length === 0) {
      readerMatchIndex = -1;
      if (info) info.textContent = '0/0';
      return;
    }
    readerMatchIndex = ((i % readerMatches.length) + readerMatches.length) % readerMatches.length;
    const el = readerMatches[readerMatchIndex];
    el.classList.add('active');
    el.scrollIntoView({block:'center', inline:'center'});
    if (info) info.textContent = `${readerMatchIndex+1}/${readerMatches.length}`;
  }

  window.readerDoSearch = function(){
    const {input} = readerGetEls();
    const q = (input?.value || '').trim();
    clearReaderHighlights();
    if (!q) return;
    highlightReaderQuery(q);
    setReaderActiveHit(0);
  };
  window.readerFindNext = function(){
    if (readerMatches.length === 0) { window.readerDoSearch(); return; }
    setReaderActiveHit(readerMatchIndex + 1);
  };
  window.readerFindPrev = function(){
    if (readerMatches.length === 0) { window.readerDoSearch(); return; }
    setReaderActiveHit(readerMatchIndex - 1);
  };

  function loadReaderBookmarks(){
    try {
      const s = localStorage.getItem(READER_BM_KEY);
      readerBookmarks = s ? JSON.parse(s) : [];
      if (!Array.isArray(readerBookmarks)) readerBookmarks = [];
    } catch(e){ readerBookmarks = []; }
  }
  function saveReaderBookmarks(){
    try { localStorage.setItem(READER_BM_KEY, JSON.stringify(readerBookmarks)); } catch(e) {}
  }
  function renderReaderBookmarks(){
    const {select} = readerGetEls();
    if (!select) return;
    select.innerHTML = '<option value="">🔖 しおり</option>';
    readerBookmarks.forEach((b, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = b.label;
      select.appendChild(opt);
    });
  }

  window.readerAddBookmark = function(){
    const {scroll} = readerGetEls();
    if (!scroll) return;
    const y = scroll.scrollTop;
    const x = scroll.scrollLeft;
    const label = `しおり ${readerBookmarks.length+1}（${Math.round(y)}px）`;
    readerBookmarks.push({top:y, left:x, label, created: Date.now()});
    saveReaderBookmarks();
    renderReaderBookmarks();
    const {select} = readerGetEls();
    if (select) select.value = String(readerBookmarks.length-1);
  };
  window.readerJumpBookmark = function(){
    const {select, scroll} = readerGetEls();
    if (!select || !scroll) return;
    const idx = parseInt(select.value, 10);
    if (Number.isNaN(idx)) return;
    const b = readerBookmarks[idx];
    if (!b) return;
    scroll.scrollTop = b.top;
    scroll.scrollLeft = b.left;
  };

  // openReaderView / closeReaderView をフック：検索ハイライト初期化＆しおり反映
  function wrapReaderViewFunctions(){
    if (typeof window.openReaderView === 'function' && !window.openReaderView.__hotfixWrapped) {
      const base = window.openReaderView;
      const wrapped = function(){
        try { clearReaderHighlights(); } catch(e) {}
        loadReaderBookmarks();
        renderReaderBookmarks();
        return base.apply(this, arguments);
      };
      wrapped.__hotfixWrapped = true;
      window.openReaderView = wrapped;
    }
    if (typeof window.closeReaderView === 'function' && !window.closeReaderView.__hotfixWrapped) {
      const base = window.closeReaderView;
      const wrapped = function(){
        try { clearReaderHighlights(); } catch(e) {}
        return base.apply(this, arguments);
      };
      wrapped.__hotfixWrapped = true;
      window.closeReaderView = wrapped;
    }
  }

  // -----------------------------
  // 4) タブ右クリックメニュー
  // -----------------------------
  let ctxTabId = null;
  function hideCtx(){
    const m = document.getElementById('tab-context-menu');
    if (!m) return;
    m.style.display = 'none';
    m.setAttribute('aria-hidden','true');
    ctxTabId = null;
  }
  function showCtx(tabId, x, y){
    const m = document.getElementById('tab-context-menu');
    if (!m) return;
    ctxTabId = tabId;
    m.style.display = 'block';
    m.setAttribute('aria-hidden','false');
    const w = m.offsetWidth || 180;
    const h = m.offsetHeight || 140;
    const left = clamp(x, 8, window.innerWidth - w - 8);
    const top  = clamp(y, 8, window.innerHeight - h - 8);
    m.style.left = left + 'px';
    m.style.top  = top + 'px';
  }

  // ctx action functions
  window.ctxRenameTab = function(){
    if (ctxTabId == null) return;
    hideCtx();
    try { startEditTabName(ctxTabId); } catch(e) {}
  };
  window.ctxDuplicateTab = function(){
    if (ctxTabId == null) return;
    hideCtx();
    try {
      const t = inputTabs.find(tt => tt.id === ctxTabId);
      if (!t) return;
      // active tab content flush
      const cur = inputTabs.find(tt => tt.id === activeTabId);
      if (cur) cur.content = inputArea.value;
      const copy = { id: nextTabId++, name: (t.name || 'タブ') + '（複製）', content: t.content || '' };
      const idx = inputTabs.findIndex(tt => tt.id === ctxTabId);
      inputTabs.splice(idx+1, 0, copy);
      activeTabId = copy.id;
      inputArea.value = copy.content;
      renderInputTabs();
      updateInputStats();
      saveTabsToStorage();
    } catch(e) {}
  };
  window.ctxNewTab = function(){ hideCtx(); try { addNewTab(); } catch(e) {} };
  window.ctxCloseTab = function(){
    if (ctxTabId == null) return;
    const id = ctxTabId;
    hideCtx();
    try { deleteTab(id); } catch(e) {}
  };

  // renderInputTabs を上書き：右クリック＋タブ字数表示（本体JSの定義後にフック）
  function wrapRenderInputTabs(){
    if (typeof window.renderInputTabs !== 'function' || window.renderInputTabs.__hotfixWrapped) return;
    const base = window.renderInputTabs;
    const wrapped = function(){
      const r = base.apply(this, arguments);
      // 既存renderが作ったDOMに対して後付けで右クリックと字数表示を付与
      const container = document.getElementById('input-tabs-container');
      if (container) {
        container.querySelectorAll('.input-tab').forEach(tabEl => {
          // 二重バインド防止
          if (tabEl.__ctxBound) return;
          tabEl.__ctxBound = true;
          const id = parseInt(tabEl.dataset.tabId, 10);
          if (!Number.isNaN(id)) {
            tabEl.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              e.stopPropagation();
              showCtx(id, e.clientX, e.clientY);
            });
          }
        });
      }
      try { updateTabMetaLabels(); } catch(e) {}
      return r;
    };
    wrapped.__hotfixWrapped = true;
    window.renderInputTabs = wrapped;
  }

  // クリック外で閉じる
  document.addEventListener('pointerdown', (e) => {
    const m = document.getElementById('tab-context-menu');
    if (!m || m.style.display !== 'block') return;
    if (m.contains(e.target)) return;
    hideCtx();
  });
  window.addEventListener('scroll', hideCtx, true);
  window.addEventListener('resize', hideCtx);

  // -----------------------------
  // 5) タブごとの字数（＋今日増分）
  // -----------------------------
  const TAB_DAY_BASE_KEY = 'cc_tab_day_baselines_v1';
  let tabDayBaselines = { date: null, base: {} };

  function normalizedLen(text){
    return String(text || '').replace(/[\n\r\s　]/g,'').length;
  }
  function loadTabBaselines(){
    try {
      const s = localStorage.getItem(TAB_DAY_BASE_KEY);
      tabDayBaselines = s ? JSON.parse(s) : {date:null, base:{}};
      if (!tabDayBaselines || typeof tabDayBaselines !== 'object') tabDayBaselines = {date:null, base:{}};
      if (!tabDayBaselines.base || typeof tabDayBaselines.base !== 'object') tabDayBaselines.base = {};
    } catch(e){ tabDayBaselines = {date:null, base:{}}; }
  }
  function saveTabBaselines(){
    try { localStorage.setItem(TAB_DAY_BASE_KEY, JSON.stringify(tabDayBaselines)); } catch(e) {}
  }
  function ensureTabBaselinesForToday(){
    const today = window.getTodayDateStr();
    if (tabDayBaselines.date !== today) {
      tabDayBaselines = { date: today, base: {} };
    }
    // base未登録は現在値を採用
    inputTabs.forEach(t => {
      const key = String(t.id);
      if (tabDayBaselines.base[key] == null) {
        tabDayBaselines.base[key] = normalizedLen(t.content || '');
      }
    });
    saveTabBaselines();
  }

  window.updateTabMetaLabels = function(){
    try {
      // activeタブの内容を退避
      const cur = inputTabs.find(t => t.id === activeTabId);
      if (cur) cur.content = inputArea.value;
    } catch(e) {}

    loadTabBaselines();
    ensureTabBaselinesForToday();

    const container = document.getElementById('input-tabs-container');
    if (!container) return;
    container.querySelectorAll('.input-tab').forEach(tabEl => {
      const id = parseInt(tabEl.dataset.tabId,10);
      if (Number.isNaN(id)) return;
      const t = inputTabs.find(tt => tt.id === id);
      if (!t) return;
      const len = normalizedLen(t.content || '');
      const base = tabDayBaselines.base[String(id)] ?? len;
      const delta = Math.max(0, len - base);

      let meta = tabEl.querySelector('.tab-meta');
      if (!meta) {
        meta = document.createElement('span');
        meta.className = 'tab-meta';
        tabEl.querySelector('.tab-name')?.after(meta);
      }
      meta.innerHTML = `${len}字<span class="today">+${delta}</span>`;
    });
  };

  // 入力のたびにメタだけ更新（重い再描画はしない）
  function wrapUpdateInputStats(){
    if (typeof window.updateInputStats !== 'function' || window.updateInputStats.__hotfixWrapped) return;
    const base = window.updateInputStats;
    const wrapped = function(){
      const r = base.apply(this, arguments);
      try { updateTabMetaLabels(); } catch(e) {}
      return r;
    };
    wrapped.__hotfixWrapped = true;
    window.updateInputStats = wrapped;
  }

  // -----------------------------
  // 6) 集中モード中のショートカット（Ctrl+Shift+P/M/O）
  // -----------------------------
  function ensureFocusOverlay(){
    let ov = document.getElementById('focus-overlay');
    if (ov) return ov;
    ov = document.createElement('div');
    ov.id = 'focus-overlay';
    ov.innerHTML = `
      <div class="fo-box" role="dialog" aria-label="集中モード一時表示">
        <div class="fo-head">
          <div class="fo-title" id="fo-title">一時表示</div>
          <div style="display:flex; gap:8px; align-items:center;">
            <span style="font-size:0.85rem; opacity:0.8;">Escで閉じる</span>
            <button class="btn" id="fo-close" type="button">✕</button>
          </div>
        </div>
        <div class="fo-body" id="fo-body"></div>
      </div>
    `;
    document.body.appendChild(ov);
    ov.addEventListener('pointerdown', (e) => {
      if (e.target === ov) closeFocusOverlay();
    });
    ov.querySelector('#fo-close')?.addEventListener('click', closeFocusOverlay);
    return ov;
  }
  function openFocusOverlay(kind){
    const ov = ensureFocusOverlay();
    const titleEl = ov.querySelector('#fo-title');
    const bodyEl = ov.querySelector('#fo-body');
    if (!bodyEl || !titleEl) return;

    // reset
    bodyEl.classList.remove('vertical-mode');
    bodyEl.innerHTML = '';

    if (kind === 'preview') {
      titleEl.textContent = '🪞 プレビュー（一時表示）';
      try { if (typeof updatePreview === 'function') updatePreview(); } catch(e) {}
      // previewScroll が縦書きなら同様に
      const pvScroll = document.getElementById('preview-scroll');
      const pvContent = document.getElementById('preview-content');
      const wrap = document.createElement('div');
      wrap.innerHTML = pvContent ? pvContent.innerHTML : '';
      bodyEl.appendChild(wrap);
      if (pvScroll && pvScroll.classList.contains('vertical-mode')) bodyEl.classList.add('vertical-mode');
    } else if (kind === 'memo') {
      titleEl.textContent = '🗒 メモ（一時表示）';
      const memoArea = document.getElementById('memo-area');
      const pre = document.createElement('pre');
      pre.textContent = memoArea ? memoArea.value : '';
      bodyEl.appendChild(pre);
    } else if (kind === 'outline') {
      titleEl.textContent = '📑 目次（一時表示）';
      const outline = document.getElementById('outline-list');
      const div = document.createElement('div');
      div.innerHTML = outline ? outline.innerHTML : '<div style="opacity:0.7;">目次がありません</div>';
      bodyEl.appendChild(div);
    }

    ov.classList.add('show');
  }
  function closeFocusOverlay(){
    const ov = document.getElementById('focus-overlay');
    if (!ov) return;
    ov.classList.remove('show');
  }
  // Escで閉じる（Reader優先）
  document.addEventListener('keydown', (e) => {
    const ov = document.getElementById('focus-overlay');
    if (ov && ov.classList.contains('show') && e.key === 'Escape') {
      e.preventDefault();
      closeFocusOverlay();
    }
  });

  // 既存のキー処理に追加（重複しても安全にする）
  document.addEventListener('keydown', (e) => {
    if (!document.body.classList.contains('focus-mode')) return;
    if (!e.ctrlKey || !e.shiftKey) return;
    const k = e.key;
    if (k === 'P' || k === 'p') { e.preventDefault(); openFocusOverlay('preview'); }
    if (k === 'M' || k === 'm') { e.preventDefault(); openFocusOverlay('memo'); }
    if (k === 'O' || k === 'o') { e.preventDefault(); openFocusOverlay('outline'); }
  }, true);

  // -----------------------------
  // 7) ルビモーダル：存在してもエラーにならないよう最低限だけ（現状仕様は維持）
  // -----------------------------
  window.closeRubyModal = window.closeRubyModal || function(){
    const m = document.getElementById('ruby-modal');
    if (!m) return;
    m.classList.remove('show');
    m.setAttribute('aria-hidden','true');
  };
  window.confirmRubyModal = window.confirmRubyModal || function(){
    // 現状はモーダル運用していないため、誤って開いてもキャンセル扱い
    window.closeRubyModal();
  };

  // -----------------------------
  // 8) 初期化：起動時にフックを有効化
  // -----------------------------
  function initHotfix(){
    hookDayStartUI();
    hookActiveTabColorUI();
    wrapReaderViewFunctions();
    wrapRenderInputTabs();
    wrapUpdateInputStats();
    // 既に描画済みのタブへ右クリック/字数表示を反映させるため、1度だけ再描画
    try { if (typeof window.renderInputTabs === 'function') window.renderInputTabs(); } catch(e) {}
    loadTabBaselines();
    ensureTabBaselinesForToday();
    try { updateTabMetaLabels(); } catch(e) {}
    loadReaderBookmarks();
    renderReaderBookmarks();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initHotfix);
  } else {
    initHotfix();
  }
})();
</script>
</head>
<body>

<header>
    <div class="header-left">
        <h1>ⓒエディタver.0.95</h1>
        <button class="btn btn-undo" onclick="undoInput()" title="元に戻す">↩</button>
        <button class="btn btn-undo" onclick="redoInput()" title="やり直し">↪</button>
        <button class="btn panel-toggle" id="btn-toggle-help" onclick="togglePanel('help-bar')" data-label="❓ 使い方">
            <span class="panel-label">❓ 使い方</span><span class="panel-state-icon">▾</span>
        </button>
        <button class="btn panel-toggle" id="btn-toggle-search" onclick="openNavTab('search')" data-label="🔍 検索">
            <span class="panel-label">🔍 検索</span><span class="panel-state-icon">▾</span>
        </button>
        <button class="btn panel-toggle" id="btn-toggle-settings" onclick="togglePanel('settings-bar')" data-label="⚙️ 設定">
            <span class="panel-label">⚙️ 設定</span><span class="panel-state-icon">▾</span>
        </button>
        <div class="dropdown">
            <button class="btn dropdown-btn" onclick="toggleDropdown('insert-dropdown')">📝 挿入</button>
            <div id="insert-dropdown" class="dropdown-content">
                <button onclick="insertText('――')">―― ダッシュ</button>
                <button onclick="insertText('……')">…… 三点リーダー</button>
                <button onclick="insertText('「」', 1)">「」 鉤括弧</button>
                <button onclick="insertText('『』', 1)">『』 二重鉤括弧</button>
                <button onclick="insertText('｜《》', 1)">｜《》 ルビ記法</button>
                <button onclick="insertText('《《》》', 2)">《《》》 傍点記法</button>
                <button onclick="insertText('__下線__', 2)">__下線__ 下線</button>
                <button onclick="insertText('==強調==', 2)">==強調== 強調表示</button>
                <button onclick="insertRubyToSelection()">🈂️ 選択文字にルビ</button>
                <button onclick="insertBoutenToSelection()">⚫ 選択文字に傍点</button>
            </div>
        </div>
        <button class="btn" onclick="toggleLayoutAxis()">縦横切替</button>
        <button class="btn" id="btn-layout-swap" onclick="toggleLayoutOrder()">入替</button>
        <button class="btn btn-sync" id="btn-sync" onclick="syncPreviewPosition()">📲 同期</button>
        <button class="btn btn-view" onclick="openReaderView()" title="全タブをまとめて閲覧（Escで戻る）">👁 閲覧</button>
        <button class="btn btn-analysis" onclick="showAnalysis()">📊 分析</button>
        <button class="btn btn-focus" id="btn-focus" onclick="toggleFocusMode()">🧘 集中</button>
    </div>
    <div class="header-right">
        <button class="btn panel-toggle" id="btn-toggle-memo" onclick="openNavTab('memo')" data-label="📝 メモ">
            <span class="panel-label">📝 メモ</span><span class="panel-state-icon">▾</span>
        </button>
        <button class="btn panel-toggle" id="btn-toggle-outline" onclick="openNavTab('outline')" data-label="📑 目次">
            <span class="panel-label">📑 目次</span><span class="panel-state-icon">▾</span>
        </button>
        <input type="file" id="file-input" accept=".txt" onchange="loadFile(this)">
        <button class="btn" onclick="openFileWithChoice()">📂 開く</button>
        <button class="btn btn-reset-input" onclick="confirmResetInput()" title="入力を初期化します">💀</button>
        <button class="btn btn-save" onclick="showSaveDialog()">💾 保存</button>
    </div>
</header>

<div class="controls-wrapper">
    <div id="search-bar" class="control-panel">
        <div class="panel-action-buttons">
            <button class="panel-pin-btn" onclick="togglePanelPin('search-bar')" title="固定">📌</button>
            <button class="panel-close-btn" onclick="closeControlPanel('search-bar')">✕</button>
        </div>
        <input type="text" id="search-input" placeholder="検索ワード..." onkeydown="if(event.key==='Enter') findNext()">
        <select id=\"search-scope\" title=\"検索範囲\" style=\"height:30px; border-radius:8px; border:1px solid var(--border-color); padding:0 6px; background:var(--panel-bg); color:var(--text-color);\">
            <option value=\"current\">このタブ</option>
            <option value=\"all\">全タブ</option>
        </select>
        <button class="btn btn-search-exec" onclick="doSearch()">検索</button>
        <button class="btn" onclick="findPrev()">▲ 前へ</button>
        <button class="btn" onclick="findNext()">▼ 次へ</button>
        <span id="search-match-info">0 / 0</span>
        <div style="width:1px;height:20px;background:#ccc;margin:0 4px;"></div>
        <input type="text" id="replace-input" placeholder="置換後...">
        <button class="btn" onclick="replaceOne()">置換</button>
        <button class="btn" onclick="replaceAll()">全置換</button>
            <div id="search-hits" class="search-hits" aria-label="ヒット一覧"></div>
    </div>
    
    <div id="help-bar" class="control-panel">
        <div class="panel-action-buttons">
            <button class="panel-pin-btn" onclick="togglePanelPin('help-bar')" title="固定">📌</button>
            <button class="panel-close-btn" onclick="closeControlPanel('help-bar')">✕</button>
        </div>
        <div style="display: flex; flex-wrap: wrap; gap: 16px;">
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【基本操作】</div>
                ・<b>入力エリア</b>：文章を入力<br>
                                ・<b>📲 同期</b>：カーソル位置にプレビュー移動<br>
                ・<b>👁 閲覧</b>：全タブをまとめて全画面表示（区切り記号「◆」付き / Escで戻る）<br>
                ・閲覧中は『縦書きへ/横書きへ』で書字方向を切替できます<br>
                ・終了は <b>Esc</b> または『↩ 元の画面に戻る』です<br>
                ・<b>縦横切替</b>：レイアウト変更<br>
                ・<b>入替</b>：ペインの順序を入れ替え
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【ショートカットキー】</div>
                ・<b>Ctrl+S</b>：保存ダイアログ<br>
                ・<b>Ctrl+F</b>：検索パネル<br>
                ・<b>Ctrl+G</b>：行番号ジャンプ<br>
                ・<b>Ctrl+Z</b>：元に戻す<br>
                ・<b>Ctrl+Y</b>：やり直し<br>
                ・<b>F11</b>：集中モード切替<br>
                ・<b>Esc</b>：ダイアログ閉じる
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【記法（小説向け）】</div>
                ・<b>ルビ</b>：｜漢字《かんじ》<br>
                ・<b>傍点</b>：《《強調》》<br>
                ・<b>傍線</b>：__下線__<br>
                <small>※テキスト選択時、ポップアップからワンクリックでルビ・傍点挿入可能</small>
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【執筆支援】</div>
                ・<b>🧘 集中モード</b>：UIを隠して執筆に集中<br>
                ・<b>タイプライター</b>：カーソル位置を中央に固定<br>
                ・<b>執筆時間トラッカー</b>：自動計測<br>
                ・<b>📊 分析</b>：文字種・文長・頻出語を分析
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【目標機能】</div>
                ・<b>全体目標</b>：作品全体の目標文字数<br>
                ・<b>今日の目標</b>：1日の執筆目標<br>
                ・目標達成時に🎉お祝いアニメーション表示<br>
                ・進捗に応じて色が変化
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【目次・ブックマーク】</div>
                ・<b>📑 目次</b>：見出し（■□▲など）を自動検出<br>
                ・<b>🔖 ブックマーク</b>：任意の位置を保存<br>
                ・クリックでその位置にジャンプ<br>
                ・📌固定で常に表示
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【保存・読込】</div>
                ・<b>💾 保存</b>：テキスト/HTML形式で保存<br>
                ・<b>📂 開く</b>：テキストファイルを読込（開く先を毎回選択：現在タブ/新規タブ）<br>
                ・設定の📤エクスポート/📥インポート
            </div>
            <div class="help-section" style="flex: 1; min-width: 180px;">
                <div class="help-title">【設定】</div>
                ・<b>フォント</b>：明朝・ゴシック・筆文字など<br>
                ・<b>縦書き/横書き</b>：切替可能<br>
                ・<b>テーマ</b>：ライト・ダーク・セピアなど<br>
                ・<b>原稿用紙換算</b>：枚数を自動計算
            </div>
        </div>
    </div>

    <div id="settings-bar" class="control-panel">
        <div class="panel-action-buttons">
            <button class="panel-pin-btn" onclick="togglePanelPin('settings-bar')" title="固定">📌</button>
            <button class="panel-close-btn" onclick="closeControlPanel('settings-bar')">✕</button>
        </div>
        <div class="setting-group">
            <div class="setting-title">入力エリア <button class="btn btn-apply" onclick="applyInputSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>文字: <input type="number" id="st-in-size" value="17" min="10" max="60"></label>
                <label>行間: <input type="number" id="st-in-line" value="1.7" step="0.1" min="1.0" max="5.0"></label>
                <label><input type="checkbox" id="st-in-v" checked> 縦書き</label>
                    <label>フォント: 
                    <select id="st-in-font">
                        <option value="font-gothic" selected>ゴシック</option>
                        <option value="font-mincho">明朝体</option>
                        <option value="font-old">アンティーク</option>
                        <option value="font-round">丸ゴシック</option>
                        <option value="font-brush">筆文字</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">プレビュー <button class="btn btn-apply" onclick="applyPreviewSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>文字: <input type="number" id="st-pv-size" value="17" min="10" max="60"></label>
                <label>行間: <input type="number" id="st-pv-line" value="1.7" step="0.1" min="1.0" max="5.0"></label>
                <label><input type="checkbox" id="st-pv-v" checked> 縦書き</label>
                    <label>フォント: 
                    <select id="st-pv-font">
                        <option value="font-gothic" selected>ゴシック</option>
                        <option value="font-mincho">明朝体</option>
                        <option value="font-old">アンティーク</option>
                        <option value="font-round">丸ゴシック</option>
                        <option value="font-brush">筆文字</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">表示オプション <button class="btn btn-apply" onclick="applyDisplaySettings()">適用</button></div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-show-space" checked> スペース可視化</label>
                <label><input type="checkbox" id="st-show-highlight" checked> ハイライト</label>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="check-show-input" checked> 入力表示</label>
                <label><input type="checkbox" id="check-show-preview" checked> プレビュー表示</label>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-default-preview-hidden"> 起動時プレビュー非表示</label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">執筆支援 <button class="btn btn-apply" onclick="applyWritingSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label><input type="checkbox" id="st-typewriter-mode"> タイプライター</label>
                <label><input type="checkbox" id="st-writing-tracker" checked> 時間トラッカー</label>
            </div>
            <div class="setting-row" id="writing-time-display" style="color: #8b5cf6; font-weight: bold;">執筆時間: 00:00:00</div>
        </div>

        <div class="setting-group">
            <div class="setting-title">目標・統計 <button class="btn btn-apply" onclick="applyGoalSettings()">適用</button></div>
            <div class="setting-row">
                <label>全体目標: <input type="number" id="st-goal-chars" value="150000" min="0" max="999999" style="width:70px;"> 字</label>
            </div>
            <div class="setting-row">
                <label>今日の目標: <input type="number" id="st-today-goal" value="2000" min="0" max="99999" style="width:60px;"> 字</label>
            </div>
            <div class="setting-row">
                <button class="btn btn-apply" onclick="resetTodayStart()" style="font-size:0.65rem;">開始点リセット</button>
            </div>
            <div class="setting-row">
              <label>「今日」の開始時刻: 
                <input id="st-day-start" type="time" list="day-start-presets" value="00:00" style="width:120px;">
              </label>
              <datalist id="day-start-presets">
                <option value="00:00"></option><option value="01:00"></option><option value="02:00"></option>
                <option value="03:00"></option><option value="04:00"></option><option value="05:00"></option><option value="06:00"></option>
              </datalist>
              <button class="btn btn-apply" onclick="applyExtendedSettings()" style="font-size:0.65rem;">適用</button>
            </div>
            <div class="setting-row">
              <label>アクティブタブ色: <input type="color" id="st-active-tab-color" value="#fff59d"></label>
              <button class="btn btn-apply" onclick="applyExtendedSettings()" style="font-size:0.65rem;">適用</button>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-show-reading-time" checked> 読み上げ時間</label>
            </div>
            <div class="setting-row">
                <label><input type="checkbox" id="st-celebrate-goal" checked> 目標達成時にお祝い表示</label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">用紙設定 <button class="btn btn-apply" onclick="applyPaperSettings()">適用</button></div>
            <div class="setting-row vertical">
                <div>行: <input type="number" id="st-manuscript-rows" value="34" min="1" max="100" style="width:50px;"> ×文字: <input type="number" id="st-manuscript-cols" value="42" min="1" max="100" style="width:50px;"></div>
                <label><input type="checkbox" id="st-show-manuscript" checked> 換算表示</label>
                <label>テーマ:
                    <select id="st-theme-preset">
                        <option value="">ライト</option>
                        <option value="theme-dark">ダーク</option>
                        <option value="theme-sepia">セピア</option>
                        <option value="theme-blue">ブルー</option>
                        <option value="theme-green">グリーン</option>
                    </select>
                </label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">開く <button class="btn btn-apply" onclick="applyOpenSettingsAndSave()">適用</button></div>
            <div class="setting-row vertical">
                <label><input type="radio" name="st-open-mode" value="current" checked > 現在のタブに開く</label>
                <label><input type="radio" name="st-open-mode" value="new" > 新しいタブに開く</label>
            </div>
        </div>

        
        <div class="setting-group">
            <div class="setting-title">目次抽出ルール <button class="btn btn-apply" onclick="applyExtendedSettings()">適用</button></div>
            <div class="setting-row" style="flex-wrap:wrap; gap:10px;">
              <label><input type="checkbox" id="st-outline-use-hash" checked> #</label>
              <label><input type="checkbox" id="st-outline-use-box" checked> ■□</label>
              <label><input type="checkbox" id="st-outline-use-tri" checked> ▲</label>
              <label><input type="checkbox" id="st-outline-use-dia" checked> ◆</label>
              <label><input type="checkbox" id="st-outline-use-cir" checked> ○</label>
              <label><input type="checkbox" id="st-outline-use-chapter" checked> 第○章</label>
              <label><input type="checkbox" id="st-outline-use-circnum" checked> ①</label>
              <label><input type="checkbox" id="st-outline-use-roman" checked> Ⅰ</label>
            </div>
            <div class="setting-row vertical">
              <label>追加記号（例: ●★◇ など）: <input type="text" id="st-outline-extra" placeholder="任意" style="width:220px;"></label>
              <div style="font-size:0.78rem; color:var(--text-muted);">チェックされたパターンから、行頭の見出しを抽出します。</div>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">ペイン幅 <button class="btn btn-apply" onclick="applyPaneWidthSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>入力: <input type="number" id="st-pane-input-width" value="520" min="120" max="3000" style="width:70px;">px</label>
                <label>プレビュー: <input type="number" id="st-pane-preview-width" value="520" min="120" max="3000" style="width:70px;">px</label>
                <label>メモ: <input type="number" id="st-pane-memo-width" value="260" min="160" max="1200" style="width:70px;">px</label>
                <label>目次: <input type="number" id="st-pane-outline-width" value="260" min="160" max="1200" style="width:70px;">px</label>
                <label>仕切り幅: <input type="number" id="st-divider-width" value="2" min="1" max="12" style="width:70px;" onchange="applyDividerSettings()">px</label>
            </div>
            <div class="setting-row">
                <button class="btn btn-apply" onclick="resetPaneWidths()" style="font-size:0.65rem;">幅をリセット</button>
                <button class="btn btn-apply" onclick="resetDividerWidth()" style="font-size:0.65rem;">2pxに戻す仕切り初期化</button>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">保存 <button class="btn btn-apply" onclick="applyAutoSaveSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label><input type="checkbox" id="st-autosave-enabled" onchange="applyAutoSaveSettings()"> 自動保存を有効にする</label>
                <label>自動保存間隔: <input type="number" id="st-autosave-interval" value="60" min="5" max="600" style="width:70px;" onchange="applyAutoSaveSettings()"> 秒</label>
            </div>
        </div>

        <div class="setting-group">
            <div class="setting-title">縦並び高さ <button class="btn btn-apply" onclick="applyPaneHeightSettings()">適用</button></div>
            <div class="setting-row vertical">
                <label>入力: <input type="number" id="st-pane-input-height" value="520" min="160" max="2000" style="width:70px;">px</label>
                <label>プレビュー: <input type="number" id="st-pane-preview-height" value="520" min="160" max="2000" style="width:70px;">px</label>
            </div>
            <div class="setting-row">
                <button class="btn btn-apply" onclick="resetPaneHeights()" style="font-size:0.65rem;">高さをリセット</button>
            </div>
        </div>

        <div class="setting-group settings-actions">
            <div class="settings-actions-row">
                <div class="dropdown settings-dropdown">
                    <button class="btn settings-action-btn dropdown-btn" onclick="toggleDropdown('settings-transfer-dropdown')">📦 設定の移行</button>
                    <div id="settings-transfer-dropdown" class="dropdown-content">
                        <button onclick="exportSettings()">📤 設定をエクスポート</button>
                        <button onclick="document.getElementById('settings-file-input').click()">📥 設定をインポート</button>
                    </div>
                </div>
                <button class="btn settings-action-btn" onclick="resetAllSettings()" style="font-size:0.7rem; background:#fee2e2; color:#dc2626; border-color:#fecaca;">🔄 設定を初期化</button>
                <button class="btn btn-apply-all settings-action-btn" onclick="applyAllSettings()">⚡ 一括適用</button>
            </div>
            <input type="file" id="settings-file-input" accept=".json" onchange="importSettings(this)" style="display:none;">
        </div>
    </div>
</div>

<div class="main-container" id="main-container">
    <div class="pane-stack" id="pane-stack">
        <div class="pane" id="pane-input">
            <div class="pane-header">
        <div class="pane-title">
            <h2><span class="novel-title-name" id="novel-title" ondblclick="startEditNovelTitle()" title="ダブルクリックで作品名を変更">ここにプロジェクトタイトルを入力してください。</span></h2>
            <span class="pane-total-stats" id="input-total-stats">全タブ: 0字 / 0行</span>
        </div>
                <div class="pane-actions">
                    <button class="pane-layout-btn" id="btn-input-writing-mode" onclick="toggleInputWritingMode()" title="書字方向切替">横書きへ</button>
                    <button class="pane-close-btn" onclick="hidePane('input')">✕</button>
                </div>
            </div>
            <div class="tabs-scroll-wrap" id="input-tabs-wrap">
                <button class="tab-scroll-btn left" type="button" aria-label="タブを左へ" data-target="input-tabs-container">◀</button>
                <div class="input-tabs-container" id="input-tabs-container">
                    <!-- Tabs will be dynamically generated -->
                </div>
                <button class="tab-scroll-btn right" type="button" aria-label="タブを右へ" data-target="input-tabs-container">▶</button>
            </div>
            <div class="pane-subheader" id="input-pos-bar">現在: 1 行目</div>
            <div class="pane-body">
                <div id="input-mirror-container"></div>
                <textarea id="input-area" spellcheck="false"></textarea>
                <div id="input-sel-overlay" class="selection-overlay"></div>
            </div>
            <div class="pane-footer">
                <span id="char-count">全体: 0</span>
                <span id="input-net-count" class="net-count">実質: 0</span>
                <span id="line-count">0 行</span>
                <span id="input-goal-display" class="goal-display"></span>
                <span id="input-today-goal" class="today-goal"></span>
                <span id="input-writing-time" class="writing-time"></span>
                <span id="input-reading-time" class="reading-time"></span>
                <span id="input-manuscript" class="manuscript-pages"></span>
            </div>
        </div>

        <div class="pane-resizer" id="resizer-input-preview"></div>

        <div class="pane" id="pane-preview">
            <div class="pane-header">
                <div class="pane-title">
                    <h2>プレビュー</h2>
                    <span class="pane-total-stats" id="preview-total-stats">全タブ: 0字 / 0行</span>
                </div>
                <div class="pane-actions">
                    <button class="pane-layout-btn" id="btn-preview-writing-mode" onclick="togglePreviewWritingMode()" title="書字方向切替">横書きへ</button>
                    <button class="pane-close-btn" onclick="hidePane('preview')">✕</button>
                </div>
            </div>
            <div class="tabs-scroll-wrap" id="preview-tabs-wrap">
                <button class="tab-scroll-btn left" type="button" aria-label="タブを左へ" data-target="preview-tabs-container">◀</button>
                <div class="preview-tabs-container" id="preview-tabs-container">
                    <!-- Preview tabs will be dynamically generated -->
                </div>
                <button class="tab-scroll-btn right" type="button" aria-label="タブを右へ" data-target="preview-tabs-container">▶</button>
            </div>
            <div class="pane-subheader" id="preview-pos-bar">位置: 0%</div>
            <div class="pane-body">
                <div id="preview-scroll">
                    <div id="preview-content"></div>
                </div>
                <div id="preview-sel-overlay" class="selection-overlay"></div>
            </div>
            <div class="pane-footer">
                <span id="pv-time" class="timestamp">未更新</span>
                <span style="border-left:1px solid var(--border-color); height:12px; margin:0 5px;"></span>
                <span id="pv-total-count">全体: 0</span>
                <span id="pv-net-count" class="net-count">実質: 0</span>
                <span id="pv-line-count">0 行</span>
                <span id="pv-goal-display" class="goal-display"></span>
                <span id="pv-today-goal" class="today-goal"></span>
                <span id="pv-reading-time" class="reading-time"></span>
                <span id="pv-manuscript" class="manuscript-pages"></span>
            </div>
        </div>
    </div>

<div id="memo-panel">
  <div class="memo-header" style="display:flex; justify-content:space-between; align-items:center; padding: 8px 10px; background: var(--pane-header-bg); border-bottom: 1px solid var(--border-color); font-weight:bold; font-size:0.85rem; flex-wrap:wrap; gap:4px;">
    <span style="font-family: var(--font-ui);">📝 メモ</span>
    <div class="memo-controls" style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
<button id="btn-memo-swap" class="btn panel-swap-btn" onclick="swapMemoSide()">左右入替</button>
<button class="panel-pin-btn" id="btn-memo-pin" onclick="toggleMemoDockPin()" title="固定/浮動切り替え">📌</button>
<input type="checkbox" id="check-memo-dock" class="dock-pin-checkbox" onchange="toggleMemoDock()">
      <button class="panel-close-btn" onclick="closeMemoPanel(true)" style="background:none; border:none; cursor:pointer;">✖</button>
    </div>
  </div>



    <div class="memo-toolbar" style="background: var(--bg-color); padding: 4px 4px 0 4px; border-bottom: 1px solid var(--border-color);">
        <div class="tabs-scroll-wrap memo-tabs-wrap" id="memo-tabs-wrap">
            <button class="tab-scroll-btn left" type="button" aria-label="メモタブを左へ" data-target="memo-tabs-container">◀</button>
            <div id="memo-tabs-container" class="memo-tabs"></div>
            <button class="tab-scroll-btn right" type="button" aria-label="メモタブを右へ" data-target="memo-tabs-container">▶</button>
        </div>
    </div>

    <textarea id="memo-area" placeholder="ここに入力..." oninput="updateMemoCharCount(); saveMemoTabs()" style="flex: 1; width: 100%; resize: none; border: none; padding: 8px; font-family: inherit; box-sizing: border-box; outline: none;"></textarea>
    
    <div class="memo-footer" style="padding: 2px 8px; font-size: 0.75rem; color: var(--text-muted); border-top: 1px solid var(--border-color); display:flex; justify-content:space-between;">
        <span id="memo-char-count">0字</span>
        <div class="memo-file-btns">
            <button onclick="showMemoSaveDialog()" style="font-size:0.7rem; cursor:pointer;">保存</button>
        </div>
    </div>
</div>
<div id="resizer-memo" class="dock-resizer" title="(左境界) プレビューとメモの幅を調整します"></div>

    <div class="dock-resizer" id="resizer-memo-outline" title="(右境界) Alt+ドラッグでメモと目次の配分を調整します"></div>
    <div id="outline-panel">
        <div class="outline-header">
            <span>📑 目次</span>
            <div class="outline-controls">
                <button id="btn-outline-swap" class="btn panel-swap-btn" onclick="swapOutlineSide()">左右入替</button>
                <input type="checkbox" id="check-outline-dock" class="dock-pin-checkbox" onchange="toggleOutlineDock()">
                <button class="panel-pin-btn" id="btn-outline-pin" onclick="toggleOutlineDockPin()" title="固定">📌</button>
                <button class="panel-close-btn" onclick="closeOutlinePanel()">✕</button>
            </div>
        </div>
        <div class="outline-toolbar" style="display:flex; padding:4px 8px; background:var(--pane-header-bg); border-bottom:1px solid var(--border-color); gap:4px; align-items:center;">
            <div class="nav-jump-controls" title="ジャンプ履歴"><button id="btn-nav-back" class="nav-jump-btn" type="button" aria-label="戻る">◀</button><button id="btn-nav-forward" class="nav-jump-btn" type="button" aria-label="進む">▶</button></div><div class="outline-tabs-inner" style="display:flex; gap:2px; flex:1;">
                <span class="memo-tab active" onclick="switchOutlineTab('outline')" style="cursor:pointer;">目次</span>
                <span class="memo-tab" onclick="switchOutlineTab('bookmark')" style="cursor:pointer;">🔖しおり</span>
                <span class="memo-tab" onclick="switchOutlineTab('search')" style="cursor:pointer;">🔍検索</span>
                <span class="memo-tab" onclick="switchOutlineTab('proof')" style="cursor:pointer;">🧹校正</span>
                <span class="memo-tab" onclick="switchOutlineTab('memo')" style="cursor:pointer;">📝メモ</span>
            </div>
        </div>
        <div class="outline-content">
            <div id="outline-tab-outline" class="outline-tab-content active">
                <div style="margin-bottom:8px; display:flex; gap:4px; flex-wrap:wrap;">
                    <button class="btn" style="padding:2px 6px; font-size:0.7rem;" onclick="generateOutline()">🔄更新</button>
                    <button class="btn" style="padding:2px 6px; font-size:0.7rem;" onclick="expandAllOutline()">全展開</button>
                    <button class="btn" style="padding:2px 6px; font-size:0.7rem;" onclick="collapseAllOutline()">全折畳</button>
                </div>
                <div id="outline-list"></div>
            </div>
            <div id="outline-tab-bookmark" class="outline-tab-content">
                <button class="bookmark-add-btn" onclick="addBookmark()">＋ 現在位置にブックマークを追加</button>
                <div id="bookmark-actions" style="display:none; margin-bottom: 8px; padding: 4px; background: #fef3c7; border-radius: 4px;">
                    <label style="font-size: 0.8rem; cursor: pointer;"><input type="checkbox" id="bookmark-select-all" onchange="toggleAllBookmarks()"> 全選択</label>
                    <button onclick="deleteSelectedBookmarks()" style="margin-left: 8px; padding: 2px 8px; font-size: 0.75rem; background: #fee2e2; border: 1px solid #fecaca; border-radius: 4px; cursor: pointer;">🗑 選択削除</button>
                </div>
                <div id="bookmark-list"></div>
            </div>

            <div id="outline-tab-search" class="outline-tab-content">
                <div class="outline-empty" style="margin-bottom:8px;">検索パネルをここに表示します（Alt+Fで一発表示）</div>
                <div id="nav-search-host"></div>
            </div>
            <div id="outline-tab-proof" class="outline-tab-content">
                <div id="proofread-modal" class="proofread-embedded">
                    <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-bottom:10px;">
                        <label style="display:flex; align-items:center; gap:6px;">範囲
                            <select id="pf-scope" style="height:30px; border-radius:10px; border:1px solid var(--border-color); padding:0 8px; background:var(--panel-bg); color:var(--text-color);">
                                <option value="current" selected>このタブ</option>
                                <option value="all">全タブ</option>
                            </select>
                        </label>
                        <label><input type="checkbox" id="pf-unclosed" checked>「」等の未閉じ</label>
                        <label><input type="checkbox" id="pf-sentend" checked>文末（。！？）の不足</label>
                        <label><input type=\"checkbox\" id=\"pf-punct\" checked>約物・空白のゆらぎ</label>
                        <button class="btn btn-apply" id="btn-proofread-run-inline" onclick="runProofread()">チェック開始</button>
                        <button class=\"btn\" id=\"btn-proofread-ignore\" type=\"button\" onclick=\"openProofIgnoreManager()\">無視リスト</button>
                    </div>
                    <div id="proofread-results"><div class="outline-empty">まだ結果はありません</div></div>
                    <div style="font-size:0.85rem; color:var(--text-muted); margin-top:10px; line-height:1.5;">※結果をクリックすると該当箇所へジャンプします。</div>
                </div>
            </div>
            <div id="outline-tab-memo" class="outline-tab-content">
                <div id="nav-memo-host"></div>
            </div>
        </div>
        <div id="outline-summary" class="outline-summary"></div>
    </div>

    <div class="dock-resizer" id="resizer-outline" title="目次の幅を調整します"></div>
</div>

<div class="focus-exit-hint">ESCキーで集中モードを解除</div>

<div id="celebration-overlay" class="celebration-overlay"></div>
<div id="celebration-message" class="celebration-message">
    <span class="emoji">🎉</span>
    <span id="celebration-text">やったね！</span>
    <span class="sub" id="celebration-sub"></span>
</div>

<div id="quick-insert-popup" class="quick-insert-popup">
    <button class="qip-ruby" onclick="quickInsertRuby()">🔤ルビ</button>
    <button class="qip-bouten" onclick="quickInsertBouten()">⚫傍点</button>
    <button onclick="quickWrapSelection('「', '」')">「」</button>
    <button onclick="quickWrapSelection('『', '』')">『』</button>
    <button onclick="quickWrapSelection('（', '）')">（）</button>
    <button style="color:#d97706;" onclick="quickAddBookmark()">🔖しおり</button>
</div>

<div id="save-dialog-overlay" class="save-dialog-overlay" style="display:none;">
    <div class="save-dialog">
        <h3>保存形式を選択</h3>
        <div style="margin-bottom: 15px; font-size: 0.85rem;">
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="save-scope" value="current" checked> 現在のタブのみ
            </label>
            <label style="display: block;">
                <input type="radio" name="save-scope" value="all"> 全タブを結合（章区切り付き）
            </label>
        </div>
        <div class="save-dialog-buttons">
            <button class="btn" onclick="saveAsText()">📄 テキスト</button>
            <button class="btn" onclick="saveAsHTML()">🌐 HTML</button>
            <button class="btn" onclick="closeSaveDialog()">キャンセル</button>
        </div>
    </div>
</div>

<div id="memo-save-dialog" class="save-dialog-overlay" style="display:none;">
    <div class="save-dialog" style="background:#fefce8;">
        <h3>📝 メモを保存</h3>
        <div style="margin-bottom: 15px; font-size: 0.85rem;">
            <label style="display: block; margin-bottom: 5px;">
                <input type="radio" name="memo-save-scope" value="current" checked> 現在のタブのみ
            </label>
            <label style="display: block;">
                <input type="radio" name="memo-save-scope" value="all"> 全タブを結合
            </label>
        </div>
        <div class="save-dialog-buttons">
            <button class="btn" onclick="executeMemoSave()">💾 保存</button>
            <button class="btn" onclick="closeMemoSaveDialog()">キャンセル</button>
        </div>
    </div>
</div>

<div id="autosave-toast" class="autosave-toast">自動保存しました♪</div>
<div id="autosave-error" class="autosave-error-overlay">
    <div class="autosave-error">
        自動保存できませんでした😢　自動保存をオフにします
        <div><button onclick="closeAutoSaveError()">OK</button></div>
    </div>
</div>

<div id="analysis-modal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header"><h3>📊 テキスト分析</h3><button class="modal-close" onclick="closeAnalysis()">✕</button></div>
        <div id="analysis-results"></div>
    </div>
</div>

<!-- 開く（読み込み）時の選択ダイアログ：現在タブ or 新規タブ -->
<div id="open-choice-modal" class="modal-overlay" aria-hidden="true">
    <div class="modal-content" style="max-width: 420px;">
        <div class="modal-header">
            <h3>📂 開く</h3>
            <button class="modal-close" onclick="closeOpenChoiceModal()">✕</button>
        </div>
        <div style="font-size:0.9rem; line-height:1.6; margin-bottom: 12px;">
            読み込んだテキストを、どこに開きますか？
            <div style="font-size:0.8rem; color: var(--text-muted); margin-top:6px;">
                
                <div style="margin-top:10px;">
                  <label style="font-size:0.85rem; color:var(--text-muted);">
                    <input type="checkbox" id="check-open-set-default"> 今回の選択を既定にする
                  </label>
                </div>
            </div>
        </div>
        <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
            <button class="btn" id="btn-open-choice-current" onclick="chooseOpenModeAndPickFile('current')">現在のタブに開く</button>
            <button class="btn btn-apply-all" id="btn-open-choice-new" onclick="chooseOpenModeAndPickFile('new')">新しいタブに開く</button>
            <button class="btn" onclick="closeOpenChoiceModal()">キャンセル</button>
        </div>
    </div>
</div>

<div id="reader-overlay" aria-hidden="true">
    <div id="reader-header">
        <div id="reader-title">👁 閲覧（全タブ） <span class="reader-hint">※保存時の区切り記号「◆」を表示 / Escでも戻れます</span></div>
        <div id="reader-controls">
            <input type="text" id="reader-search-input" placeholder="閲覧内検索..." style="height:30px; width:160px; border-radius:10px; border:1px solid var(--border-color); padding:0 10px; background:var(--panel-bg); color:var(--text-color);" onkeydown="if(event.key==='Enter') readerDoSearch()">
            <button class="btn" onclick="readerDoSearch()">検索</button>
            <button class="btn" onclick="readerFindPrev()">▲</button>
            <button class="btn" onclick="readerFindNext()">▼</button>
            <span id="reader-search-info" style="min-width:52px; display:inline-block; text-align:right;">0/0</span>
            <select id="reader-bookmark-select" style="height:30px; border-radius:10px; border:1px solid var(--border-color); padding:0 8px; background:var(--panel-bg); color:var(--text-color);" onchange="readerJumpBookmark()">
              <option value="">🔖 しおり</option>
            </select>
            <button class="btn" onclick="readerAddBookmark()">＋しおり</button>
            <button class="btn" id="btn-reader-writing-mode" onclick="toggleReaderWritingMode()" title="書字方向切替">縦書きへ</button>
            <button class="btn btn-sync" onclick="closeReaderView()" title="元の画面に戻る（Esc）">↩ 元の画面に戻る</button>
            <button class="btn" onclick="closeReaderView()" title="閉じる">✕</button>
        </div>
    </div>
    <div id="reader-scroll"><div id="reader-content"></div></div>
</div>

<div id="jump-dialog" class="jump-dialog">
    <h4>行番号ジャンプ</h4>
    <input type="number" id="jump-line-input" placeholder="行番号を入力..." min="1">
    <div class="jump-dialog-buttons">
        <button class="btn" onclick="executeJump()">ジャンプ</button>
        <button class="btn" onclick="closeJumpDialog()">キャンセル</button>
    </div>
</div>


<!-- タブ右クリックメニュー -->
<div id="tab-context-menu" aria-hidden="true">
  <button onclick="ctxRenameTab()">✏️ リネーム</button>
  <button onclick="ctxDuplicateTab()">📄 複製</button>
  <button onclick="ctxNewTab()">＋ 新規タブ</button>
  <hr>
  <button onclick="ctxCloseTab()">✕ このタブを閉じる</button>
</div>

<!-- ルビ入力モーダル -->
<div id="ruby-modal" aria-hidden="true">
  <div class="ruby-box" role="dialog" aria-label="ルビ入力">
    <div class="ruby-header">
      <h3>🈂️ ルビ</h3>
      <button class="ruby-close" onclick="closeRubyModal()" title="閉じる">✕</button>
    </div>
    <div class="ruby-target">対象：<b id="ruby-target-text"></b></div>
    <input id="ruby-input" type="text" placeholder="ルビを入力（Enterで確定）">
    <div class="ruby-actions">
      <button class="btn" onclick="closeRubyModal()">キャンセル</button>
      <button class="btn btn-apply-all" onclick="confirmRubyModal()">OK</button>
    </div>
  </div>
</div>

<!-- 集中モード用 一時表示オーバーレイ -->
<div id="focus-overlay" aria-hidden="true">
  <div class="focus-box" role="dialog" aria-label="集中モード一時表示">
    <div class="focus-header">
      <h3 id="focus-overlay-title">表示</h3>
      <button class="btn" onclick="closeFocusOverlay()">✕</button>
    </div>
    <div class="focus-body" id="focus-overlay-body"></div>
  </div>
</div>

<script>

  // 先にダミーを作って未定義落ちを防ぐ（あとで本物があれば上書きされる）
  window.setupMemoInteractionGuard = window.setupMemoInteractionGuard || function(){};

  // エラー回避：未実装でも落ちないようにする（最初の<script>の先頭に置く）
  window.updateActiveTabTitle = window.updateActiveTabTitle || function () {};
  window.updateMemoCharCount = function () {
    const memoArea = document.getElementById('memo-area');
    const countEl  = document.getElementById('memo-char-count');
    if (memoArea && countEl) countEl.innerText = memoArea.value.length + '字';
  };
    window.updateMemoCharCount = function () {
    const memoArea = document.getElementById('memo-area');
    const countEl  = document.getElementById('memo-char-count');
    if (memoArea && countEl) countEl.innerText = memoArea.value.length + '字';
  };

// パネル操作中フラグ（浮動パネルが意図せず閉じないようにする）
window.memoInteracting = false;
window.outlineInteracting = false;

function setupMemoInteractionGuard() {
  const memo = document.getElementById('memo-panel');
  if (!memo) return;

  const on = () => { window.memoInteracting = true; };
  const off = () => { window.memoInteracting = false; };

  // マウスが乗っている間／フォーカス中は「操作中」
  memo.addEventListener('pointerenter', on);
  memo.addEventListener('pointerleave', off);
  memo.addEventListener('focusin', on);
  memo.addEventListener('focusout', off);

  // クリック・ドラッグの最中も「操作中」
  memo.addEventListener('pointerdown', on, { capture: true });
  memo.addEventListener('pointerup', off, { capture: true });
  memo.addEventListener('pointercancel', off, { capture: true });
}

function setupOutlineInteractionGuard() {
  const outline = document.getElementById('outline-panel');
  if (!outline) return;

  const on = () => { window.outlineInteracting = true; };
  const off = () => { window.outlineInteracting = false; };

  outline.addEventListener('pointerenter', on);
  outline.addEventListener('pointerleave', off);
  outline.addEventListener('focusin', on);
  outline.addEventListener('focusout', off);
  outline.addEventListener('pointerdown', on, { capture: true });
  outline.addEventListener('pointerup', off, { capture: true });
  outline.addEventListener('pointercancel', off, { capture: true });
}

// タブバー左右スクロール
function setupTabScrollButtons() {
  document.querySelectorAll('.tab-scroll-btn').forEach(btn => {
    btn.addEventListener('click', ev => {
      ev.preventDefault();
      ev.stopPropagation();
      const targetId = btn.dataset.target;
      const container = document.getElementById(targetId);
      if (!container) return;
      const dir = btn.classList.contains('left') ? -1 : 1;
      container.scrollBy({ left: dir * 200, behavior: 'smooth' });
    });
  });
}

function updateTabScrollButtonsFor(targetId) {
  const container = document.getElementById(targetId);
  if (!container) return;
  const wrap = container.closest('.tabs-scroll-wrap');
  if (!wrap) return;
  const leftBtn = wrap.querySelector('.tab-scroll-btn.left');
  const rightBtn = wrap.querySelector('.tab-scroll-btn.right');
  if (!leftBtn || !rightBtn) return;

  const needs = container.scrollWidth > container.clientWidth + 1;
  leftBtn.classList.toggle('show', needs);
  rightBtn.classList.toggle('show', needs);
  if (!needs) {
    leftBtn.disabled = true;
    rightBtn.disabled = true;
    leftBtn.style.opacity = '0.35';
    rightBtn.style.opacity = '0.35';
    return;
  }

  const maxScroll = container.scrollWidth - container.clientWidth;
  const atLeft = container.scrollLeft <= 0;
  const atRight = container.scrollLeft >= maxScroll - 1;
  leftBtn.disabled = atLeft;
  rightBtn.disabled = atRight;
  leftBtn.style.opacity = atLeft ? '0.35' : '1';
  rightBtn.style.opacity = atRight ? '0.35' : '1';
}

function initTabScrollers() {
  setupTabScrollButtons();
  ['input-tabs-container', 'preview-tabs-container', 'memo-tabs-container'].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.addEventListener('scroll', () => updateTabScrollButtonsFor(id), { passive: true });
  });
  window.addEventListener('resize', () => {
    updateTabScrollButtonsFor('input-tabs-container');
    updateTabScrollButtonsFor('preview-tabs-container');
    updateTabScrollButtonsFor('memo-tabs-container');
  });

  // 初期状態
  updateTabScrollButtonsFor('input-tabs-container');
  updateTabScrollButtonsFor('preview-tabs-container');
  updateTabScrollButtonsFor('memo-tabs-container');
}

// 起動時に1回だけセットアップ
setupMemoInteractionGuard();
setupOutlineInteractionGuard();
initTabScrollers();

	
    const inputArea = document.getElementById('input-area');
    const inputMirror = document.getElementById('input-mirror-container');
    const previewContent = document.getElementById('preview-content');
    const previewScroll = document.getElementById('preview-scroll');
    const inputPosBar = document.getElementById('input-pos-bar');
    const previewPosBar = document.getElementById('preview-pos-bar');
    const charCountEl = document.getElementById('char-count');
    const lineCountEl = document.getElementById('line-count');
    const inputNetCountEl = document.getElementById('input-net-count');
    const inputGoalEl = document.getElementById('input-goal-display');
    const inputTodayGoalEl = document.getElementById('input-today-goal');
    const inputWritingTimeEl = document.getElementById('input-writing-time');
    const inputReadingEl = document.getElementById('input-reading-time');
    const inputManuscriptEl = document.getElementById('input-manuscript');
    const inputSelOverlay = document.getElementById('input-sel-overlay');
    const pvTotalCountEl = document.getElementById('pv-total-count');
    const pvNetCountEl = document.getElementById('pv-net-count');
    const pvLineCountEl = document.getElementById('pv-line-count');
    const pvTimeEl = document.getElementById('pv-time');
    const pvGoalEl = document.getElementById('pv-goal-display');
    const pvTodayGoalEl = document.getElementById('pv-today-goal');
    const pvReadingEl = document.getElementById('pv-reading-time');
    const pvManuscriptEl = document.getElementById('pv-manuscript');
    const previewSelOverlay = document.getElementById('preview-sel-overlay');
    const btnSwap = document.getElementById('btn-layout-swap');
    const paneStack = document.getElementById('pane-stack');

    if (inputSelOverlay) inputSelOverlay.title = '選択中の文字数と行数を表示します。';
    if (previewSelOverlay) previewSelOverlay.title = 'プレビューで選択した範囲の文字数と行数を表示します。';

    let layoutAxis = 'row', layoutReversed = false;
    const LAYOUT_AXIS_KEY = 'cc_layout_axis';
    const LAYOUT_REVERSED_KEY = 'cc_layout_reversed';

    let settingsCache = {
        goalChars: 150000, todayGoal: 2000, manuscriptRows: 34, manuscriptCols: 42,
        showReadingTime: true, showManuscript: true, showSpace: true, showHighlight: true,
        typewriterMode: false, writingTracker: true, defaultPreviewHidden: false,
        celebrateGoal: true, openMode: 'current', autosaveInterval: 60, autosaveEnabled: false
    };
    let goalAchieved = { today: false, total: false };
    let previewUpdateTimeout = null;

    // 「📂 開く」を押した時に、その場で「現在タブ / 新規タブ」を選べるようにするための一時設定
    // （loadFile() 内で優先して参照し、処理後に null に戻します）
    let pendingOpenMode = null;

    const PANE_WIDTH_KEYS = {
        input: 'cc_pane_input_width_px',
        preview: 'cc_pane_preview_width_px',
        memo: 'cc_memo_width_px',
        outline: 'cc_outline_width_px',
        legacyInput: 'cc_pane_input_width',
        legacyPreview: 'cc_pane_preview_width'
    };
    const PANE_HEIGHT_KEYS = {
        input: 'cc_pane_input_height_px',
        preview: 'cc_pane_preview_height_px'
    };
    const DIVIDER_WIDTH_KEY = 'cc_divider_width_px';

    const TODAY_START_KEY = 'cc_editor_today_start';
    const WRITING_TIME_KEY = 'cc_editor_writing_time';
    const BOOKMARKS_KEY = 'cc_editor_bookmarks';
    const SETTINGS_KEY = 'cc_editor_settings';
    const TABS_KEY = 'cc_editor_tabs';
    const NOVEL_TITLE_KEY = 'cc_editor_novel_title';
    const DEFAULT_NOVEL_TITLE = 'ここにプロジェクトタイトルを入力してください。';
    let todayStartChars = 0, writingSeconds = 0, lastInputTime = 0, writingTimerInterval = null, bookmarks = [];
    let novelTitle = DEFAULT_NOVEL_TITLE;
    let lastTextSaveHandle = null;
    let lastHtmlSaveHandle = null;
    let lastMemoSaveHandle = null;
    let autoSaveTarget = { handle: null, type: null };

    // Utility function - must be defined before use in renderInputTabs
    function escapeHtml(s) { return s.replace(/[&<>"']/g, m => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' }[m])); }

    function saveLayoutSettings() {
        localStorage.setItem(LAYOUT_AXIS_KEY, layoutAxis);
        localStorage.setItem(LAYOUT_REVERSED_KEY, layoutReversed ? 'true' : 'false');
    }

    function applyLayoutState() {
        if (layoutAxis === 'column') {
            document.body.classList.add('scroll-mode');
            btnSwap.innerText = '上下入替';
        } else {
            document.body.classList.remove('scroll-mode');
            btnSwap.innerText = '左右入替';
        }
        paneStack.classList.remove('reverse-row', 'reverse-col');
        if (layoutReversed) paneStack.classList.add(layoutAxis === 'row' ? 'reverse-row' : 'reverse-col');
    }

    function loadLayoutSettings() {
        const savedAxis = localStorage.getItem(LAYOUT_AXIS_KEY);
        const savedReversed = localStorage.getItem(LAYOUT_REVERSED_KEY);
        if (savedAxis === 'row' || savedAxis === 'column') layoutAxis = savedAxis;
        layoutReversed = savedReversed === 'true';
        applyLayoutState();
    }

    function setPaneSplitEqual() {
        if (document.body.classList.contains('scroll-mode')) {
            const inputPane = document.getElementById('pane-input');
            const baseHeight = Math.round(inputPane?.getBoundingClientRect().height || 520);
            const equalHeight = clampValue(baseHeight, 160, 2000);
            document.getElementById('st-pane-input-height').value = equalHeight;
            document.getElementById('st-pane-preview-height').value = equalHeight;
            localStorage.setItem(PANE_HEIGHT_KEYS.input, String(equalHeight));
            localStorage.setItem(PANE_HEIGHT_KEYS.preview, String(equalHeight));
            applyPaneHeightSettings();
        } else {
            const mainContainer = document.getElementById('main-container');
            const containerWidth = mainContainer.getBoundingClientRect().width || 1000;
            const halfWidth = clampValue(Math.round(containerWidth / 2), 120, 3000);
            document.getElementById('st-pane-input-width').value = halfWidth;
            document.getElementById('st-pane-preview-width').value = halfWidth;
            localStorage.setItem(PANE_WIDTH_KEYS.input, halfWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.preview, halfWidth);
            applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
        }
    }

    // Input Tabs System
    let inputTabs = [{ id: 1, name: 'タブはリネームできます', content: '' }];
    let activeTabId = 1;
    let nextTabId = 2;
    let draggingInputTabId = null;

    function renderInputTabs() {
        const container = document.getElementById('input-tabs-container');
        container.innerHTML = '';
        inputTabs.forEach(tab => {
            const tabEl = document.createElement('div');
            tabEl.className = 'input-tab' + (tab.id === activeTabId ? ' active' : '');
            tabEl.draggable = true;
            tabEl.dataset.tabId = tab.id;
            tabEl.innerHTML = `
                <span class="tab-name" ondblclick="startEditTabName(${tab.id})">${escapeHtml(tab.name)}</span>
                ${inputTabs.length > 1 ? `<span class="tab-close" onclick="event.stopPropagation(); deleteTab(${tab.id})">✕</span>` : ''}
            `;
            tabEl.onclick = () => switchTab(tab.id);
            tabEl.addEventListener('dragstart', e => {
                draggingInputTabId = tab.id;
                tabEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            tabEl.addEventListener('dragend', () => {
                draggingInputTabId = null;
                tabEl.classList.remove('dragging');
            });
            tabEl.addEventListener('dragover', e => {
                if (draggingInputTabId === null || draggingInputTabId === tab.id) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            tabEl.addEventListener('drop', e => {
                e.preventDefault();
                if (draggingInputTabId === null || draggingInputTabId === tab.id) return;
                const fromIndex = inputTabs.findIndex(t => t.id === draggingInputTabId);
                const toIndex = inputTabs.findIndex(t => t.id === tab.id);
                if (fromIndex === -1 || toIndex === -1) return;
                const [moved] = inputTabs.splice(fromIndex, 1);
                inputTabs.splice(toIndex, 0, moved);
                renderInputTabs();
                saveTabsToStorage();
            });
            container.appendChild(tabEl);
        });
        const addBtn = document.createElement('button');
        addBtn.className = 'input-tab-add';
        addBtn.textContent = '＋';
        addBtn.title = '新しいタブを追加';
        addBtn.onclick = addNewTab;
        container.appendChild(addBtn);
        updateTabScrollButtonsFor('input-tabs-container');
        updateActiveTabTitle();
        updatePreviewTabOptions();
    }
    function sanitizeFileName(name) {
        return name.replace(/[\\/:*?"<>|]/g, '').trim();
    }
    function setNovelTitle(title, save = true) {
        novelTitle = title.trim() || DEFAULT_NOVEL_TITLE;
        const titleEl = document.getElementById('novel-title');
        if (titleEl) titleEl.textContent = novelTitle;
        if (save) localStorage.setItem(NOVEL_TITLE_KEY, novelTitle);
    }
    function loadNovelTitle() {
        const saved = localStorage.getItem(NOVEL_TITLE_KEY);
        setNovelTitle(saved || DEFAULT_NOVEL_TITLE, false);
    }
    function startEditNovelTitle() {
        const titleEl = document.getElementById('novel-title');
        if (!titleEl) return;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'novel-title-input';
        input.value = novelTitle;
        input.onblur = () => finishEditNovelTitle(input.value);
        input.onkeydown = e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') { input.value = novelTitle; input.blur(); } };
        titleEl.replaceWith(input);
        input.focus();
        input.select();
    }
    function finishEditNovelTitle(newTitle) {
        setNovelTitle(newTitle);
        const input = document.querySelector('.pane-title input.novel-title-input');
        if (!input) return;
        const span = document.createElement('span');
        span.className = 'novel-title-name';
        span.id = 'novel-title';
        span.title = 'ダブルクリックで作品名を変更';
        span.ondblclick = startEditNovelTitle;
        span.textContent = novelTitle;
        input.replaceWith(span);
    }

function switchTab(tabId) {
  // Save current tab content
  const currentTab = inputTabs.find(t => t.id === activeTabId);
  if (currentTab) currentTab.content = inputArea.value;

  // Switch to new tab
  activeTabId = tabId;
  const newTab = inputTabs.find(t => t.id === tabId);
  if (newTab) inputArea.value = newTab.content;

  renderInputTabs();
  updateInputStats();

  // ★ここではプレビューを更新しない（完全独立）

  saveTabsToStorage();
}

function addNewTab() {
  const currentTab = inputTabs.find(t => t.id === activeTabId);
  if (currentTab) currentTab.content = inputArea.value;

  const newTab = { id: nextTabId++, name: `タブ${inputTabs.length + 1}`, content: '' };
  inputTabs.push(newTab);

  activeTabId = newTab.id;
  inputArea.value = '';

  renderInputTabs();
  updateInputStats();

  // ★ここではプレビューを更新しない（完全独立）
  // updatePreview();

  saveTabsToStorage();
}


    function deleteTab(tabId) {
        if (inputTabs.length <= 1) return;
        if (!confirm('このタブを削除しますか？')) return;
        const idx = inputTabs.findIndex(t => t.id === tabId);
        inputTabs.splice(idx, 1);
        if (activeTabId === tabId) {
            activeTabId = inputTabs[Math.max(0, idx - 1)].id;
            inputArea.value = inputTabs.find(t => t.id === activeTabId).content;
        }
        renderInputTabs();
        updateInputStats();
        updatePreview();
        saveTabsToStorage();
    }

    function startEditTabName(tabId) {
        const container = document.getElementById('input-tabs-container');
        const tabEl = container.querySelector(`.input-tab.active .tab-name`) || container.querySelector(`.input-tab:nth-child(${inputTabs.findIndex(t => t.id === tabId) + 1}) .tab-name`);
        const tab = inputTabs.find(t => t.id === tabId);
        if (!tabEl || !tab) return;
        const input = document.createElement('input');
        input.type = 'text';
        input.className = 'tab-name-input';
        input.value = tab.name;
        input.onblur = () => finishEditTabName(tabId, input.value);
        input.onkeydown = e => { if (e.key === 'Enter') input.blur(); if (e.key === 'Escape') { input.value = tab.name; input.blur(); } };
        tabEl.replaceWith(input);
        input.focus();
        input.select();
    }

    function finishEditTabName(tabId, newName) {
        const tab = inputTabs.find(t => t.id === tabId);
        if (tab) tab.name = newName.trim() || tab.name;
        updateActiveTabTitle();
        renderInputTabs();
        saveTabsToStorage();
    }

    function saveTabsToStorage() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;
        localStorage.setItem(TABS_KEY, JSON.stringify({ tabs: inputTabs, activeTabId, nextTabId }));
    }

    function loadTabsFromStorage() {
        const s = localStorage.getItem(TABS_KEY);
        if (s) {
            try {
                const d = JSON.parse(s);
                if (d.tabs && d.tabs.length > 0) {
                    inputTabs = d.tabs;
                    activeTabId = d.activeTabId || inputTabs[0].id;
                    nextTabId = d.nextTabId || inputTabs.length + 1;
                    const activeTab = inputTabs.find(t => t.id === activeTabId);
                    if (activeTab) inputArea.value = activeTab.content;
                    return true;
                }
            } catch (e) {}
        }
        return false;
    }

    function getAllTabsContent() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;
        let combined = '';
        inputTabs.forEach((tab, idx) => {
            if (idx > 0) combined += '\n\n';
            combined += `◆ ${tab.name}\n\n${tab.content}`;
        });
        return combined;
    }

    function getCurrentTabContent() {
        return inputArea.value;
    }

    function getTodayDateStr() { const n = new Date(); return `${n.getFullYear()}-${(n.getMonth()+1).toString().padStart(2,'0')}-${n.getDate().toString().padStart(2,'0')}`; }

    function loadTodayStart() {
        const s = localStorage.getItem(TODAY_START_KEY);
        if (s) { try { const d = JSON.parse(s); if (d.date === getTodayDateStr()) { todayStartChars = d.startChars; return; } } catch (e) {} }
        saveTodayStart();
    }
    function saveTodayStart() { const n = inputArea.value.replace(/[\n\s　]/g, '').length; todayStartChars = n; localStorage.setItem(TODAY_START_KEY, JSON.stringify({ date: getTodayDateStr(), startChars: n })); }
    function resetTodayStart() { if (confirm('今日の開始点をリセットしますか？')) { saveTodayStart(); updateInputStats(); updatePreview(); } }

    function loadWritingTime() {
        const s = localStorage.getItem(WRITING_TIME_KEY);
        if (s) { try { const d = JSON.parse(s); if (d.date === getTodayDateStr()) { writingSeconds = d.seconds; return; } } catch (e) {} }
        writingSeconds = 0; saveWritingTime();
    }
    function saveWritingTime() { localStorage.setItem(WRITING_TIME_KEY, JSON.stringify({ date: getTodayDateStr(), seconds: writingSeconds })); }
    function formatTime(s) { return `${Math.floor(s/3600).toString().padStart(2,'0')}:${Math.floor((s%3600)/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
    function updateWritingTimeDisplay() {
        const t = formatTime(writingSeconds);
        document.getElementById('writing-time-display').textContent = `執筆時間: ${t}`;
        inputWritingTimeEl.textContent = settingsCache.writingTracker ? `⏱${t}` : '';
    }
    function startWritingTimer() {
        if (writingTimerInterval) return;
        writingTimerInterval = setInterval(() => { if (Date.now() - lastInputTime < 5000) { writingSeconds++; updateWritingTimeDisplay(); if (writingSeconds % 30 === 0) saveWritingTime(); } }, 1000);
    }

    function loadBookmarks() { const s = localStorage.getItem(BOOKMARKS_KEY); if (s) { try { bookmarks = JSON.parse(s); } catch (e) { bookmarks = []; } } renderBookmarks(); }
    function saveBookmarks() { localStorage.setItem(BOOKMARKS_KEY, JSON.stringify(bookmarks)); }
    function addBookmark() {
        const pos = inputArea.selectionStart, text = inputArea.value;
        const lineStart = text.lastIndexOf('\n', pos - 1) + 1, lineEnd = text.indexOf('\n', pos);
        const lineText = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd).trim();
        const preview = lineText.substring(0, 30) + (lineText.length > 30 ? '...' : '');
        const lineNum = (text.substring(0, pos).match(/\n/g) || []).length + 1;
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        bookmarks.push({ pos, lineNum, preview, created: Date.now(), tabId: activeTabId, tabName: currentTab?.name || '' });
        saveBookmarks();
        renderBookmarks();
    }
    function deleteBookmark(i) { bookmarks.splice(i, 1); saveBookmarks(); renderBookmarks(); }
    function jumpToBookmark(pos, tabId) {
        if (tabId && tabId !== activeTabId) {
            switchTab(tabId);
        }
        inputArea.focus();
        inputArea.setSelectionRange(pos, pos);
        setTimeout(() => scrollToCursorPosition(pos), 100);
        updateCursorLineDisplay();
    }
    function toggleAllBookmarks() {
        const checked = document.getElementById('bookmark-select-all').checked;
        document.querySelectorAll('.bookmark-checkbox').forEach(cb => cb.checked = checked);
    }
    function deleteSelectedBookmarks() {
        const checkboxes = document.querySelectorAll('.bookmark-checkbox:checked');
        if (checkboxes.length === 0) return;
        if (!confirm(`${checkboxes.length}件のブックマークを削除しますか？`)) return;
        const indices = Array.from(checkboxes).map(cb => parseInt(cb.dataset.index)).sort((a, b) => b - a);
        indices.forEach(i => bookmarks.splice(i, 1));
        saveBookmarks(); renderBookmarks();
        document.getElementById('bookmark-select-all').checked = false;
    }
    function renderBookmarks() {
        const l = document.getElementById('bookmark-list'); l.innerHTML = '';
        const actions = document.getElementById('bookmark-actions');
        if (bookmarks.length === 0) { l.innerHTML = '<div class="outline-empty">ブックマークがありません</div>'; actions.style.display = 'none'; return; }
        actions.style.display = 'block';
        bookmarks.forEach((b, i) => {
            const tabName = b.tabName || inputTabs.find(t => t.id === b.tabId)?.name || '';
            const tabLabel = tabName ? `【${escapeHtml(tabName)}】` : '';
            const d = document.createElement('div');
            d.className = 'bookmark-item';
            d.innerHTML = `<input type="checkbox" class="bookmark-checkbox" data-index="${i}" style="margin-right:6px;"><span class="bookmark-text" onclick="jumpToBookmark(${b.pos}, ${b.tabId || activeTabId})">📍 ${tabLabel}${b.lineNum}行目: ${escapeHtml(b.preview)}</span><span class="bookmark-delete" onclick="deleteBookmark(${i})">✕</span>`;
            l.appendChild(d);
        });
    }

    // 設定エクスポート/インポート
    function collectAllSettings() {
        return {
            version: '3.5',
            input: { size: document.getElementById('st-in-size').value, line: document.getElementById('st-in-line').value, font: document.getElementById('st-in-font').value, vertical: document.getElementById('st-in-v').checked },
            preview: { size: document.getElementById('st-pv-size').value, line: document.getElementById('st-pv-line').value, font: document.getElementById('st-pv-font').value, vertical: document.getElementById('st-pv-v').checked },
            display: { showSpace: document.getElementById('st-show-space').checked, showHighlight: document.getElementById('st-show-highlight').checked, showInput: document.getElementById('check-show-input').checked, showPreview: document.getElementById('check-show-preview').checked, defaultPreviewHidden: document.getElementById('st-default-preview-hidden').checked },
            writing: { typewriter: document.getElementById('st-typewriter-mode').checked, tracker: document.getElementById('st-writing-tracker').checked },
            goal: { chars: document.getElementById('st-goal-chars').value, today: document.getElementById('st-today-goal').value, showReading: document.getElementById('st-show-reading-time').checked, celebrate: document.getElementById('st-celebrate-goal').checked },
            manuscript: { rows: document.getElementById('st-manuscript-rows').value, cols: document.getElementById('st-manuscript-cols').value, show: document.getElementById('st-show-manuscript').checked },
            open: { mode: document.querySelector('input[name="st-open-mode"]:checked')?.value || 'current' },
            autosave: { interval: document.getElementById('st-autosave-interval').value, enabled: document.getElementById('st-autosave-enabled').checked },
            theme: document.getElementById('st-theme-preset').value,
            divider: { width: document.getElementById('st-divider-width').value },
            paneWidths: {
                input: document.getElementById('st-pane-input-width').value,
                preview: document.getElementById('st-pane-preview-width').value,
                memo: document.getElementById('st-pane-memo-width').value,
                outline: document.getElementById('st-pane-outline-width').value
            },
            paneHeights: {
                input: document.getElementById('st-pane-input-height').value,
                preview: document.getElementById('st-pane-preview-height').value
            }
        };
    }
    function applyImportedSettings(s) {
        if (s.input) { document.getElementById('st-in-size').value = s.input.size || 17; document.getElementById('st-in-line').value = s.input.line || 1.7; document.getElementById('st-in-font').value = s.input.font || 'font-mincho'; document.getElementById('st-in-v').checked = s.input.vertical !== false; }
        if (s.preview) { document.getElementById('st-pv-size').value = s.preview.size || 17; document.getElementById('st-pv-line').value = s.preview.line || 1.7; document.getElementById('st-pv-font').value = s.preview.font || 'font-mincho'; document.getElementById('st-pv-v').checked = s.preview.vertical !== false; }
        if (s.display) {
            document.getElementById('st-show-space').checked = s.display.showSpace !== false;
            document.getElementById('st-show-highlight').checked = s.display.showHighlight !== false;
            document.getElementById('check-show-input').checked = s.display.showInput !== false;
            document.getElementById('check-show-preview').checked = s.display.showPreview !== false;
            document.getElementById('st-default-preview-hidden').checked = s.display.defaultPreviewHidden || false;
        }
        if (s.writing) { document.getElementById('st-typewriter-mode').checked = s.writing.typewriter || false; document.getElementById('st-writing-tracker').checked = s.writing.tracker !== false; }
        if (s.goal) { document.getElementById('st-goal-chars').value = s.goal.chars || 150000; document.getElementById('st-today-goal').value = s.goal.today || 2000; document.getElementById('st-show-reading-time').checked = s.goal.showReading !== false; document.getElementById('st-celebrate-goal').checked = s.goal.celebrate !== false; }
        if (s.manuscript) {
            document.getElementById('st-manuscript-rows').value = s.manuscript.rows || 34;
            document.getElementById('st-manuscript-cols').value = s.manuscript.cols || 42;
            document.getElementById('st-show-manuscript').checked = s.manuscript.show !== false;
        }
        if (s.open) {
            const openMode = s.open.mode || 'current';
            const openInput = document.querySelector(`input[name="st-open-mode"][value="${openMode}"]`);
            if (openInput) openInput.checked = true;
        }
        if (s.autosave) {
            const autosaveInterval = clampValue(parseInt(s.autosave.interval, 10) || 60, 5, 600);
            const autosaveEnabled = s.autosave.enabled === true;
            document.getElementById('st-autosave-interval').value = autosaveInterval;
            document.getElementById('st-autosave-enabled').checked = autosaveEnabled;
            settingsCache.autosaveInterval = autosaveInterval;
            settingsCache.autosaveEnabled = autosaveEnabled;
        }
        if (s.theme !== undefined) document.getElementById('st-theme-preset').value = s.theme;
        if (s.divider) document.getElementById('st-divider-width').value = s.divider.width || 2;
        if (s.paneWidths) {
            document.getElementById('st-pane-input-width').value = s.paneWidths.input || 520;
            document.getElementById('st-pane-preview-width').value = s.paneWidths.preview || 520;
            document.getElementById('st-pane-memo-width').value = s.paneWidths.memo || 260;
            document.getElementById('st-pane-outline-width').value = s.paneWidths.outline || 260;
        }
        if (s.paneHeights) {
            document.getElementById('st-pane-input-height').value = s.paneHeights.input || 520;
            document.getElementById('st-pane-preview-height').value = s.paneHeights.preview || 520;
        }
        applyAllSettings();
    }
    function exportSettings() {
        const s = collectAllSettings(); const blob = new Blob([JSON.stringify(s, null, 2)], { type: 'application/json' });
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `cc_editor_settings_${getTodayDateStr()}.json`;
        document.body.appendChild(a); a.click(); document.body.removeChild(a);
    }
    function importSettings(input) {
        const file = input.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = e => { try { const s = JSON.parse(e.target.result); applyImportedSettings(s); alert('設定をインポートしました。'); } catch (err) { alert('設定ファイルの読み込みに失敗しました。'); } input.value = ''; };
        reader.readAsText(file);
    }
    function saveSettingsToStorage() { localStorage.setItem(SETTINGS_KEY, JSON.stringify(collectAllSettings())); }
    function loadSettingsFromStorage() { const s = localStorage.getItem(SETTINGS_KEY); if (s) { try { applyImportedSettings(JSON.parse(s)); } catch (e) {} } }

    const defaultText = `　C-エディタ（使い方） v0.96

■ 0. タブ
・タブ名はダブルクリックでリネームできます
・タブはドラッグで並べ替えできます
・タブを右クリックで「複製／リネーム／閉じる」などのメニューが出ます

■ 1. 入力 → プレビュー（同期）
・📲 同期：入力内容をプレビューに反映（更新）し、カーソル行へ位置合わせします
・プレビューが閉じている時に同期を押すと、プレビューを開いてから同期します
・ショートカット：Ctrl+Shift+S（※同期と同じ動作）

■ 2. 閲覧（全タブ一括表示）
・👁 閲覧：全タブを結合して全画面表示します（区切り記号「◆」を表示）
・閲覧内検索：右上の検索欄で、閲覧内容を検索できます
・しおり：＋しおり で位置を保存／プルダウンからジャンプ
・終了：Esc か「↩ 元の画面に戻る」

■ 3. 検索（このタブ／全タブ）
・🔍 検索パネルで「このタブ／全タブ」を切り替えられます
・ヒット一覧：見つかった箇所を一覧表示し、クリックでその場所へジャンプします
・置換：
  ・置換：現在ヒットのみ
  ・全置換：件数を確認してから一括置換します（このタブ／全タブ）

■ 4. 挿入（記法）
・ルビ：｜漢字《かんじ》
  ・選択→「🈂️ 選択文字にルビ」で入力窓が開きます（Enterで確定、×で戻る）
・傍点：《《ここ》》
・強調：==強調==（挿入メニューから）

■ 5. 目次
・📑 目次：全タブから見出しを拾って一覧にします
・「設定＞目次抽出ルール」で、# や ■ などの抽出条件を変更できます

■ 6. 「今日」の基準時刻
・設定の「今日の開始時刻」で、00:00以外（例: 03:00）を指定できます
・今日の目標や「今日: +○○」の計算は、この時刻を基準にします

■ 7. 集中モード
・🧘 集中：集中表示に切り替えます
・集中中の一時表示：Ctrl+Shift+P（プレビュー）／M（メモ）／O（目次）

（このタブは初期化すると復元されます）
`;


    const sampleText = `虱
芥川龍之介

　　　　　　　Ⅰ

　元治《げんぢ》元年十一月二十六日、京都守護の任に当つてゐた、加州家の同勢は、折からの長州征伐に加はる為、国家老《くにがらう》の長｜大隅守《おほすみのかみ》を大将にして、大阪の安治川口《あぢかはぐち》から、船を出した。
　小頭《こがしら》は、佃久太夫《つくだきうだいふ》、山岸三十郎の二人で、佃組の船には白幟《しろのぼり》、山岸組の船には赤幟が立つてゐる。五百石積の金毘羅《こんぴら》船が、皆それぞれ、紅白の幟を風にひるがへして、川口を海へのり出した時の景色は、如何《いか》にも勇ましいものだつたさうである。
　しかし、その船へ乗組んでゐる連中は、中々勇ましがつてゐる所の騒ぎではない。第一どの船にも、一艘に、主従三十四人、船頭四人、併《あは》せて三十八人づつ乗組んでゐる。だから、船の中は、皆、身動きも碌《ろく》に出来ない程狭い。それから又、胴の間《ま》には、沢庵漬《たくあんづけ》を鰌桶《どぢやうをけ》へつめたのが、足のふみ所もない位、ならべてある。慣れない内は、その臭気を嗅ぐと、誰でもすぐに、吐き気を催した。最後に旧暦の十一月下旬だから、海上を吹いて来る風が、まるで身を切るやうに冷い。殊に日が暮れてからは、摩耶颪《まやおろし》なり水の上なり、流石《さすが》に北国生れの若侍も、多くは歯の根が合はないと云ふ始末であつた。
　その上、船の中には、虱《しらみ》が沢山ゐた。それも、着物の縫目にかくれてゐるなどと云ふ、生やさしい虱ではない。帆にもたかつてゐる。幟にもたかつてゐる。檣《ほばしら》にもたかつてゐる。錨《いかり》にもたかつてゐる。少し誇張して云へば、人間を乗せる為の船だか、虱を乗せる為の船だか、判然しない位である。勿論その位だから、着物には、何十匹となくたかつてゐる。さうして、それが人肌にさへさはれば、すぐに、いい気になつて、ちくちくやる。それも、五匹や十匹なら、どうにでも、せいとう［＃「せいとう」に傍点］のしやうがあるが、前にも云つた通り、白胡麻《しろごま》をふり撒いたやうに、沢山ゐるのだから、とても、とりつくすなどと云ふ事が出来る筈のものではない。だから、佃組と山岸組とを問はず、船中にゐる侍と云ふ侍の体は、悉《ことごと》く虱に食はれた痕《あと》で、まるで麻疹《はしか》［＃「麻疹」は底本では「痳疹」］にでも罹《かか》つたやうに、胸と云はず腹と云はず、一面に赤く腫れ上がつてゐた。
　しかし、いくら手のつけやうがないと云つても、そのまま打遣《うつちや》つて置くわけには、猶《なほ》行かない。そこで、船中の連中は、暇さへあれば、虱狩をやつた。上は家老から下は草履取《ざうりとり》まで、悉く裸になつて、随所にゐる虱をてんでに茶呑茶碗の中へ、取つては入れ、取つては入れするのである。大きな帆に内海の冬の日をうけた金毘羅船の中で、三十何人かの侍が、湯もじ一つに茶呑茶碗を持つて、帆綱の下、錨の陰と、一生懸命に虱ばかり、さがして歩いた時の事を想像すると、今日では誰しも滑稽だと云ふ感じが先に立つが、「必要」の前に、一切の事が真面目になるのは、維新以前と雖《いへど》も、今と別に変りはない。――そこで、一船の裸侍は、それ自身が大きな虱のやうに、寒いのを我慢して、毎日根気よく、そこここと歩きながら、丹念に板の間の虱ばかりつぶしてゐた。

　　　　　　　Ⅱ

　所が佃組の船に、妙な男が一人ゐた。これは森｜権之進《ごんのしん》と云ふ中老のつむじ曲りで、身分は七十俵五人｜扶持《ぶち》の御徒士《おかち》である。この男だけは不思議に、虱をとらない。とらないから、勿論、何処《どこ》と云はず、たかつてゐる。髷《まげ》ぶしへのぼつてゐる奴があるかと思ふと、袴腰のふちを渡つてゐる奴がある。それでも別段、気にかける容子《ようす》がない。
　ではこの男だけ、虱に食はれないのかと云ふと、又さうでもない。やはり外《ほか》の連中のやうに、体中｜金銭斑々《きんせんはんはん》とでも形容したらよからうと思ふ程、所まだらに赤くなつてゐる。その上、当人がそれを掻いてゐる所を見ると、痒《かゆ》くない訳でもないらしい。が、痒くつても何でも、一向平気で、すましてゐる。
　すましてゐるだけなら、まだいいが、外の連中が、せつせと虱狩をしてゐるのを見ると、必《かならず》わきからこんな事を云ふ。――
「とるなら、殺し召さるな。殺さずに茶碗へ入れて置けば、わしが貰うて進ぜよう。」
「貰うて、どうさつしやる？」同役の一人が、呆《あき》れた顔をして、かう尋ねた。
「貰うてか。貰へばわしが飼うておくまでぢや。」
　森は、恬然《てんぜん》として答へるのである。

　　　　　　　Ⅲ

　それから、その船の中では、森の真似をして、虱を飼ふ連中が出来て来た。

　　　　　　　Ⅳ

　［＃地から２字上げ］（大正五年三月）`;

    function confirmResetInput() {
        const first = confirm('入力を初期化しますが、よろしいですか？');
        if (!first) return;
        const second = confirm('本当に初期化します。全部消えますよ？');
        if (!second) return;
        resetInputToStartup();
    }

    function resetInputToStartup() {
        inputTabs = [
            { id: 1, name: 'タブはリネームできます', content: defaultText },
            { id: 2, name: '見本', content: sampleText }
        ];
        activeTabId = 1;
        nextTabId = 3;
        inputArea.value = defaultText;
        previewTabId = null;
        previewShowAll = false;
        bookmarks = [];
        todayStartChars = 0;
        writingSeconds = 0;
        memoTabs = [{ id: 1, name: 'メモ1', content: '' }];
        activeMemoTabId = 1;
        nextMemoTabId = 2;
        memoArea.value = '';
        setNovelTitle(DEFAULT_NOVEL_TITLE);
        autoSaveTarget = { handle: null, type: null, scope: 'current' };
        settingsCache.autosaveInterval = 60;
        setAutoSaveEnabled(false);
        document.getElementById('st-autosave-interval').value = 60;
        localStorage.removeItem(TABS_KEY);
        localStorage.removeItem(AUTOSAVE_KEY);
        localStorage.removeItem(TODAY_START_KEY);
        localStorage.removeItem(BOOKMARKS_KEY);
        localStorage.removeItem(MEMO_KEY);
        localStorage.removeItem(NOVEL_TITLE_KEY);
        sessionStorage.removeItem('cc_editor_session_started');
        document.getElementById('st-in-v').checked = true;
        document.getElementById('st-pv-v').checked = true;
        // 初期化時の既定レイアウト：横並び＆入力左
        layoutAxis = 'row';
        layoutReversed = false;
        applyLayoutState();
        saveLayoutSettings();
        applyInputSettings();
        applyPreviewSettings();
        document.getElementById('st-pane-memo-width').value = 260;
        document.getElementById('st-pane-outline-width').value = 260;

        resetPaneWidths();
        resetPaneHeights();
        setPaneSplitEqual();
        renderInputTabs();
        renderPreviewTabs();
        renderBookmarks();
        renderMemoTabs();
        updateInputStats();
        updateMemoCharCount();
        updatePreview();
        saveTabsToStorage();
        saveMemoTabs();
        saveWritingTime();
		applyDefaultStartupLayoutAfterReset();
		requestAnimationFrame(() => {
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
  if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
});

    }

    const AUTOSAVE_KEY = 'cc_editor_autosave';
    let autosaveTimerId = null;
    function persistLocalState() { saveTabsToStorage(); saveSettingsToStorage(); }
    function showAutoSaveToast() {
        const toast = document.getElementById('autosave-toast');
        if (!toast) return;
        toast.classList.add('show');
        clearTimeout(showAutoSaveToast._timer);
        showAutoSaveToast._timer = setTimeout(() => toast.classList.remove('show'), 1500);
    }
    function closeAutoSaveError() {
        const overlay = document.getElementById('autosave-error');
        if (overlay) overlay.classList.remove('show');
    }
    function showAutoSaveError() {
        const overlay = document.getElementById('autosave-error');
        if (overlay) overlay.classList.add('show');
    }
    function setAutoSaveEnabled(enabled) {
        settingsCache.autosaveEnabled = enabled;
        const checkbox = document.getElementById('st-autosave-enabled');
        if (checkbox) checkbox.checked = enabled;
        startAutoSaveTimer();
    }
    function buildHtmlExport(scope) {
        const v = document.getElementById('st-pv-v').checked;
        const fk = document.getElementById('st-pv-font').value;
        const fs = document.getElementById('st-pv-size').value;
        const lh = document.getElementById('st-pv-line').value;
        let htmlContent = '';
        if (scope === 'all') {
            const currentTab = inputTabs.find(t => t.id === activeTabId);
            if (currentTab) currentTab.content = inputArea.value;
            inputTabs.forEach((tab, idx) => {
                if (idx > 0) htmlContent += '<div style="page-break-before: always; margin-top: 40px;"></div>';
                htmlContent += `<h2 style="font-size: 1.5em; margin-bottom: 1em;">${escapeHtml(tab.name)}</h2>`;
                htmlContent += renderTextToHTML(tab.content);
            });
        } else {
            updatePreview();
            htmlContent = previewContent.innerHTML;
        }
        return `<!DOCTYPE html><html lang="ja"><head><meta charset="UTF-8"><title>${escapeHtml(getNovelBaseName())}</title><link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho&family=Noto+Sans+JP&display=swap" rel="stylesheet"><style>body{margin:40px;background:#fdfcf0;font-family:${fontMap[fk]};font-size:${fs}px;line-height:${lh};${v?'writing-mode:vertical-rl;min-height:100vh;':''}}ruby{ruby-align:space-between;}rt{font-size:0.5em;color:#555;}.bouten-ruby rt{font-size:0.8em;font-weight:bold;}.underline-text{text-decoration:underline;text-decoration-color:#dc2626;}.highlight-text{background:linear-gradient(transparent 60%,#fef08a 60%);}</style></head><body>${htmlContent}</body></html>`;
    }
    function getAutoSavePayload() {
        if (!autoSaveTarget.handle || !autoSaveTarget.type) return null;
        const scope = autoSaveTarget.scope || 'current';
        if (autoSaveTarget.type === 'html') {
            return { blob: new Blob([buildHtmlExport(scope)], { type: 'text/html' }) };
        }
        return { blob: new Blob([scope === 'all' ? getAllTabsContent() : getCurrentTabContent()], { type: 'text/plain' }) };
    }
    async function autoSave() {
        if (!settingsCache.autosaveEnabled) return;
        persistLocalState();
        if (!autoSaveTarget.handle) {
            showAutoSaveError();
            setAutoSaveEnabled(false);
            return;
        }
        const payload = getAutoSavePayload();
        if (!payload) return;
        const handled = await saveWithHandle(autoSaveTarget.handle, payload.blob);
        if (handled) {
            showAutoSaveToast();
            return;
        }
        showAutoSaveError();
        setAutoSaveEnabled(false);
    }
    function startAutoSaveTimer() {
        if (autosaveTimerId) clearInterval(autosaveTimerId);
        if (!settingsCache.autosaveEnabled) return;
        const seconds = settingsCache.autosaveInterval || 60;
        autosaveTimerId = setInterval(autoSave, seconds * 1000);
    }
    function loadAutoSave() {
        // Try to load tabs first (new format)
        if (loadTabsFromStorage()) {
            renderInputTabs();
            return;
        }
        // Fallback: try old single-content format
        const s = localStorage.getItem(AUTOSAVE_KEY);
        if (s && s.length > 0 && s !== defaultText) {
            if (confirm('前回の自動保存データがあります。復元しますか？')) {
                inputTabs[0].content = s;
                inputArea.value = s;
            } else {
                inputArea.value = defaultText;
                inputTabs[0].content = defaultText;
            }
        } else {
            inputArea.value = defaultText;
            inputTabs[0].content = defaultText;
        }
        renderInputTabs();
    }
    startAutoSaveTimer();
    window.addEventListener('beforeunload', e => { persistLocalState(); saveWritingTime(); e.preventDefault(); e.returnValue = ''; });

    function undoInput() { inputArea.focus(); document.execCommand('undo'); }
    function redoInput() { inputArea.focus(); document.execCommand('redo'); }
    function getGoalColorClass(p) { if (p >= 100) return 'goal-100'; if (p >= 75) return 'goal-75-99'; if (p >= 50) return 'goal-50-74'; if (p >= 25) return 'goal-25-49'; return 'goal-0-24'; }

    // Celebration Functions
    function launchFireworks() {
        const overlay = document.getElementById('celebration-overlay');
        const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#1dd1a1'];
        const fireworkCount = 8;
        for (let f = 0; f < fireworkCount; f++) {
            setTimeout(() => {
                const x = Math.random() * window.innerWidth;
                const y = Math.random() * window.innerHeight * 0.6 + window.innerHeight * 0.1;
                const color = colors[Math.floor(Math.random() * colors.length)];
                // Trail
                const trail = document.createElement('div');
                trail.className = 'firework-trail';
                trail.style.left = x + 'px';
                trail.style.bottom = '0';
                trail.style.background = color;
                trail.style.setProperty('--rise', `-${window.innerHeight - y}px`);
                overlay.appendChild(trail);
                setTimeout(() => trail.remove(), 800);
                // Burst
                setTimeout(() => {
                    const particleCount = 20;
                    for (let i = 0; i < particleCount; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'firework';
                        particle.style.left = x + 'px';
                        particle.style.top = y + 'px';
                        particle.style.background = color;
                        const angle = (i / particleCount) * Math.PI * 2;
                        const distance = 80 + Math.random() * 60;
                        const tx = Math.cos(angle) * distance;
                        const ty = Math.sin(angle) * distance;
                        particle.style.setProperty('--tx', tx + 'px');
                        particle.style.setProperty('--ty', ty + 'px');
                        overlay.appendChild(particle);
                        setTimeout(() => particle.remove(), 1500);
                    }
                }, 600);
            }, f * 200);
        }
    }

    function showCelebration(type) {
        if (!settingsCache.celebrateGoal) return;
        const msgEl = document.getElementById('celebration-message');
        const textEl = document.getElementById('celebration-text');
        const subEl = document.getElementById('celebration-sub');
        if (type === 'today') {
            textEl.textContent = 'やったね！今日の目標達成！';
            subEl.textContent = '今日も素晴らしい執筆でした！';
        } else if (type === 'total') {
            textEl.textContent = '🎊 おめでとう！全体目標達成！ 🎊';
            subEl.textContent = '大きな節目を達成しました！';
        }
        launchFireworks();
        msgEl.classList.add('show');
        setTimeout(() => msgEl.classList.remove('show'), 4000);
    }

    function checkGoalAchievement(todayWritten, todayGoal, totalWritten, totalGoal) {
        if (todayGoal > 0 && todayWritten >= todayGoal && !goalAchieved.today) {
            goalAchieved.today = true;
            setTimeout(() => showCelebration('today'), 300);
        }
        if (totalGoal > 0 && totalWritten >= totalGoal && !goalAchieved.total) {
            goalAchieved.total = true;
            setTimeout(() => showCelebration('total'), goalAchieved.today ? 4500 : 300);
        }
    }

    // Debounced preview update for performance
    function debouncedPreviewUpdate() {
        if (previewUpdateTimeout) clearTimeout(previewUpdateTimeout);
        previewUpdateTimeout = setTimeout(() => updatePreview(), 300);
    }

    function updateInputStats() {
        const t = inputArea.value, tl = t.replace(/[\n\r]/g, '').length, nl = t.replace(/[\n\s　]/g, '').length, ll = t.split('\n').length;
        charCountEl.innerText = `全体: ${tl}`; inputNetCountEl.innerText = `実質: ${nl}`; lineCountEl.innerText = `${ll} 行`;
        const g = settingsCache.goalChars;
        if (g > 0) { const p = Math.round((nl / g) * 100); inputGoalEl.innerText = `目標: ${nl}/${g} (${p}%)`; inputGoalEl.className = 'goal-display ' + getGoalColorClass(p); } else { inputGoalEl.innerText = ''; }
        const tg = settingsCache.todayGoal;
        let tw = 0;
        if (tg > 0) { tw = Math.max(0, nl - todayStartChars); const tp = Math.round((tw / tg) * 100); inputTodayGoalEl.innerText = `今日: ${tw}/${tg} (${tp}%)`; inputTodayGoalEl.className = tw >= tg ? 'today-goal achieved' : 'today-goal'; } else { inputTodayGoalEl.innerText = ''; }
        inputReadingEl.innerText = settingsCache.showReadingTime ? `約${Math.ceil(nl / 400)}分` : '';
        if (settingsCache.showManuscript) { const cpp = settingsCache.manuscriptRows * settingsCache.manuscriptCols; inputManuscriptEl.innerText = `原稿用紙: ${(nl / cpp).toFixed(1)}枚`; } else { inputManuscriptEl.innerText = ''; }
        updateCursorLineDisplay();
        // Check goal achievement
        checkGoalAchievement(tw, tg, nl, g);
        updateAllTabsStats();
    }
    function updateCursorLineDisplay() { const p = inputArea.selectionStart, c = (inputArea.value.substring(0, p).match(/\n/g) || []).length + 1; inputPosBar.innerText = `現在: ${c} 行目`; }

    function updateAllTabsStats() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;
        const allText = inputTabs.map(t => t.content || '').join('\n');
        const totalChars = allText.replace(/[\n\r]/g, '').length;
        const totalNet = allText.replace(/[\n\s　]/g, '').length;
        const totalLines = allText.split('\n').length;
        const display = `全タブ: ${totalChars}字 / ${totalLines}行`;
        const title = `全タブ: ${totalChars}字 / 実質 ${totalNet}字 / ${totalLines}行`;
        const inputTotal = document.getElementById('input-total-stats');
        const previewTotal = document.getElementById('preview-total-stats');
        if (inputTotal) {
            inputTotal.innerText = display;
            inputTotal.title = title;
        }
        if (previewTotal) {
            previewTotal.innerText = display;
            previewTotal.title = title;
        }
    }

    const quickInsertPopup = document.getElementById('quick-insert-popup');
    let lastSelectionRange = { start: 0, end: 0 };

    function showQuickInsertPopup() {
        const s = inputArea.selectionStart, e = inputArea.selectionEnd;
        if (s === e) { quickInsertPopup.classList.remove('show'); return; }
        lastSelectionRange = { start: s, end: e };
        const overlayRect = inputSelOverlay.getBoundingClientRect();
        const inputRect = inputArea.getBoundingClientRect();
const isVertical = inputArea.parentElement.classList.contains('vertical-mode');
const margin = 8;
const footerRect = document.querySelector('#pane-input .pane-footer')?.getBoundingClientRect();

        quickInsertPopup.classList.add('show');
        quickInsertPopup.style.visibility = 'hidden';
        const popupRect = quickInsertPopup.getBoundingClientRect();

let popupLeft;
let popupTop;

if (isVertical) {
    // 縦書き：選択範囲の左に出したいので、overlayRect.left を基準に左側へ
    popupLeft = overlayRect.left - popupRect.width - 12;
    // 位置は選択範囲の上端あたりに合わせる
    popupTop = overlayRect.top;
} else {
    // 横書き：選択範囲の上に中央寄せ（元のPR挙動）
    popupLeft = overlayRect.left + (overlayRect.width / 2) - (popupRect.width / 2);
    popupTop = overlayRect.top - popupRect.height - 8;
}

popupLeft = Math.min(Math.max(popupLeft, margin), window.innerWidth - popupRect.width - margin);
let maxTop = window.innerHeight - popupRect.height - margin;
if (footerRect) {
    maxTop = Math.min(maxTop, footerRect.top - popupRect.height - margin);
}
const minTop = inputRect.top + margin;
if (maxTop < minTop) maxTop = minTop;
popupTop = Math.min(Math.max(popupTop, minTop), maxTop);


        quickInsertPopup.style.top = `${popupTop}px`;
        quickInsertPopup.style.left = `${popupLeft}px`;
        quickInsertPopup.style.visibility = '';
    }

    function hideQuickInsertPopup() { quickInsertPopup.classList.remove('show'); }

    function quickInsertRuby() {
        const s = lastSelectionRange.start, e = lastSelectionRange.end;
        if (s === e) return;
        const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e);
        const rt = `｜${st}《》`;
        inputArea.value = b + rt + a;
        inputArea.setSelectionRange(s + st.length + 2, s + st.length + 2);
        inputArea.focus();
        updateInputStats();
        hideQuickInsertPopup();
    }

    function quickInsertBouten() {
        const s = lastSelectionRange.start, e = lastSelectionRange.end;
        if (s === e) return;
        const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e);
        const bt = `《《${st}》》`;
        inputArea.value = b + bt + a;
        inputArea.setSelectionRange(s + bt.length, s + bt.length);
        inputArea.focus();
        updateInputStats();
        hideQuickInsertPopup();
    }

    function quickAddBookmark() {
        const s = lastSelectionRange.start, e = lastSelectionRange.end;
        const pos = s;
        const text = inputArea.value;
        const lineStart = text.lastIndexOf('\n', pos - 1) + 1;
        const lineEnd = text.indexOf('\n', pos);
        const lineText = text.substring(lineStart, lineEnd === -1 ? text.length : lineEnd).trim();
        const preview = lineText.substring(0, 30) + (lineText.length > 30 ? '...' : '');
        const lineNum = (text.substring(0, pos).match(/\n/g) || []).length + 1;
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        bookmarks.push({ pos, lineNum, preview, created: Date.now(), tabId: activeTabId, tabName: currentTab?.name || '' });
        saveBookmarks();
        renderBookmarks();
        hideQuickInsertPopup();
    }

    document.addEventListener('selectionchange', () => {
        const a = document.activeElement;
        if (a === inputArea) {
            const s = inputArea.selectionStart, e = inputArea.selectionEnd;
            if (s !== e) {
                const t = inputArea.value.substring(s, e), c = t.replace(/[\n\r]/g, '').length, l = (t.match(/\n/g) || []).length + 1;
                inputSelOverlay.textContent = `選択: ${c}字 / ${l}行`;
                inputSelOverlay.classList.add('show');
                showQuickInsertPopup();
            } else {
                inputSelOverlay.classList.remove('show');
                hideQuickInsertPopup();
            }
            previewSelOverlay.classList.remove('show');
        }
        else if (previewScroll.contains(window.getSelection()?.anchorNode)) {
            const t = window.getSelection().toString();
            if (t.length > 0) {
                const c = t.replace(/[\n\r]/g, '').length, l = (t.match(/\n/g) || []).length + 1;
                previewSelOverlay.textContent = `選択: ${c}字 / ${l}行`;
                previewSelOverlay.classList.add('show');
            } else {
                previewSelOverlay.classList.remove('show');
            }
            inputSelOverlay.classList.remove('show');
            hideQuickInsertPopup();
        }
        else {
            inputSelOverlay.classList.remove('show');
            previewSelOverlay.classList.remove('show');
            hideQuickInsertPopup();
        }
    });

    previewScroll.addEventListener('scroll', () => {
        const v = document.getElementById('st-pv-v').checked; let p;
        if (v) {
            const sl = previewScroll.scrollLeft;
            const sw = previewScroll.scrollWidth - previewScroll.clientWidth;
            p = sw > 0 ? Math.round(Math.abs(sl) / sw * 100) : 0;
            // 縦書きは「上（先頭）=100%」になっていたので、表示だけ逆算する：先頭=0% / 末尾=100%
            p = 100 - p;
        } else {
            const st = previewScroll.scrollTop;
            const sh = previewScroll.scrollHeight - previewScroll.clientHeight;
            p = sh > 0 ? Math.round((st / sh) * 100) : 0;
        }
        p = Math.max(0, Math.min(100, p));
        previewPosBar.innerText = `位置: ${p}%`;
    });

    let previewTabId = null; // null = follow input, or specific tab id
    let previewShowAll = false;

    function renderPreviewTabs() {
        const container = document.getElementById('preview-tabs-container');
        if (!container) return;
        container.innerHTML = '';

        // Individual tabs only (removed "全タブ")
        inputTabs.forEach(tab => {
            const tabEl = document.createElement('div');
            const isActive = previewTabId === tab.id || (previewTabId === null && tab.id === activeTabId);
            tabEl.className = 'preview-tab' + (isActive ? ' active' : '');
            tabEl.textContent = tab.name;
            tabEl.onclick = () => { previewTabId = tab.id; renderPreviewTabs(); updatePreview(); };
            container.appendChild(tabEl);
        });
        updateTabScrollButtonsFor('preview-tabs-container');
    }

    function getPreviewContent() {
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;

        const targetId = previewTabId !== null ? previewTabId : activeTabId;
        const tab = inputTabs.find(t => t.id === targetId);
        return tab ? tab.content : inputArea.value;
    }

    function updatePreviewTabOptions() {
        renderPreviewTabs();
    }

    function updatePreview() {
        renderPreviewTabs();
        const t = getPreviewContent(), ss = settingsCache.showSpace, sh = settingsCache.showHighlight;
        let s = escapeHtml(t); if (sh) previewContent.classList.add('highlight-active'); else previewContent.classList.remove('highlight-active');
        const MZ = '\uE001', MH = '\uE002'; if (ss) { s = s.replace(/　/g, MZ).replace(/ /g, MH); }
        if (sh) { s = s.replace(/「(.*?)」/g, '<span class="bracket-blue">「$1」</span>').replace(/『(.*?)』/g, '<span class="bracket-green">『$1』</span>'); }
        s = s.replace(/｜([^《]+?)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>').replace(/([一-龠々〆ヵヶ]+)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>');
        s = s.replace(/《《(.+?)》》/g, (m, p) => { let r = ''; for (let c of p) r += `<ruby class="bouten-ruby">${c}<rt>・</rt></ruby>`; return r; });
        s = s.replace(/__(.+?)__/g, '<span class="underline-text">$1</span>').replace(/==(.+?)==/g, '<span class="highlight-text">$1</span>');
        if (sh) s = s.replace(/([―─]{2,}|…{2,})/g, '<span class="symbol-hl">$1</span>');
        if (ss) { s = s.split(MZ).join('<span class="space-zen">□</span>').split(MH).join('<span class="space-han">･</span>'); }
        s = s.replace(/\n/g, '<br>'); previewContent.innerHTML = s;
        const tl = t.replace(/[\n\r]/g, '').length, nl = t.replace(/[\n\s　｜《》]/g, '').length, ll = t.split('\n').length;
        pvTotalCountEl.innerText = `全体: ${tl}`; pvNetCountEl.innerText = `実質: ${nl}`; pvLineCountEl.innerText = `${ll} 行`;
        const g = settingsCache.goalChars; if (g > 0) { const p = Math.round((nl / g) * 100); pvGoalEl.innerText = `目標: ${nl}/${g} (${p}%)`; pvGoalEl.className = 'goal-display ' + getGoalColorClass(p); } else { pvGoalEl.innerText = ''; }
        const tg = settingsCache.todayGoal; if (tg > 0) { const tw = Math.max(0, nl - todayStartChars), tp = Math.round((tw / tg) * 100); pvTodayGoalEl.innerText = `今日: ${tw}/${tg} (${tp}%)`; pvTodayGoalEl.className = tw >= tg ? 'today-goal achieved' : 'today-goal'; } else { pvTodayGoalEl.innerText = ''; }
        pvReadingEl.innerText = settingsCache.showReadingTime ? `約${Math.ceil(nl / 400)}分` : '';
        if (settingsCache.showManuscript) { const cpp = settingsCache.manuscriptRows * settingsCache.manuscriptCols; pvManuscriptEl.innerText = `原稿用紙: ${(nl / cpp).toFixed(1)}枚`; } else { pvManuscriptEl.innerText = ''; }
        pvTimeEl.innerText = `更新: ${new Date().toLocaleTimeString('ja-JP', { hour12: false })}`;
    }

function syncPreviewPosition() {
  const previewPane = document.getElementById('pane-preview');

  // プレビューが閉じている時は、開いてから同期する
  if (previewPane && previewPane.classList.contains('hidden')) {
    // これが updatePreview() も呼ぶ
    if (typeof updatePreviewAndShow === 'function') updatePreviewAndShow();
    // DOM反映後に位置合わせ（2フレーム待つと安定します）
    requestAnimationFrame(() => requestAnimationFrame(() => syncPreviewPositionCore()));
    return;
  }
  syncPreviewPositionCore();
}

function syncPreviewPositionCore() {
  // ★同期ボタンを押した時だけ「内容」を同期する
  // （入力タブ → プレビュータブを合わせる）
  if (typeof previewTabId !== 'undefined') previewTabId = activeTabId;
  if (typeof renderPreviewTabs === 'function') renderPreviewTabs();
  if (typeof updatePreview === 'function') updatePreview();

  // ★ここから下は「位置（スクロール）同期」
  const start = inputArea.selectionStart;
  const end = inputArea.selectionEnd;
  const targetPos = start === end ? start : Math.floor((start + end) / 2);
  const lineNum = (inputArea.value.substring(0, targetPos).match(/\n/g) || []).length;

  const brs = previewContent.querySelectorAll('br');
  if (brs.length > 0) {
    const targetBr = brs[Math.min(lineNum, brs.length - 1)];
    if (targetBr) {
      targetBr.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      setTimeout(() => showPreviewSyncIndicator(targetBr), 60);
    }
  } else {
    previewScroll.scrollTop = 0;
    previewScroll.scrollLeft = 0;
    const indicator = document.getElementById('preview-sync-indicator');
    if (indicator) indicator.style.display = 'none';
  }

  const indicatorRect = getPreviewLineStartRect(lineNum);
  if (indicatorRect) {
    setTimeout(() => showPreviewSyncIndicator(indicatorRect), 60);
  } else {
    const indicator = document.getElementById('preview-sync-indicator');
    if (indicator) indicator.style.display = 'none';
  }
}



    function updatePreviewAndShow() {
        updatePreview();
        renderPreviewTabs();
        const previewPane = document.getElementById('pane-preview');
        if (previewPane.classList.contains('hidden')) {
            previewPane.classList.remove('hidden');
            document.getElementById('check-show-preview').checked = true;
            setPaneSplitEqual();
        }
    }

    function toggleInputWritingMode() {
        const inputToggle = document.getElementById('st-in-v');
        inputToggle.checked = !inputToggle.checked;
        applyInputSettings();
        saveSettingsToStorage();
    }

    function togglePreviewWritingMode() {
        const previewToggle = document.getElementById('st-pv-v');
        previewToggle.checked = !previewToggle.checked;
        applyPreviewSettings();
        saveSettingsToStorage();
    }

    // 縦横ボタンの表記を『次に切り替わる方向』で表示
    function updateWritingModeButtonLabels() {
        const inBtn = document.getElementById('btn-input-writing-mode');
        const pvBtn = document.getElementById('btn-preview-writing-mode');
        const inV = document.getElementById('st-in-v')?.checked;
        const pvV = document.getElementById('st-pv-v')?.checked;

        if (inBtn) inBtn.textContent = inV ? '横書きへ' : '縦書きへ';
        if (pvBtn) pvBtn.textContent = pvV ? '横書きへ' : '縦書きへ';
    }

    // ===== 閲覧（全タブをまとめて全画面表示） =====
    let readerVertical = true;

    function updateReaderWritingModeButtonLabel() {
        const btn = document.getElementById('btn-reader-writing-mode');
        if (!btn) return;
        btn.textContent = readerVertical ? '横書きへ' : '縦書きへ';
    }

    function applyReaderWritingModeClass() {
        const scroll = document.getElementById('reader-scroll');
        if (!scroll) return;
        if (readerVertical) scroll.classList.add('vertical-mode');
        else scroll.classList.remove('vertical-mode');
    }

    function renderReaderContent() {
        const contentEl = document.getElementById('reader-content');
        const scroll = document.getElementById('reader-scroll');
        if (!contentEl || !scroll) return;

        // 現在タブの内容を退避
        const currentTab = inputTabs.find(t => t.id === activeTabId);
        if (currentTab) currentTab.content = inputArea.value;

        // ハイライト設定
        if (settingsCache.showHighlight) contentEl.classList.add('highlight-active');
        else contentEl.classList.remove('highlight-active');

        let html = '';
        inputTabs.forEach((tab, idx) => {
            const name = tab.name || `タブ${idx+1}`;
            const marker = `◆ ${name}`;
            const body = renderTextToHTML(tab.content || '');
            html += `<div class="reader-section">` +
                    `<div class="reader-marker">${escapeHtml(marker)}</div>` +
                    `<div class="reader-text">${body}</div>` +
                    `</div>`;
        });

        contentEl.innerHTML = html;
        applyReaderWritingModeClass();

        // 先頭へ
        scroll.scrollTop = 0;
        scroll.scrollLeft = 0;
    }

    function openReaderView() {
        const overlay = document.getElementById('reader-overlay');
        if (!overlay) return;

        // 既定はプレビューの縦横設定に合わせる（閲覧だけで独立切替可能）
        const pvV = document.getElementById('st-pv-v');
        readerVertical = pvV ? !!pvV.checked : true;

        renderReaderContent();
        updateReaderWritingModeButtonLabel();

        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
    }

    function closeReaderView() {
        const overlay = document.getElementById('reader-overlay');
        if (!overlay) return;
        overlay.classList.remove('show');
        overlay.setAttribute('aria-hidden', 'true');
    }

    function toggleReaderWritingMode() {
        readerVertical = !readerVertical;
        applyReaderWritingModeClass();
        updateReaderWritingModeButtonLabel();
    }

const fontMap = { 'font-gothic': '"Noto Sans JP", sans-serif', 'font-mincho': '"Shippori Mincho", serif', 'font-old': '"Zen Old Mincho", serif', 'font-round': '"M PLUS Rounded 1c", sans-serif', 'font-brush': '"Yuji Syuku", serif' };
    function applyInputSettings() {
    const s = document.getElementById('st-in-size').value + 'px';
    const l = document.getElementById('st-in-line').value;
    const f = fontMap[document.getElementById('st-in-font').value];
    const v = document.getElementById('st-in-v').checked;

    inputArea.style.fontSize = s;
    inputArea.style.lineHeight = l;
    inputArea.style.fontFamily = f;
    inputMirror.style.fontSize = s;
    inputMirror.style.lineHeight = l;
    inputMirror.style.fontFamily = f;

    if (v) inputArea.parentElement.classList.add('vertical-mode');
    else inputArea.parentElement.classList.remove('vertical-mode');

    updateWritingModeButtonLabels();
}

function applyPreviewSettings() {
    const s = document.getElementById('st-pv-size').value + 'px';
    const l = document.getElementById('st-pv-line').value;
    const f = fontMap[document.getElementById('st-pv-font').value];
    const v = document.getElementById('st-pv-v').checked;

    previewContent.style.fontSize = s;
    previewContent.style.lineHeight = l;
    previewContent.style.fontFamily = f;

    if (v) previewScroll.classList.add('vertical-mode');
    else previewScroll.classList.remove('vertical-mode');

    updateWritingModeButtonLabels();
    updatePreview();
}

function applyDisplaySettings() {
        settingsCache.showSpace = document.getElementById('st-show-space').checked;
        settingsCache.showHighlight = document.getElementById('st-show-highlight').checked;
        settingsCache.defaultPreviewHidden = document.getElementById('st-default-preview-hidden').checked;
        const si = document.getElementById('check-show-input').checked, sp = document.getElementById('check-show-preview').checked;
        if (si) document.getElementById('pane-input').classList.remove('hidden'); else document.getElementById('pane-input').classList.add('hidden');
        if (sp) document.getElementById('pane-preview').classList.remove('hidden'); else document.getElementById('pane-preview').classList.add('hidden');
        adjustPaneWidthsOnVisibility();
        updatePreview();
    }
    function applyWritingSettings() { settingsCache.typewriterMode = document.getElementById('st-typewriter-mode').checked; settingsCache.writingTracker = document.getElementById('st-writing-tracker').checked; updateWritingTimeDisplay(); }
    function applyGoalSettings() { settingsCache.goalChars = parseInt(document.getElementById('st-goal-chars').value) || 0; settingsCache.todayGoal = parseInt(document.getElementById('st-today-goal').value) || 0; settingsCache.showReadingTime = document.getElementById('st-show-reading-time').checked; settingsCache.celebrateGoal = document.getElementById('st-celebrate-goal').checked; goalAchieved = { today: false, total: false }; updateInputStats(); updatePreview(); }
    function applyManuscriptSettings() {
        settingsCache.manuscriptRows = parseInt(document.getElementById('st-manuscript-rows').value) || 34;
        settingsCache.manuscriptCols = parseInt(document.getElementById('st-manuscript-cols').value) || 42;
        settingsCache.showManuscript = document.getElementById('st-show-manuscript').checked;
        updateInputStats();
        updatePreview();
    }
    function applyThemeSettings() { const t = document.getElementById('st-theme-preset').value; document.body.className = document.body.className.replace(/theme-\w+/g, '').trim(); if (t) document.body.classList.add(t); }
    function applyOpenSettings() { settingsCache.openMode = document.querySelector('input[name="st-open-mode"]:checked')?.value || 'current'; }
    function applyOpenSettingsAndSave() {
        applyOpenSettings();
        if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();
    }
    function applyDividerSettings() {
        const dividerWidthRaw = parseInt(document.getElementById('st-divider-width').value, 10);
        const dividerWidth = clampValue(dividerWidthRaw || 2, 1, 12);
        document.getElementById('st-divider-width').value = dividerWidth;
        document.documentElement.style.setProperty('--divider-size', `${dividerWidth}px`);
        document.documentElement.style.setProperty('--divider-hit-area', `${Math.max(10, dividerWidth + 8)}px`);
        localStorage.setItem(DIVIDER_WIDTH_KEY, String(dividerWidth));
    }
    function resetDividerWidth() {
        document.getElementById('st-divider-width').value = 2;
        applyDividerSettings();
    }
    function applyAutoSaveSettings(skipConfirm = false) {
        const input = document.getElementById('st-autosave-interval');
        const checkbox = document.getElementById('st-autosave-enabled');
        if (!input || !checkbox) return;
        const secondsRaw = parseInt(input.value, 10);
        const seconds = clampValue(secondsRaw || 60, 5, 600);
        input.value = seconds;
        settingsCache.autosaveInterval = seconds;
        const enableAutoSave = checkbox.checked;
        if (enableAutoSave && !settingsCache.autosaveEnabled && !skipConfirm) {
            const confirmed = confirm('自動保存をオンにすると、指定したフォルダーに保存が続きますがよろしいですか？');
            if (!confirmed) {
                checkbox.checked = false;
                settingsCache.autosaveEnabled = false;
                return;
            }
        }
        settingsCache.autosaveEnabled = enableAutoSave;
        startAutoSaveTimer();
    }
    function applyPaperSettings() { applyManuscriptSettings(); applyThemeSettings(); }
    function applyAllSettings() { applyInputSettings(); applyPreviewSettings(); applyDisplaySettings(); applyWritingSettings(); applyGoalSettings();
        updateWritingModeButtonLabels(); applyManuscriptSettings(); applyThemeSettings(); applyOpenSettings(); applyPaneWidthSettings(); applyPaneHeightSettings(); applyDividerSettings(); applyAutoSaveSettings(true); }

    function resetAllSettings() {
        if (!confirm('全ての設定を初期状態に戻しますか？')) return;
        // Reset to defaults
        document.getElementById('st-in-size').value = 17;
        document.getElementById('st-in-line').value = 1.7;
        document.getElementById('st-in-font').value = 'font-gothic';
        document.getElementById('st-in-v').checked = true;
        document.getElementById('st-pv-size').value = 17;
        document.getElementById('st-pv-line').value = 1.7;
        document.getElementById('st-pv-font').value = 'font-gothic';
        document.getElementById('st-pv-v').checked = true;
        document.getElementById('check-show-input').checked = true;
        document.getElementById('check-show-preview').checked = true;
        document.getElementById('st-show-space').checked = true;
        document.getElementById('st-show-highlight').checked = true;
        document.getElementById('st-default-preview-hidden').checked = false;
        document.getElementById('st-typewriter-mode').checked = false;
        document.getElementById('st-writing-tracker').checked = true;
        document.getElementById('st-goal-chars').value = 150000;
        document.getElementById('st-today-goal').value = 2000;
        document.getElementById('st-celebrate-goal').checked = true;
        document.getElementById('st-show-reading-time').checked = true;
        document.getElementById('st-manuscript-rows').value = 34;
        document.getElementById('st-manuscript-cols').value = 42;
        document.getElementById('st-show-manuscript').checked = true;
        document.querySelector('input[name="st-open-mode"][value="current"]').checked = true;
        document.getElementById('st-autosave-interval').value = 60;
        document.getElementById('st-autosave-enabled').checked = false;
        document.getElementById('st-theme-preset').value = '';
        document.getElementById('st-pane-input-width').value = 520;
        document.getElementById('st-pane-preview-width').value = 520;
        document.getElementById('st-pane-memo-width').value = 260;
        document.getElementById('st-pane-outline-width').value = 260;
        document.getElementById('st-divider-width').value = 2;
const inputH = document.getElementById('st-pane-input-height');
const previewH = document.getElementById('st-pane-preview-height');
if (inputH) inputH.value = 520;
if (previewH) previewH.value = 520;

        applyAllSettings();
        autoSaveTarget = { handle: null, type: null, scope: 'current' };
        setAutoSaveEnabled(false);
        resetPaneWidths();
        resetPaneHeights();
        localStorage.removeItem(DIVIDER_WIDTH_KEY);
        localStorage.removeItem(SETTINGS_KEY);
    }

    function clampValue(value, min, max) {
        if (Number.isNaN(value)) return min;
        return Math.max(min, Math.min(max, value));
    }

    function applyDockedPanelWidths() {
        const memoWidthRaw = parseInt(document.getElementById('st-pane-memo-width').value);
        const outlineWidthRaw = parseInt(document.getElementById('st-pane-outline-width').value);
        const memoWidth = clampValue(memoWidthRaw || 260, 160, 2000);
        const outlineWidth = clampValue(outlineWidthRaw || 260, 160, 2000);
        const memoPanel = document.getElementById('memo-panel');
        const outlinePanel = document.getElementById('outline-panel');

        document.getElementById('st-pane-memo-width').value = memoWidth;
        document.getElementById('st-pane-outline-width').value = outlineWidth;

        memoPanel.style.width = `${memoWidth}px`;
        memoPanel.style.flexBasis = `${memoWidth}px`;
        outlinePanel.style.width = `${outlineWidth}px`;
        outlinePanel.style.flexBasis = `${outlineWidth}px`;

        localStorage.setItem(PANE_WIDTH_KEYS.memo, memoWidth);
        localStorage.setItem(PANE_WIDTH_KEYS.outline, outlineWidth);
    }

    function applyPaneWidthSettings() {
        const inputWidthEl = document.getElementById('st-pane-input-width');
        const previewWidthEl = document.getElementById('st-pane-preview-width');

        if (!inputWidthEl || !previewWidthEl) return;

        const inputWidth = clampValue(parseInt(inputWidthEl.value, 10) || 520, 120, 3000);
        const previewWidth = clampValue(parseInt(previewWidthEl.value, 10) || 520, 120, 3000);

        inputWidthEl.value = inputWidth;
        previewWidthEl.value = previewWidth;

        localStorage.setItem(PANE_WIDTH_KEYS.input, inputWidth);
        localStorage.setItem(PANE_WIDTH_KEYS.preview, previewWidth);

        applyDockedPanelWidths();
        adjustPaneWidthsOnVisibility();
        updateDockSplitState();
    }

	function applyPaneHeightSettings() {
    const inputHeightEl = document.getElementById('st-pane-input-height');
    const previewHeightEl = document.getElementById('st-pane-preview-height');
    const inputPane = document.getElementById('pane-input');
    const previewPane = document.getElementById('pane-preview');

    // 必要な要素が無いなら何もしない（落ちないように）
    if (!inputHeightEl || !previewHeightEl || !inputPane || !previewPane) return;

    const inputHeightRaw = parseInt(inputHeightEl.value, 10);
    const previewHeightRaw = parseInt(previewHeightEl.value, 10);

    const inputHeight = clampValue(inputHeightRaw || 520, 160, 2000);
    const previewHeight = clampValue(previewHeightRaw || 520, 160, 2000);

    inputHeightEl.value = inputHeight;
    previewHeightEl.value = previewHeight;

    if (document.body.classList.contains('scroll-mode')) {
        inputPane.style.height = `${inputHeight}px`;
        previewPane.style.height = `${previewHeight}px`;
    } else {
        inputPane.style.height = '';
        previewPane.style.height = '';
    }

    localStorage.setItem(PANE_HEIGHT_KEYS.input, String(inputHeight));
    localStorage.setItem(PANE_HEIGHT_KEYS.preview, String(previewHeight));

    if (typeof adjustPaneHeightsOnVisibility === 'function') {
        adjustPaneHeightsOnVisibility();
    }
}

function resetPaneWidths() {
    document.getElementById('st-pane-input-width').value = 520;
    document.getElementById('st-pane-preview-width').value = 520;
    document.getElementById('st-pane-memo-width').value = 260;
    document.getElementById('st-pane-outline-width').value = 260;

    localStorage.removeItem(PANE_WIDTH_KEYS.input);
    localStorage.removeItem(PANE_WIDTH_KEYS.preview);
    localStorage.removeItem(PANE_WIDTH_KEYS.memo);
    localStorage.removeItem(PANE_WIDTH_KEYS.outline);
    localStorage.removeItem(PANE_WIDTH_KEYS.legacyInput);
    localStorage.removeItem(PANE_WIDTH_KEYS.legacyPreview);

    applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
}

function resetPaneHeights() {
    const inputHeightEl = document.getElementById('st-pane-input-height');
    const previewHeightEl = document.getElementById('st-pane-preview-height');

    if (inputHeightEl) inputHeightEl.value = 520;
    if (previewHeightEl) previewHeightEl.value = 520;

    localStorage.removeItem(PANE_HEIGHT_KEYS.input);
    localStorage.removeItem(PANE_HEIGHT_KEYS.preview);

    if (typeof applyPaneHeightSettings === 'function') {
        applyPaneHeightSettings();
    }
}

function updateDockSplitState() {
    const c = document.getElementById('main-container');
    if (!c) return;
    const memoDocked = c.classList.contains('memo-docked');
    const outlineDocked = c.classList.contains('outline-docked');
    const memoRight = c.classList.contains('memo-right');
    const outlineLeft = c.classList.contains('outline-left');
    const splitRight = memoDocked && outlineDocked && memoRight && !outlineLeft;
    const splitLeft = memoDocked && outlineDocked && !memoRight && outlineLeft;
    c.classList.toggle('dock-split-right', splitRight);
    c.classList.toggle('dock-split-left', splitLeft);
}

    function loadPaneWidthSettings() {
        const mainContainer = document.getElementById('main-container');
        const containerWidth = mainContainer.getBoundingClientRect().width || 1000;
        const legacyInput = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.legacyInput), 10);
        const legacyPreview = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.legacyPreview), 10);
        const inputWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.input), 10);
        const previewWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.preview), 10);
        const memoWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.memo), 10);
        const outlineWidth = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.outline), 10);

        if (inputWidth || legacyInput) {
            const converted = inputWidth || Math.round(containerWidth * (legacyInput / 100));
            document.getElementById('st-pane-input-width').value = converted;
        }
        if (previewWidth || legacyPreview) {
            const converted = previewWidth || Math.round(containerWidth * (legacyPreview / 100));
            document.getElementById('st-pane-preview-width').value = converted;
        }
        if (memoWidth) {
            document.getElementById('st-pane-memo-width').value = memoWidth;
        }
        if (outlineWidth) {
            document.getElementById('st-pane-outline-width').value = outlineWidth;
        }
    }

    function loadDividerSettings() {
        const dividerWidth = parseInt(localStorage.getItem(DIVIDER_WIDTH_KEY), 10);
        if (Number.isFinite(dividerWidth)) {
            document.getElementById('st-divider-width').value = dividerWidth;
        }
        applyDividerSettings();
    }

	function loadPaneHeightSettings() {
    const inputHeightEl = document.getElementById('st-pane-input-height');
    const previewHeightEl = document.getElementById('st-pane-preview-height');

    // UIが無いなら何もしない（落ちないように）
    if (!inputHeightEl || !previewHeightEl) return;

    const inputHeight = parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.input), 10);
    const previewHeight = parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.preview), 10);

    if (Number.isFinite(inputHeight)) inputHeightEl.value = inputHeight;
    if (Number.isFinite(previewHeight)) previewHeightEl.value = previewHeight;

    if (typeof applyPaneHeightSettings === 'function') {
        applyPaneHeightSettings();
    }
}

    const pinnedPanels = new Set();
    function updateControlPanelScrollState() {
        const hasOpen = document.querySelectorAll('.control-panel.open').length > 0;
        document.body.classList.toggle('allow-scroll', hasOpen);
        updateDockTopOffset();
    }
    function getPanelStateIcon(isOpen, isPinned) {
        if (isPinned) return '📌';
        if (isOpen) return '▾';
        return '▾';
    }
    function updateControlPanelButton(panelId, btnId) {
        const panel = document.getElementById(panelId);
        const btn = document.getElementById(btnId);
        if (!panel || !btn) return;
        const iconEl = btn.querySelector('.panel-state-icon');
        if (iconEl) iconEl.textContent = getPanelStateIcon(panel.classList.contains('open'), pinnedPanels.has(panelId));
    }
    function updateDockPanelButton(panelId, btnId, dockCheckboxId) {
        const panel = document.getElementById(panelId);
        const btn = document.getElementById(btnId);
        const dockCheckbox = document.getElementById(dockCheckboxId);
        if (!panel || !btn || !dockCheckbox) return;
        const iconEl = btn.querySelector('.panel-state-icon');
        if (iconEl) iconEl.textContent = getPanelStateIcon(panel.classList.contains('open'), dockCheckbox.checked);
    }
    function updatePanelButtonStates() {
        updateControlPanelButton('help-bar', 'btn-toggle-help');
        updateControlPanelButton('search-bar', 'btn-toggle-search');
        updateControlPanelButton('settings-bar', 'btn-toggle-settings');
        updateDockPanelButton('memo-panel', 'btn-toggle-memo', 'check-memo-dock');
        updateDockPanelButton('outline-panel', 'btn-toggle-outline', 'check-outline-dock');
    }
    function togglePanel(id) {
        const p = document.getElementById(id);
        const btn = document.querySelector(`#${id} .panel-pin-btn`);
        if (p.classList.contains('open')) {
            if (pinnedPanels.has(id)) {
                // If pinned, unpin and close
                pinnedPanels.delete(id);
                if (btn) btn.classList.remove('pinned');
                p.classList.remove('open');
            } else {
                // If open but not pinned, pin it
                pinnedPanels.add(id);
                if (btn) btn.classList.add('pinned');
            }
        } else {
            // Close non-pinned panels
            document.querySelectorAll('.control-panel.open').forEach(x => {
                if (!pinnedPanels.has(x.id) && x.id !== id) x.classList.remove('open');
            });
            p.classList.add('open');
            if (id === 'search-bar') setTimeout(() => document.getElementById('search-input').focus(), 100);
        }
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }
    function closeControlPanel(id) {
        const p = document.getElementById(id);
        const btn = document.querySelector(`#${id} .panel-pin-btn`);
        if (!p) return;
        p.classList.remove('open');
        pinnedPanels.delete(id);
        if (btn) btn.classList.remove('pinned');
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }
    function togglePanelPin(id) {
        const btn = document.querySelector(`#${id} .panel-pin-btn`);
        if (pinnedPanels.has(id)) {
            pinnedPanels.delete(id);
            btn.classList.remove('pinned');
        } else {
            pinnedPanels.add(id);
            btn.classList.add('pinned');
        }
        updateControlPanelScrollState();
        updatePanelButtonStates();
    }
    function updateDockTopOffset() {
        const header = document.querySelector('header');
        const controls = document.querySelector('.controls-wrapper');
        const padding = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--layout-padding')) || 0;
        const headerHeight = header ? header.getBoundingClientRect().height : 0;
        const controlsHeight = controls ? controls.getBoundingClientRect().height : 0;
        const top = Math.round(headerHeight + controlsHeight + padding);
        document.documentElement.style.setProperty('--dock-top', `${top}px`);
    }
    // Close non-pinned panels on outside click
    document.addEventListener('click', e => {
        if (e.target.closest('.control-panel') || e.target.closest('.btn') || e.target.closest('.dropdown')) return;
        document.querySelectorAll('.control-panel.open').forEach(p => {
            if (!pinnedPanels.has(p.id)) p.classList.remove('open');
        });
        updateControlPanelScrollState();
        updatePanelButtonStates();
    });
    // Close non-docked memo/outline on outside click
    document.addEventListener('click', e => {
        // パネル操作中（タブクリック等）に誤って閉じないようにする
        if (window.memoInteracting || window.outlineInteracting) return;
        if (e.target.closest('#memo-panel') || e.target.closest('#outline-panel')) return;
        if (e.target.closest('#btn-toggle-memo') || e.target.closest('#btn-toggle-outline')) return;
        if (e.target.closest('#resizer-memo') || e.target.closest('#resizer-outline')) return;
        const mainContainer = document.getElementById('main-container');
        if (!mainContainer.classList.contains('memo-docked')) {
            document.getElementById('memo-panel').classList.remove('open');
        }
        if (!mainContainer.classList.contains('outline-docked')) {
            document.getElementById('outline-panel').classList.remove('open');
        }
        updatePanelButtonStates();
    });
    function hidePane(t) {
        if (t === 'input') {
            document.getElementById('check-show-input').checked = false;
            document.getElementById('pane-input').classList.add('hidden');
        } else if (t === 'preview') {
            document.getElementById('check-show-preview').checked = false;
            document.getElementById('pane-preview').classList.add('hidden');
        }
        adjustPaneWidthsOnVisibility();
    }

    function adjustPaneWidthsOnVisibility() {
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');
        if (document.body.classList.contains('scroll-mode')) {
            inputPane.style.flex = '1 1 auto';
            previewPane.style.flex = '1 1 auto';
            inputPane.style.width = '100%';
            previewPane.style.width = '100%';
if (typeof adjustPaneHeightsOnVisibility === 'function') {
    adjustPaneHeightsOnVisibility();
}

            return;
        }
        const inputHidden = inputPane.classList.contains('hidden');
        const previewHidden = previewPane.classList.contains('hidden');
        if (inputHidden && !previewHidden) {
            previewPane.style.flex = '1 1 auto';
            previewPane.style.width = '100%';
        } else if (!inputHidden && previewHidden) {
            inputPane.style.flex = '1 1 auto';
            inputPane.style.width = '100%';
        } else if (!inputHidden && !previewHidden) {
            const savedInput = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.input)) || parseInt(document.getElementById('st-pane-input-width').value) || 520;
            const savedPreview = parseInt(localStorage.getItem(PANE_WIDTH_KEYS.preview)) || parseInt(document.getElementById('st-pane-preview-width').value) || 520;
            inputPane.style.flex = `1 1 ${savedInput}px`;
            previewPane.style.flex = `1 1 ${savedPreview}px`;
            inputPane.style.width = `${savedInput}px`;
            previewPane.style.width = `${savedPreview}px`;
        }
    }

    function adjustPaneHeightsOnVisibility() {
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');
        const inputHeightEl = document.getElementById('st-pane-input-height');
        const previewHeightEl = document.getElementById('st-pane-preview-height');

        // 必要な要素が無いなら何もしない（落ちないように）
        if (!inputPane || !previewPane || !inputHeightEl || !previewHeightEl) return;

        if (!document.body.classList.contains('scroll-mode')) {
            inputPane.style.height = '';
            previewPane.style.height = '';
            return;
        }

        const inputHidden = inputPane.classList.contains('hidden');
        const previewHidden = previewPane.classList.contains('hidden');

        const inputHeight =
            parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.input), 10) ||
            parseInt(inputHeightEl.value, 10) ||
            520;

        const previewHeight =
            parseInt(localStorage.getItem(PANE_HEIGHT_KEYS.preview), 10) ||
            parseInt(previewHeightEl.value, 10) ||
            520;

        const combinedHeight = inputHeight + previewHeight;

        if (inputHidden && !previewHidden) {
            previewPane.style.height = `${combinedHeight}px`;
        } else if (!inputHidden && previewHidden) {
            inputPane.style.height = `${combinedHeight}px`;
        } else {
            inputPane.style.height = `${inputHeight}px`;
            previewPane.style.height = `${previewHeight}px`;
        }
    }
    function toggleDropdown(id) { document.getElementById(id).classList.toggle('show'); }
    document.addEventListener('click', e => { if (!e.target.closest('.dropdown')) document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); });

    function toggleFocusMode() { document.body.classList.toggle('focus-mode'); document.getElementById('btn-focus').classList.toggle('active'); if (document.body.classList.contains('focus-mode')) inputArea.focus(); }

    inputArea.addEventListener('keydown', e => {
        if (e.key === 'Enter' && !e.shiftKey && !e.ctrlKey && !e.altKey) {
            const p = inputArea.selectionStart, t = inputArea.value, ls = t.lastIndexOf('\n', p - 1) + 1, cl = t.substring(ls, p);
            if (cl.startsWith('　')) { e.preventDefault(); const b = t.substring(0, p), a = t.substring(inputArea.selectionEnd); inputArea.value = b + '\n　' + a; const np = p + 2; inputArea.setSelectionRange(np, np); updateInputStats(); if (settingsCache.typewriterMode) setTimeout(() => scrollToCursorPosition(np), 10); }
        }
    });
    inputArea.addEventListener('input', () => { lastInputTime = Date.now(); updateInputStats(); if (settingsCache.typewriterMode) scrollToCursorPosition(inputArea.selectionStart); });

    function insertText(t, o = 0) { const s = inputArea.selectionStart, e = inputArea.selectionEnd, b = inputArea.value.substring(0, s), a = inputArea.value.substring(e); inputArea.value = b + t + a; const np = s + t.length - o; inputArea.setSelectionRange(np, np); inputArea.focus(); updateInputStats(); document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); }
    function insertRubyToSelection() { const s = inputArea.selectionStart, e = inputArea.selectionEnd; if (s === e) { alert('ルビを付けたい文字を選択してください。'); return; } const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e), rt = `｜${st}《》`; inputArea.value = b + rt + a; inputArea.setSelectionRange(s + st.length + 2, s + st.length + 2); inputArea.focus(); updateInputStats(); document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); }
    function insertBoutenToSelection() { const s = inputArea.selectionStart, e = inputArea.selectionEnd; if (s === e) { alert('傍点を付けたい文字を選択してください。'); return; } const st = inputArea.value.substring(s, e), b = inputArea.value.substring(0, s), a = inputArea.value.substring(e), bt = `《《${st}》》`; inputArea.value = b + bt + a; inputArea.setSelectionRange(s + bt.length, s + bt.length); inputArea.focus(); updateInputStats(); document.querySelectorAll('.dropdown-content').forEach(d => d.classList.remove('show')); }
    function quickWrapSelection(left, right) {
        const s = inputArea.selectionStart, e = inputArea.selectionEnd;
        if (s === e) { alert('範囲を選択してください。'); return; }
        const st = inputArea.value.substring(s, e);
        const b = inputArea.value.substring(0, s);
        const a = inputArea.value.substring(e);
        const wrapped = `${left}${st}${right}`;
        inputArea.value = b + wrapped + a;
        inputArea.setSelectionRange(s + wrapped.length, s + wrapped.length);
        inputArea.focus();
        updateInputStats();
        hideQuickInsertPopup();
    }

    function scrollToCursorPosition(idx) {
        const t = inputArea.value, v = document.getElementById('st-in-v').checked, cs = window.getComputedStyle(inputArea);
        inputMirror.style.fontSize = cs.fontSize; inputMirror.style.lineHeight = cs.lineHeight; inputMirror.style.fontFamily = cs.fontFamily; inputMirror.style.width = inputArea.clientWidth + 'px'; inputMirror.style.height = inputArea.clientHeight + 'px';
        const tc = t.substring(0, idx), m = document.createElement('span'); m.textContent = '|'; inputMirror.innerHTML = ''; inputMirror.appendChild(document.createTextNode(tc)); inputMirror.appendChild(m);
        const mr = m.getBoundingClientRect(), mir = inputMirror.getBoundingClientRect(), mot = mr.top - mir.top + inputMirror.scrollTop, mol = mr.left - mir.left + inputMirror.scrollLeft;
        if (v) inputArea.scrollLeft = mol - (inputArea.clientWidth / 2); else inputArea.scrollTop = mot - (inputArea.clientHeight / 2);
    }


    function getPreviewLineStartRect(lineNum) {
        const brs = previewContent.querySelectorAll('br');
        const range = document.createRange();
        if (lineNum <= 0) {
            if (previewContent.firstChild) {
                range.setStart(previewContent.firstChild, 0);
                range.setEnd(previewContent.firstChild, 0);
            } else {
                return previewContent.getBoundingClientRect();
            }
        } else {
            const br = brs[Math.min(lineNum - 1, brs.length - 1)];
            if (!br) return null;
            range.setStartAfter(br);
            range.setEndAfter(br);
        }
        const rect = range.getClientRects()[0];
        return rect || range.getBoundingClientRect();
    }
    function showPreviewSyncIndicator(targetRect) {
        const indicator = document.getElementById('preview-sync-indicator');
        if (!indicator || !targetRect) return;
        const scrollRect = previewScroll.getBoundingClientRect();
        const offsetTop = targetRect.top - scrollRect.top + previewScroll.scrollTop;
        const offsetLeft = targetRect.left - scrollRect.left + previewScroll.scrollLeft;
        const isVertical = previewScroll.classList.contains('vertical-mode');
        if (isVertical) {
            indicator.textContent = '←';
            indicator.style.left = `${Math.max(8, offsetLeft - 20)}px`;
            indicator.style.top = `${Math.max(8, offsetTop - 4)}px`;
        } else {
            indicator.textContent = '↓';
            indicator.style.left = `${Math.max(8, offsetLeft - 4)}px`;
            indicator.style.top = `${Math.max(8, offsetTop - 24)}px`;
        }
        indicator.style.display = 'block';
        clearTimeout(showPreviewSyncIndicator._timer);
        showPreviewSyncIndicator._timer = setTimeout(() => {
            indicator.style.display = 'none';
        }, 1400);
    }

    let searchMatches = [], currentMatchIndex = -1;
    function doSearch() { const q = document.getElementById('search-input').value, t = inputArea.value; searchMatches = []; currentMatchIndex = -1; if (!q) { updateSearchInfo(); return; } const esc = q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), rx = new RegExp(esc, 'g'); let m; while ((m = rx.exec(t)) !== null) searchMatches.push({ start: m.index, end: m.index + m[0].length }); if (searchMatches.length > 0) { currentMatchIndex = 0; jumpToMatch(); } updateSearchInfo(); }
    function updateSearchInfo() { const i = document.getElementById('search-match-info'); if (searchMatches.length === 0) { i.innerText = '0 / 0'; i.style.color = '#999'; } else { i.innerText = `${currentMatchIndex + 1} / ${searchMatches.length}`; i.style.color = '#15803d'; } }
    function findNext() { if (searchMatches.length === 0) doSearch(); else { currentMatchIndex = (currentMatchIndex + 1) % searchMatches.length; jumpToMatch(); updateSearchInfo(); } }
    function findPrev() { if (searchMatches.length === 0) doSearch(); else { currentMatchIndex = (currentMatchIndex - 1 + searchMatches.length) % searchMatches.length; jumpToMatch(); updateSearchInfo(); } }
    function jumpToMatch() { const m = searchMatches[currentMatchIndex]; if (!m) return; inputArea.focus(); inputArea.setSelectionRange(m.start, m.end); scrollToCursorPosition(m.start); updateCursorLineDisplay(); }
    function replaceOne() { if (currentMatchIndex < 0) findNext(); if (currentMatchIndex < 0) return; const r = document.getElementById('replace-input').value, m = searchMatches[currentMatchIndex]; inputArea.setRangeText(r, m.start, m.end, 'select'); doSearch(); jumpToMatch(); }
    function replaceAll() { const q = document.getElementById('search-input').value, r = document.getElementById('replace-input').value; if (!q) return; inputArea.value = inputArea.value.split(q).join(r); updateInputStats(); }


    // Memo Pane with Tabs
    const MEMO_KEY = 'cc_editor_memo_tabs';
    const memoArea = document.getElementById('memo-area');
    const memoCharCount = document.getElementById('memo-char-count');
    let memoTabs = [{ id: 1, name: 'メモ1', content: '' }];
    let activeMemoTabId = 1;
    let nextMemoTabId = 2;
    let draggingMemoTabId = null;


function toggleMemoPanel() {
  const panel = document.getElementById('memo-panel');
  const checkbox = document.getElementById('check-memo-dock');

  if (!panel) return;
  if (!checkbox) {
    console.error('check-memo-dock が見つかりません（HTMLに追加したか確認してください）');
    return;
  }

  const isOpen = panel.classList.contains('open');
  const isDocked = checkbox.checked;

  // ★ここで「何が起きるか」を出す
  console.log('toggleMemoPanel', { isOpen, isDocked });
  console.trace();

  // ↓ここから下は元の処理のまま
  if (!isOpen) {
    panel.classList.add('open');
    if (isDocked) {
      checkbox.checked = false;
      toggleMemoDock();
    }
  } else if (!isDocked) {
    checkbox.checked = true;
    toggleMemoDock();
    panel.classList.add('open');
  } else {
    checkbox.checked = false;
    toggleMemoDock();
    panel.classList.remove('open');
  }

  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
  if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
}



function closeMemoPanel(force = false) {
  console.log('closeMemoPanel called', { force });
  console.trace(); // ←呼び出し元の履歴が出る
  const c = document.getElementById('main-container');
  if (!force && c && c.classList.contains('memo-docked')) return; // ドック中は閉じない

  if (!force && window.memoInteracting) return;

  const panel = document.getElementById('memo-panel');
  if (!panel) return;
  panel.classList.remove('open');

  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
}



function toggleMemoDock() {
  const checkbox = document.getElementById('check-memo-dock');
  const c = document.getElementById('main-container');
  const b = document.getElementById('btn-memo-swap');
  const pinBtn = document.getElementById('btn-memo-pin');
  const panel = document.getElementById('memo-panel');

  if (!checkbox) {
    console.error('check-memo-dock が見つかりません');
    return;
  }
  if (!c) {
    console.error('main-container が見つかりません');
    return;
  }

  const d = checkbox.checked;

  if (d) {
    c.classList.add('memo-docked');
    if (b) b.classList.add('is-active');
  } else {
    c.classList.remove('memo-docked', 'memo-right');
    if (b) b.classList.remove('is-active');
    if (panel) panel.style.width = '260px';
  }

  if (pinBtn) pinBtn.classList.toggle('pinned', d);

  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
}


    function toggleMemoDockPin() {
        const checkbox = document.getElementById('check-memo-dock');
        checkbox.checked = !checkbox.checked;
        toggleMemoDock();
    }

    function swapMemoSide() {
        document.getElementById('main-container').classList.toggle('memo-right');
        updateDockSplitState();
    }

    function renderMemoTabs() {
        const container = document.getElementById('memo-tabs-container');
        if (!container) return;
        container.innerHTML = '';
        memoTabs.forEach(tab => {
            const tabEl = document.createElement('div');
            tabEl.className = 'memo-tab' + (tab.id === activeMemoTabId ? ' active' : '');
            tabEl.draggable = true;
            tabEl.dataset.tabId = tab.id;
            tabEl.innerHTML = `
                <span class="tab-name" ondblclick="startEditMemoTabName(${tab.id})">${escapeHtml(tab.name)}</span>
                ${memoTabs.length > 1 ? `<span class="tab-close" onclick="event.stopPropagation(); deleteMemoTab(${tab.id})">✕</span>` : ''}
            `;
            tabEl.addEventListener('click', ev => { ev.stopPropagation(); switchMemoTab(tab.id); });
            tabEl.addEventListener('dragstart', e => {
                draggingMemoTabId = tab.id;
                tabEl.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            tabEl.addEventListener('dragend', () => {
                draggingMemoTabId = null;
                tabEl.classList.remove('dragging');
            });
            tabEl.addEventListener('dragover', e => {
                if (draggingMemoTabId === null || draggingMemoTabId === tab.id) return;
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
            });
            tabEl.addEventListener('drop', e => {
                e.preventDefault();
                if (draggingMemoTabId === null || draggingMemoTabId === tab.id) return;
                const fromIndex = memoTabs.findIndex(t => t.id === draggingMemoTabId);
                const toIndex = memoTabs.findIndex(t => t.id === tab.id);
                if (fromIndex === -1 || toIndex === -1) return;
                const [moved] = memoTabs.splice(fromIndex, 1);
                memoTabs.splice(toIndex, 0, moved);
                renderMemoTabs();
                saveMemoTabs();
            });
            container.appendChild(tabEl);
        });
        const addBtn = document.createElement('button');
        addBtn.className = 'memo-tab memo-tab-add';
        addBtn.textContent = '＋';
        addBtn.title = '新しいメモタブを追加';
        addBtn.onclick = ev => { if (ev) ev.stopPropagation(); addNewMemoTab(); };
        container.appendChild(addBtn);
        updateTabScrollButtonsFor('memo-tabs-container');
    }

    function switchMemoTab(id) {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        activeMemoTabId = id;
        const newTab = memoTabs.find(t => t.id === id);
        memoArea.value = newTab ? newTab.content : '';
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    }

    function addNewMemoTab() {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        memoTabs.push({ id: nextMemoTabId, name: `メモ${nextMemoTabId}`, content: '' });
        activeMemoTabId = nextMemoTabId;
        nextMemoTabId++;
        memoArea.value = '';
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    }

    function deleteMemoTab(id) {
        if (memoTabs.length <= 1) return;
        if (!confirm('このメモタブを削除しますか？')) return;
        const idx = memoTabs.findIndex(t => t.id === id);
        memoTabs.splice(idx, 1);
        if (activeMemoTabId === id) {
            activeMemoTabId = memoTabs[Math.max(0, idx - 1)].id;
            memoArea.value = memoTabs.find(t => t.id === activeMemoTabId).content;
        }
        renderMemoTabs();
        updateMemoCharCount();
        saveMemoTabs();
    }

    function startEditMemoTabName(id) {
        const tab = memoTabs.find(t => t.id === id);
        const newName = prompt('タブ名を入力:', tab.name);
        if (newName && newName.trim()) {
            tab.name = newName.trim();
            renderMemoTabs();
            saveMemoTabs();
        }
    }

    function loadMemoTabs() {
        const saved = localStorage.getItem(MEMO_KEY);
        if (saved) {
            try {
                const data = JSON.parse(saved);
                if (data.tabs && data.tabs.length > 0) {
                    memoTabs = data.tabs;
                    activeMemoTabId = data.activeId || memoTabs[0].id;
                    nextMemoTabId = data.nextId || Math.max(...memoTabs.map(t => t.id)) + 1;
                    const activeTab = memoTabs.find(t => t.id === activeMemoTabId);
                    memoArea.value = activeTab ? activeTab.content : '';
                }
            } catch (e) { /* use defaults */ }
        }
        renderMemoTabs();
        updateMemoCharCount();
    }

    function saveMemoTabs() {
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        localStorage.setItem(MEMO_KEY, JSON.stringify({
            tabs: memoTabs,
            activeId: activeMemoTabId,
            nextId: nextMemoTabId
        }));
    }

    function showMemoSaveDialog() {
        document.getElementById('memo-save-dialog').style.display = 'flex';
    }
    function closeMemoSaveDialog() {
        document.getElementById('memo-save-dialog').style.display = 'none';
    }
    async function executeMemoSave() {
        const scope = document.querySelector('input[name="memo-save-scope"]:checked')?.value || 'current';
        const currentTab = memoTabs.find(t => t.id === activeMemoTabId);
        if (currentTab) currentTab.content = memoArea.value;
        let content;
        if (scope === 'all') {
            content = memoTabs.map(t => `◇ ${t.name}\n${t.content}`).join('\n\n');
        } else {
            content = currentTab ? currentTab.content : '';
        }
        const blob = new Blob([content], { type: 'text/plain' });
        const n = new Date();
        const name = `memo_${n.getFullYear()}${(n.getMonth()+1).toString().padStart(2,'0')}${n.getDate().toString().padStart(2,'0')}.txt`;
        const result = await saveBlobWithPicker(blob, name, [{ description: 'Text', accept: { 'text/plain': ['.txt'] } }], lastMemoSaveHandle);
        if (result.handle) lastMemoSaveHandle = result.handle;
        if (!result.handled) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        closeMemoSaveDialog();
    }

    function loadMemoFile(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = e => {
            const content = e.target.result;
            const parsedTabs = parseStructuredTabs(content, '◇');
            if (parsedTabs.length > 0) {
                parsedTabs.forEach(tab => {
                    const name = tab.name || `メモ${nextMemoTabId}`;
                    memoTabs.push({ id: nextMemoTabId++, name, content: tab.content });
                });
                activeMemoTabId = memoTabs[memoTabs.length - parsedTabs.length].id;
                memoArea.value = memoTabs.find(t => t.id === activeMemoTabId)?.content || '';
            } else {
                const newId = nextMemoTabId++;
                memoTabs.push({ id: newId, name: `メモ${newId}`, content });
                activeMemoTabId = newId;
                memoArea.value = content;
            }
            renderMemoTabs();
            updateMemoCharCount();
            saveMemoTabs();
        };
        reader.readAsText(file);
        input.value = '';
    }

    memoArea.addEventListener('input', () => {
        updateMemoCharCount();
        saveMemoTabs();
    });

    let outlineData = [];
function toggleOutlinePanel() {
    const panel = document.getElementById('outline-panel');
    const checkbox = document.getElementById('check-outline-dock');
    const isOpen = panel.classList.contains('open');
    const isDocked = checkbox.checked;

    if (!isOpen) {
        generateOutline();
        panel.classList.add('open');

        if (isDocked) {
            checkbox.checked = false;
            toggleOutlineDock();
        }
    } else if (!isDocked) {
        checkbox.checked = true;
        toggleOutlineDock();
        panel.classList.add('open');
    } else {
        checkbox.checked = false;
        toggleOutlineDock();
        panel.classList.remove('open');
    }

    applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
    updatePanelButtonStates();
    updateDockSplitState();
}

function closeOutlinePanel() {
    const panel = document.getElementById('outline-panel');
    panel.classList.remove('open');
    applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
    updatePanelButtonStates();
    updateDockSplitState();
}

    function toggleOutlineDock() {
        const d = document.getElementById('check-outline-dock').checked;
        const c = document.getElementById('main-container');
        const b = document.getElementById('btn-outline-swap');
        const pinBtn = document.getElementById('btn-outline-pin');
        if (d) {
            c.classList.add('outline-docked');
            b.classList.add('is-active');
        } else {
            c.classList.remove('outline-docked', 'outline-left');
            b.classList.remove('is-active');
            document.getElementById('outline-panel').style.width = '260px';
        }
        if (pinBtn) pinBtn.classList.toggle('pinned', d);
        applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
        updatePanelButtonStates();
        updateDockSplitState();
    }

    function toggleOutlineDockPin() {
        const checkbox = document.getElementById('check-outline-dock');
        checkbox.checked = !checkbox.checked;
        toggleOutlineDock();
    }
    function swapOutlineSide() {
        document.getElementById('main-container').classList.toggle('outline-left');
        updateDockSplitState();
    }
    function switchOutlineTab(tab) {
        document.querySelectorAll('#outline-panel .outline-tabs-inner .memo-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.outline-tab-content').forEach(c => c.classList.remove('active'));
        const tabEl = document.querySelector(`#outline-panel .outline-tabs-inner .memo-tab[onclick*="${tab}"]`);
        if (tabEl) tabEl.classList.add('active');
        const content = document.getElementById(`outline-tab-${tab}`);
        if (content) content.classList.add('active');
    }
    
    function generateOutline() {
        const l = document.getElementById('outline-list');
        const sm = document.getElementById('outline-summary');
        l.innerHTML = '';
        outlineData = [];

        const rx = /^([#＃■□▲△▼▽◆◇○◎●§・※☆★]+|第[一二三四五六七八九十百千\d]+[章話節部編]|[①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳]+|[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+)/;
        let foundAny = false;

        function outlineItemsForTab(tab) {
            const t = (tab && typeof tab.content === 'string') ? tab.content : '';
            const tabName = (tab && typeof tab.name === 'string') ? tab.name.trim() : '';
            const tabId = tab ? tab.id : null;
            const ls = t.split('\n');

            const items = [];

            // Lv1: タブ名（タブ同士は同じレベル）
            if (tabName) {
                items.push({
                    text: tabName,
                    level: 1,
                    pos: 0,
                    length: 0,
                    collapsed: false,
                    index: 0,
                    directCharCount: 0,
                    charCount: 0,
                    tabId,
                    tabName,
                    isTabTitle: true
                });
            }

            let cl = 1; // Lv1はタブ名に予約
            const lm = new Map();
            let ca = 0;
            let hasHeading = false;

            ls.forEach(line => {
                const c = line.trim();
                const cp = ca;
                ca += line.length + 1;
                const m = c.match(rx);
                if (!m) return;

                hasHeading = true;
                let sk = m[1];
                if (sk.match(/^第.+[章話節部編]$/)) sk = '___CHAPTER___';
                else if (sk.match(/^[①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳]+$/)) sk = '___CIRCLED___';
                else if (sk.match(/^[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+$/)) sk = '___ROMAN___';

                if (!lm.has(sk)) {
                    cl++;
                    lm.set(sk, cl);
                }

                items.push({
                    text: c,
                    level: lm.get(sk),
                    pos: cp,
                    length: c.length,
                    collapsed: false,
                    index: items.length,
                    directCharCount: 0,
                    charCount: 0,
                    tabId
                });
            });

            if (tabName || hasHeading) foundAny = true;

            // directCharCount（同一タブ内）
            const tl = t.length;
            for (let i = 0; i < items.length; i++) {
                if (items[i].isTabTitle) continue;
                const sp = items[i].pos;
                const ep = (i + 1 < items.length) ? items[i + 1].pos : tl;
                items[i].directCharCount = t.substring(sp, ep).replace(/[\n\s　]/g, '').length;
            }

            const tabTitleItem = items.find(it => it.isTabTitle);
            if (tabTitleItem) {
                tabTitleItem.directCharCount = t.replace(/[\n\s　]/g, '').length;
            }

            // charCount（同一タブ内で集計）
            for (let i = items.length - 1; i >= 0; i--) {
                if (items[i].isTabTitle) {
                    items[i].charCount = items[i].directCharCount;
                    continue;
                }
                const clv = items[i].level;
                let tc = items[i].directCharCount;
                for (let j = i + 1; j < items.length; j++) {
                    if (items[j].level <= clv) break;
                    if (items[j].level === clv + 1) tc += items[j].charCount;
                    else {
                        let hp = false;
                        for (let k = j - 1; k > i; k--) {
                            if (items[k].level === items[j].level - 1) { hp = true; break; }
                            if (items[k].level <= clv) break;
                        }
                        if (!hp) tc += items[j].charCount;
                    }
                }
                items[i].charCount = tc;
            }

            return items;
        }

        // 全タブから目次生成（タブ名が最上位）
        inputTabs.forEach(tab => {
            outlineData.push(...outlineItemsForTab(tab));
        });

        // Lv別集計（全タブ合算）
        const lc = new Map();
        outlineData.forEach(it => {
            if (!lc.has(it.level)) lc.set(it.level, 0);
            lc.set(it.level, lc.get(it.level) + (it.directCharCount || 0));
        });

        if (foundAny) {
            let st = '文字数: ';
            Array.from(lc.keys()).sort((a, b) => a - b).forEach((lv, i, a) => {
                st += `Lv${lv}: ${lc.get(lv).toLocaleString()}`;
                if (i < a.length - 1) st += ' / ';
            });
            sm.innerHTML = st;
            sm.style.display = 'block';
        } else {
            sm.style.display = 'none';
        }

        renderOutline();
        if (!foundAny) l.innerHTML = '<div class="outline-empty">見出しが見つかりません。</div>';
    }

    function renderOutline() {
        const l = document.getElementById('outline-list'); l.innerHTML = '';
        outlineData.forEach((it, idx) => {
            const d = document.createElement('div'); d.className = `outline-item outline-level-${Math.min(it.level, 3)}`;
            const hc = outlineData.some((x, i) => i > idx && x.level > it.level && !outlineData.slice(idx + 1, i).some(m => m.level <= it.level));
            const tg = document.createElement('span'); tg.className = 'outline-toggle'; if (hc) { tg.textContent = it.collapsed ? '▶' : '▼'; tg.onclick = e => { e.stopPropagation(); toggleOutlineItem(idx); }; } d.appendChild(tg);
            const ts = document.createElement('span'); ts.className = 'outline-text'; ts.textContent = it.text; d.appendChild(ts);
            const cc = document.createElement('span'); cc.className = 'outline-char-count'; cc.textContent = it.charCount.toLocaleString(); d.appendChild(cc);
            let hd = false; for (let i = 0; i < idx; i++) { if (outlineData[i].collapsed && outlineData[i].level < it.level) { let ir = true; for (let j = i + 1; j < idx; j++) { if (outlineData[j].level <= outlineData[i].level) { ir = false; break; } } if (ir) { hd = true; break; } } } if (hd) d.classList.add('outline-hidden');
            d.onclick = e => { if (e.target.classList.contains('outline-toggle')) return; if (it.tabId && it.tabId !== activeTabId) switchTab(it.tabId); inputArea.focus(); inputArea.setSelectionRange(it.pos, it.pos + it.length); setTimeout(() => scrollToCursorPosition(it.pos), 100); updateCursorLineDisplay(); if (window.innerWidth < 768 && !document.getElementById('check-outline-dock').checked) closeOutlinePanel(); };
            l.appendChild(d);
        });
    }
    function toggleOutlineItem(i) { outlineData[i].collapsed = !outlineData[i].collapsed; renderOutline(); }
    function expandAllOutline() { outlineData.forEach(it => it.collapsed = false); renderOutline(); }
    function collapseAllOutline() { outlineData.forEach(it => it.collapsed = true); renderOutline(); }

    function toggleLayoutAxis() {
        if (layoutAxis === 'row') {
            layoutAxis = 'column';
        } else {
            layoutAxis = 'row';
        }
        layoutReversed = false;
        applyLayoutState();
        applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
if (typeof applyPaneHeightSettings === 'function') {
    applyPaneHeightSettings();
}
        saveLayoutSettings();
    }
    function toggleLayoutOrder() {
        layoutReversed = !layoutReversed;
        applyLayoutState();
        saveLayoutSettings();
    }

    function showJumpDialog() { document.getElementById('jump-dialog').classList.add('show'); document.getElementById('jump-line-input').value = ''; document.getElementById('jump-line-input').focus(); }
    function closeJumpDialog() { document.getElementById('jump-dialog').classList.remove('show'); }
    function executeJump() { const ln = parseInt(document.getElementById('jump-line-input').value); if (isNaN(ln) || ln < 1) { alert('有効な行番号を入力してください。'); return; } const ls = inputArea.value.split('\n'); if (ln > ls.length) { alert(`最大行数は ${ls.length} 行です。`); return; } let p = 0; for (let i = 0; i < ln - 1; i++) p += ls[i].length + 1; inputArea.focus(); inputArea.setSelectionRange(p, p); setTimeout(() => scrollToCursorPosition(p), 100); updateCursorLineDisplay(); closeJumpDialog(); }
    document.getElementById('jump-line-input').addEventListener('keydown', e => { if (e.key === 'Enter') executeJump(); if (e.key === 'Escape') closeJumpDialog(); });

    let currentHeatmapType = 'paragraph';
    function showAnalysis() {
        const t = inputArea.value, tc = t.replace(/[\n\s　]/g, '').length;
        const kc = (t.match(/[一-龠々〆ヵヶ]/g) || []).length, hc = (t.match(/[ぁ-ん]/g) || []).length, ktc = (t.match(/[ァ-ヴー]/g) || []).length, oc = tc - kc - hc - ktc;
        const kp = tc > 0 ? (kc / tc * 100).toFixed(1) : 0, hp = tc > 0 ? (hc / tc * 100).toFixed(1) : 0, ktp = tc > 0 ? (ktc / tc * 100).toFixed(1) : 0, op = tc > 0 ? (oc / tc * 100).toFixed(1) : 0;
        const ss = t.split(/。|！|？|\!|\?/).filter(s => s.trim().length > 0), sl = ss.map(s => s.replace(/[\n\s　]/g, '').length);
        const al = sl.length > 0 ? Math.round(sl.reduce((a, b) => a + b, 0) / sl.length) : 0, ml = sl.length > 0 ? Math.max(...sl) : 0, ls = sl.filter(l => l > 100).length;
        const dm = t.match(/「[^」]*」/g) || [], dc = dm.join('').replace(/[「」\n\s　]/g, '').length, dp = tc > 0 ? (dc / tc * 100).toFixed(1) : 0, np = (100 - parseFloat(dp)).toFixed(1);
        const ct = t.replace(/[\n\s　「」『』（）()、。！？\!\?…―─]/g, ''), fm = new Map();
        for (let len = 2; len <= 4; len++) { for (let i = 0; i <= ct.length - len; i++) { const w = ct.substring(i, i + len); if (!/^[ぁ-んァ-ヴー一-龠々〆ヵヶ]+$/.test(w)) continue; fm.set(w, (fm.get(w) || 0) + 1); } }
        const fw = Array.from(fm.entries()).filter(([w, c]) => c >= 3).sort((a, b) => b[1] - a[1]).slice(0, 15);
        document.getElementById('analysis-results').innerHTML = `
            <div class="analysis-section"><h4>📊 文字種別</h4>
                <div class="analysis-row"><span>漢字</span><span>${kc.toLocaleString()}字 (${kp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${kp}%; background:#dc2626;"></div></div>
                <div class="analysis-row"><span>ひらがな</span><span>${hc.toLocaleString()}字 (${hp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${hp}%; background:#2563eb;"></div></div>
                <div class="analysis-row"><span>カタカナ</span><span>${ktc.toLocaleString()}字 (${ktp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${ktp}%; background:#16a34a;"></div></div>
                <div class="analysis-row"><span>その他</span><span>${oc.toLocaleString()}字 (${op}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${op}%; background:#9ca3af;"></div></div>
            </div>
            <div class="analysis-section"><h4>📝 文長分析</h4>
                <div class="analysis-row"><span>文の数</span><span>${ss.length}文</span></div>
                <div class="analysis-row"><span>平均文長</span><span>${al}字</span></div>
                <div class="analysis-row"><span>最長文</span><span>${ml}字</span></div>
                ${ls > 0 ? `<div class="warning-text">⚠️ 100字超の長い文が ${ls} 箇所</div>` : '<div style="color:#16a34a;">✓ 極端に長い文はありません</div>'}
            </div>
            <div class="analysis-section"><h4>💬 会話文比率</h4>
                <div class="analysis-row"><span>会話文</span><span>${dc.toLocaleString()}字 (${dp}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${dp}%; background:#f97316;"></div></div>
                <div class="analysis-row"><span>地の文</span><span>${(tc - dc).toLocaleString()}字 (${np}%)</span></div><div class="analysis-bar"><div class="analysis-bar-fill" style="width:${np}%; background:#8b5cf6;"></div></div>
            </div>
            <div class="analysis-section"><h4>🔤 頻出語 TOP15</h4>
                ${fw.length > 0 ? `<div class="freq-list">${fw.map(([w, c]) => `<span class="freq-item">${w} (${c})</span>`).join('')}</div>` : '<div class="outline-empty">十分なデータがありません</div>'}
            </div>
            <div class="analysis-section"><h4>🗺️ ヒートマップ分析</h4>
                <div class="heatmap-tabs">
                    <span class="heatmap-tab ${currentHeatmapType === 'paragraph' ? 'active' : ''}" onclick="switchHeatmap('paragraph')">段落長</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'kanji' ? 'active' : ''}" onclick="switchHeatmap('kanji')">漢字密度</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'char' ? 'active' : ''}" onclick="switchHeatmap('char')">文字頻度</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'ending' ? 'active' : ''}" onclick="switchHeatmap('ending')">文末表現</span>
                    <span class="heatmap-tab ${currentHeatmapType === 'punct' ? 'active' : ''}" onclick="switchHeatmap('punct')">句読点密度</span>
                </div>
                <div id="heatmap-display"></div>
            </div>`;
        renderHeatmap();
        document.getElementById('analysis-modal').classList.add('show');
    }
    function switchHeatmap(type) { currentHeatmapType = type; document.querySelectorAll('.heatmap-tab').forEach(t => t.classList.remove('active')); document.querySelector(`.heatmap-tab[onclick*="${type}"]`).classList.add('active'); renderHeatmap(); }
    function getHeatColor(value, type) {
        const colors = { paragraph: ['#dcfce7','#86efac','#22c55e','#16a34a','#15803d'], kanji: ['#fef3c7','#fcd34d','#f59e0b','#d97706','#b45309'], char: ['#dbeafe','#93c5fd','#3b82f6','#2563eb','#1d4ed8'], ending: ['#fce7f3','#f9a8d4','#ec4899','#db2777','#be185d'], punct: ['#f3e8ff','#c4b5fd','#a78bfa','#8b5cf6','#7c3aed'] };
        const idx = Math.min(4, Math.floor(value * 5)); return colors[type][idx];
    }
    function renderHeatmap() {
        const t = inputArea.value, container = document.getElementById('heatmap-display');
        const paragraphs = t.split(/\n\n+/).filter(p => p.trim().length > 0);
        if (paragraphs.length === 0) { container.innerHTML = '<div class="outline-empty">データがありません</div>'; return; }
        let cells = [], legend = '';
        if (currentHeatmapType === 'paragraph') {
            legend = '短い → 長い';
            const lengths = paragraphs.map(p => p.replace(/[\n\s　]/g, '').length);
            const maxLen = Math.max(...lengths, 1);
            cells = lengths.map((len, i) => ({ value: len / maxLen, tooltip: `段落${i+1}: ${len}字` }));
        } else if (currentHeatmapType === 'kanji') {
            legend = '少ない → 多い';
            cells = paragraphs.map((p, i) => { const clean = p.replace(/[\n\s　]/g, ''); const kj = (p.match(/[一-龠々〆ヵヶ]/g) || []).length; const ratio = clean.length > 0 ? kj / clean.length : 0; return { value: ratio, tooltip: `段落${i+1}: ${(ratio*100).toFixed(1)}%` }; });
        } else if (currentHeatmapType === 'char') {
            legend = '低頻度 → 高頻度';
            const allChars = t.replace(/[\n\s　「」『』（）()、。！？\!\?…―─\r]/g, '');
            const charFreq = new Map(); for (const c of allChars) charFreq.set(c, (charFreq.get(c) || 0) + 1);
            const maxFreq = Math.max(...charFreq.values(), 1);
            const blockSize = 50;
            for (let i = 0; i < allChars.length; i += blockSize) {
                const block = allChars.substring(i, i + blockSize);
                let sum = 0; for (const c of block) sum += charFreq.get(c) || 0;
                const avg = sum / block.length / maxFreq;
                cells.push({ value: avg, tooltip: `${i+1}-${Math.min(i+blockSize, allChars.length)}字目` });
            }
        } else if (currentHeatmapType === 'ending') {
            legend = '。多 → 多様';
            const sentences = t.split(/(?<=[。！？\!\?])/).filter(s => s.trim().length > 0);
            const blockSize = 10;
            for (let i = 0; i < sentences.length; i += blockSize) {
                const block = sentences.slice(i, i + blockSize);
                const endings = block.map(s => { const m = s.match(/[。！？\!\?]/); return m ? m[0] : ''; });
                const unique = new Set(endings.filter(e => e)).size;
                const variety = unique / Math.min(block.length, 4);
                cells.push({ value: Math.min(1, variety), tooltip: `文${i+1}-${i+block.length}: ${unique}種類` });
            }
        } else if (currentHeatmapType === 'punct') {
            legend = '少ない → 多い';
            cells = paragraphs.map((p, i) => { const clean = p.replace(/[\n\s　]/g, ''); const puncts = (p.match(/[、。！？\!\?…―─「」『』（）()]/g) || []).length; const ratio = clean.length > 0 ? puncts / clean.length : 0; return { value: Math.min(1, ratio * 5), tooltip: `段落${i+1}: ${puncts}個` }; });
        }
        container.innerHTML = `<div class="heatmap-title"><span>${{paragraph:'段落長さ',kanji:'漢字密度',char:'文字頻度',ending:'文末表現',punct:'句読点密度'}[currentHeatmapType]}</span><span class="heatmap-legend">${legend}</span></div><div class="heatmap-grid">${cells.map(c => `<div class="heatmap-cell" style="background:${getHeatColor(c.value, currentHeatmapType)}" data-tooltip="${c.tooltip}"></div>`).join('')}</div>`;
    }
    function closeAnalysis() { document.getElementById('analysis-modal').classList.remove('show'); }

    function showSaveDialog() { document.getElementById('save-dialog-overlay').style.display = 'flex'; }
    function closeSaveDialog() { document.getElementById('save-dialog-overlay').style.display = 'none'; }
    async function saveWithHandle(handle, blob) {
        if (!handle) return false;
        try {
            const permission = await handle.queryPermission({ mode: 'readwrite' });
            if (permission !== 'granted') {
                const requested = await handle.requestPermission({ mode: 'readwrite' });
                if (requested !== 'granted') return false;
            }
            const writable = await handle.createWritable();
            await writable.write(blob);
            await writable.close();
            return true;
        } catch (err) {
            return false;
        }
    }
    async function saveBlobWithPicker(blob, suggestedName, types, existingHandle) {
        if (existingHandle) {
            const handled = await saveWithHandle(existingHandle, blob);
            if (handled) return { handled: true, handle: existingHandle };
        }
        if (!window.showSaveFilePicker) return { handled: false, handle: null };
        try {
            const handle = await window.showSaveFilePicker({ suggestedName, types });
            const handled = await saveWithHandle(handle, blob);
            return { handled, handle: handled ? handle : null };
        } catch (err) {
            if (err && err.name === 'AbortError') return { handled: true, handle: existingHandle || null };
            return { handled: false, handle: null };
        }
    }
    function getNovelBaseName() {
        const base = sanitizeFileName(novelTitle || DEFAULT_NOVEL_TITLE);
        return base || 'novel';
    }
    function getSaveScope() { return document.querySelector('input[name="save-scope"]:checked')?.value || 'current'; }
    function getContentToSave(scope = getSaveScope()) { return scope === 'all' ? getAllTabsContent() : getCurrentTabContent(); }
    function setAutoSaveTarget(handle, type, scope) {
        autoSaveTarget = { handle, type, scope };
    }
    function maybePromptEnableAutoSave() {
        if (settingsCache.autosaveEnabled) return;
        if (!autoSaveTarget.handle) return;
        const enable = confirm('自動保存をオンにすると、指定したフォルダーに保存が続きますがよろしいですか？');
        if (enable) {
            document.getElementById('st-autosave-enabled').checked = true;
            applyAutoSaveSettings(true);
        }
    }
    async function saveAsText() {
        const scope = getSaveScope();
        const content = getContentToSave(scope);
        const b = new Blob([content], { type: 'text/plain' });
        const name = `${getNovelBaseName()}.txt`;
        const result = await saveBlobWithPicker(b, name, [{ description: 'Text', accept: { 'text/plain': ['.txt'] } }], lastTextSaveHandle);
        if (result.handle) lastTextSaveHandle = result.handle;
        if (!result.handled) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(b);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        if (result.handle) {
            setAutoSaveTarget(result.handle, 'text', scope);
            maybePromptEnableAutoSave();
        }
        closeSaveDialog();
    }
    async function saveAsHTML() {
        const scope = getSaveScope();
        const h = buildHtmlExport(scope);
        const b = new Blob([h], { type: 'text/html' });
        const name = `${getNovelBaseName()}.html`;
        const result = await saveBlobWithPicker(b, name, [{ description: 'HTML', accept: { 'text/html': ['.html'] } }], lastHtmlSaveHandle);
        if (result.handle) lastHtmlSaveHandle = result.handle;
        if (!result.handled) {
            const a = document.createElement('a');
            a.href = URL.createObjectURL(b);
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        if (result.handle) {
            setAutoSaveTarget(result.handle, 'html', scope);
            maybePromptEnableAutoSave();
        }
        closeSaveDialog();
    }
    function renderTextToHTML(text) {
        const ss = settingsCache.showSpace, sh = settingsCache.showHighlight;
        let s = escapeHtml(text);
        const MZ = '\uE001', MH = '\uE002'; if (ss) { s = s.replace(/　/g, MZ).replace(/ /g, MH); }
        if (sh) { s = s.replace(/「(.*?)」/g, '<span class="bracket-blue">「$1」</span>').replace(/『(.*?)』/g, '<span class="bracket-green">『$1』</span>'); }
        s = s.replace(/｜([^《]+?)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>').replace(/([一-龠々〆ヵヶ]+)《(.+?)》/g, '<ruby>$1<rt>$2</rt></ruby>');
        s = s.replace(/《《(.+?)》》/g, (m, p) => { let r = ''; for (let c of p) r += `<ruby class="bouten-ruby">${c}<rt>・</rt></ruby>`; return r; });
        s = s.replace(/__(.+?)__/g, '<span class="underline-text">$1</span>').replace(/==(.+?)==/g, '<span class="highlight-text">$1</span>');
        if (sh) s = s.replace(/([―─]{2,}|…{2,})/g, '<span class="symbol-hl">$1</span>');
        if (ss) { s = s.split(MZ).join('<span class="space-zen">□</span>').split(MH).join('<span class="space-han">･</span>'); }
        return s.replace(/\n/g, '<br>');
    }
    function parseStructuredTabs(text, marker) {
        const lines = text.split(/\r?\n/);
        const rx = new RegExp(`^\\${marker}\\s*(.*)$`);
        const tabs = [];
        let current = null;
        lines.forEach(line => {
            const m = line.match(rx);
            if (m) {
                if (current) tabs.push(current);
                current = { name: m[1].trim() || '', content: '' };
            } else if (current) {
                current.content += (current.content ? '\n' : '') + line;
            }
        });
        if (current) tabs.push(current);
        return tabs;
    }

    // -----------------------------
    // 📂 開く：その場で「現在タブ / 新規タブ」を選ぶ
    // -----------------------------
    function openFileWithChoice() {
        const modal = document.getElementById('open-choice-modal');
        if (!modal) {
            // 旧動作のフォールバック
            document.getElementById('file-input')?.click();
            return;
        }

        // 設定（既定）に応じてボタンの強調を変える
        const defaultMode = (settingsCache && settingsCache.openMode) ? settingsCache.openMode : 'current';
        const btnCur = document.getElementById('btn-open-choice-current');
        const btnNew = document.getElementById('btn-open-choice-new');
        if (btnCur && btnNew) {
            btnCur.classList.toggle('active', defaultMode === 'current');
            btnNew.classList.toggle('active', defaultMode === 'new');
        }

        modal.classList.add('show');
        modal.setAttribute('aria-hidden', 'false');
    }

    function closeOpenChoiceModal() {
        const modal = document.getElementById('open-choice-modal');
        if (!modal) return;
        modal.classList.remove('show');
        modal.setAttribute('aria-hidden', 'true');
        pendingOpenMode = null;
    }

    function chooseOpenModeAndPickFile(mode) {
        pendingOpenMode = mode;
        closeOpenChoiceModal();
        // 次の tick で file picker を開く（モーダルが閉じた後に）
        setTimeout(() => document.getElementById('file-input')?.click(), 0);
    }

    // モーダル外クリックで閉じる
    document.addEventListener('mousedown', (e) => {
        const modal = document.getElementById('open-choice-modal');
        if (!modal || !modal.classList.contains('show')) return;
        if (e.target === modal) closeOpenChoiceModal();
    });
    function loadFile(input) {
        const f = input.files[0]; if (!f) return;
        const r = new FileReader();
        r.onload = e => {
            const content = e.target.result;

            // まず現在タブの内容を保存
            const currentTab = inputTabs.find(t => t.id === activeTabId);
            if (currentTab) currentTab.content = inputArea.value;

            // 「📂 開く」の選択（その場選択）があれば最優先。なければ設定の既定を使う
            const openMode = pendingOpenMode || ((settingsCache && settingsCache.openMode) ? settingsCache.openMode : 'current');
            const parsedTabs = parseStructuredTabs(content, '◆');

            // 開くモード: current = 現在タブへ上書き / new = 新規タブへ追加
            if (openMode === 'current') {
                if (!currentTab) {
                    // 念のため（通常は必ずある）
                    inputTabs.push({ id: nextTabId++, name: `タブ${inputTabs.length + 1}`, content: '' });
                    activeTabId = inputTabs[inputTabs.length - 1].id;
                }

                const targetTab = inputTabs.find(t => t.id === activeTabId);
                if (parsedTabs.length > 0) {
                    // 1つ目は現在タブへ、残りは新規タブへ
                    const first = parsedTabs[0];
                    targetTab.name = (first.name || targetTab.name || `タブ${activeTabId}`);
                    targetTab.content = first.content;
                } else {
                    targetTab.content = content;
                }

                // 残りタブ追加（for文をPython風に書いてしまう事故を避けるため、下でJSとして追記する）
                if (parsedTabs.length > 1) {
                    for (let i = 1; i < parsedTabs.length; i++) {
                        const tab = parsedTabs[i];
                        const name = tab.name || `タブ${inputTabs.length + 1}`;
                        inputTabs.push({ id: nextTabId++, name, content: tab.content });
                    }
                    // 最後に追加したタブへ移動するかどうかは好みが分かれるので、現在タブのままにします
                }

                inputArea.value = inputTabs.find(t => t.id === activeTabId)?.content || '';

            } else {
                // new: 既存仕様（読み込んだ内容を新規タブとして追加）
                if (parsedTabs.length > 0) {
                    parsedTabs.forEach(tab => {
                        const name = tab.name || `タブ${inputTabs.length + 1}`;
                        inputTabs.push({ id: nextTabId++, name, content: tab.content });
                    });
                    activeTabId = inputTabs[inputTabs.length - parsedTabs.length].id;
                    inputArea.value = inputTabs.find(t => t.id === activeTabId)?.content || '';
                } else {
                    const name = `タブ${inputTabs.length + 1}`;
                    inputTabs.push({ id: nextTabId++, name, content });
                    activeTabId = inputTabs[inputTabs.length - 1].id;
                    inputArea.value = content;
                }
            }

            renderInputTabs();
            updateInputStats();
            updatePreview();
            saveTabsToStorage();
            input.value = '';
            pendingOpenMode = null;
        };
        r.readAsText(f);
    }

    document.addEventListener('keydown', e => {
        if (document.getElementById('reader-overlay')?.classList.contains('show')) {
            if (e.key === 'Escape') { e.preventDefault(); closeReaderView(); return; }
        }

        if (e.key === 'Escape') { if (document.body.classList.contains('focus-mode')) toggleFocusMode(); closeJumpDialog(); closeAnalysis(); closeMemoSaveDialog(); }
        if (e.key === 'F11') { e.preventDefault(); toggleFocusMode(); }
        if (e.ctrlKey && e.key === 'g') { e.preventDefault(); showJumpDialog(); }
        if (e.ctrlKey && e.key === 'f') { e.preventDefault(); togglePanel('search-bar'); }
        if (e.ctrlKey && e.key === 's') { e.preventDefault(); showSaveDialog(); }
        if (e.ctrlKey && !e.shiftKey && e.key === 't') { e.preventDefault(); addNewTab(); }
        if (e.ctrlKey && e.shiftKey && e.key === 'T') { e.preventDefault(); addNewMemoTab(); }
        // Ctrl+Alt+Enter: 同期（更新＋位置合わせを一発）
        if (e.ctrlKey && e.altKey && e.key === 'Enter') {
            e.preventDefault();
            try { updatePreview(); } catch (err) {}
            try { syncPreviewPosition(); } catch (err) {}
        }
    });
    inputArea.addEventListener('keyup', updateCursorLineDisplay);
    inputArea.addEventListener('click', updateCursorLineDisplay);

    // Pane Resizer
    (function initResizer() {
        const resizer = document.getElementById('resizer-input-preview');
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');
        let isResizing = false;

        resizer.addEventListener('mousedown', e => {
            isResizing = true;
            resizer.classList.add('resizing');
            document.body.style.cursor = document.body.classList.contains('scroll-mode') ? 'row-resize' : 'col-resize';
            document.body.style.userSelect = 'none';
            e.preventDefault();
        });

        document.addEventListener('mousemove', e => {
            if (!isResizing) return;
            if (document.body.classList.contains('scroll-mode')) {
                const minPaneHeight = 160;
                const inputRect = inputPane.getBoundingClientRect();
                const previewRect = previewPane.getBoundingClientRect();
                const totalHeight = inputRect.height + previewRect.height;
                if (totalHeight <= minPaneHeight * 2) return;
                const stackRect = paneStack.getBoundingClientRect();
                const topPane = paneStack.classList.contains('reverse-col') ? previewPane : inputPane;
                const bottomPane = paneStack.classList.contains('reverse-col') ? inputPane : previewPane;
                const newTopHeight = clampValue(e.clientY - stackRect.top, minPaneHeight, totalHeight - minPaneHeight);
                const newBottomHeight = totalHeight - newTopHeight;
                topPane.style.height = `${newTopHeight}px`;
                bottomPane.style.height = `${newBottomHeight}px`;
            } else {
                const minPaneWidth = 120;
                const inputRect = inputPane.getBoundingClientRect();
                const previewRect = previewPane.getBoundingClientRect();
                const totalWidth = inputRect.width + previewRect.width;
                if (totalWidth <= minPaneWidth * 2) return;

                if (paneStack.classList.contains('reverse-row')) {
                    const newPreviewWidth = clampValue(e.clientX - previewRect.left, minPaneWidth, totalWidth - minPaneWidth);
                    const newInputWidth = totalWidth - newPreviewWidth;
                    previewPane.style.flex = `1 1 ${newPreviewWidth}px`;
                    inputPane.style.flex = `1 1 ${newInputWidth}px`;
                    previewPane.style.width = `${newPreviewWidth}px`;
                    inputPane.style.width = `${newInputWidth}px`;
                } else {
                    const newInputWidth = clampValue(e.clientX - inputRect.left, minPaneWidth, totalWidth - minPaneWidth);
                    const newPreviewWidth = totalWidth - newInputWidth;
                    inputPane.style.flex = `1 1 ${newInputWidth}px`;
                    previewPane.style.flex = `1 1 ${newPreviewWidth}px`;
                    inputPane.style.width = `${newInputWidth}px`;
                    previewPane.style.width = `${newPreviewWidth}px`;
                }
            }
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                lockedOtherWidth = null;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                if (document.body.classList.contains('scroll-mode')) {
                    const inputRect = inputPane.getBoundingClientRect();
                    const previewRect = previewPane.getBoundingClientRect();
                    const inputHeight = Math.round(inputRect.height);
                    const previewHeight = Math.round(previewRect.height);
                    document.getElementById('st-pane-input-height').value = inputHeight;
                    document.getElementById('st-pane-preview-height').value = previewHeight;
                    localStorage.setItem(PANE_HEIGHT_KEYS.input, String(inputHeight));
                    localStorage.setItem(PANE_HEIGHT_KEYS.preview, String(previewHeight));
                } else {
                    const inputRect = inputPane.getBoundingClientRect();
                    const previewRect = previewPane.getBoundingClientRect();
                    const inputWidth = Math.round(inputRect.width);
                    const previewWidth = Math.round(previewRect.width);
                    document.getElementById('st-pane-input-width').value = inputWidth;
                    document.getElementById('st-pane-preview-width').value = previewWidth;
                    localStorage.setItem(PANE_WIDTH_KEYS.input, inputWidth);
                    localStorage.setItem(PANE_WIDTH_KEYS.preview, previewWidth);
                }
            }
        });
    })();

    (function initDockResizers() {
        const mainContainer = document.getElementById('main-container');
        const inputPane = document.getElementById('pane-input');
        const previewPane = document.getElementById('pane-preview');

        function setupDockResizer(resizerId, panelId, widthInputId, storageKey, getSide) {
            const resizer = document.getElementById(resizerId);
            const panel = document.getElementById(panelId);
            const otherPanel = panelId === 'memo-panel' ? document.getElementById('outline-panel') : document.getElementById('memo-panel');
            const otherWidthInputId = panelId === 'memo-panel' ? 'st-pane-outline-width' : 'st-pane-memo-width';
            const otherIsDocked = () => (panelId === 'memo-panel' ? mainContainer.classList.contains('outline-docked') : mainContainer.classList.contains('memo-docked'));
            let isResizing = false;
            let lockedOtherWidth = null;

            resizer.addEventListener('mousedown', e => {
                if (!panel.classList.contains('open')) return;
                isResizing = true;
                // もう片方のドック（目次/メモ）が開いている場合は、現在幅をロックして動かさない
                lockedOtherWidth = null;
                if (otherPanel && otherIsDocked() && otherPanel.classList.contains('open')) {
                    lockedOtherWidth = Math.round(otherPanel.getBoundingClientRect().width);
                    if (lockedOtherWidth > 0) {
                        otherPanel.style.width = `${lockedOtherWidth}px`;
                        otherPanel.style.flexBasis = `${lockedOtherWidth}px`;
                    }
                }
                resizer.classList.add('resizing');
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                e.preventDefault();
            });

            document.addEventListener('mousemove', e => {
                if (!isResizing) return;
                const containerRect = mainContainer.getBoundingClientRect();
                const panelRect = panel.getBoundingClientRect();
                const minDockWidth = 160;
                const minPaneWidth = 120;
                const inputHidden = inputPane.classList.contains('hidden');
                const previewHidden = previewPane.classList.contains('hidden');
                let minCenter = 0;
                if (!inputHidden) minCenter += minPaneWidth;
                if (!previewHidden) minCenter += minPaneWidth;
                if (!inputHidden && !previewHidden) minCenter += 2;
                let otherDockWidth = 0;
                if (lockedOtherWidth !== null) {
                    otherDockWidth = lockedOtherWidth;
                } else if (panelId === 'memo-panel' && otherIsDocked()) {
                    const outlinePanel = document.getElementById('outline-panel');
                    if (mainContainer.classList.contains('outline-docked') && outlinePanel.classList.contains('open')) {
                        otherDockWidth = outlinePanel.getBoundingClientRect().width;
                    }
                } else if (panelId !== 'memo-panel' && otherIsDocked()) {
                    const memoPanel = document.getElementById('memo-panel');
                    if (memoPanel.classList.contains('open')) {
                        otherDockWidth = memoPanel.getBoundingClientRect().width;
                    }
                }

                const maxDockWidth = Math.max(minDockWidth, containerRect.width - otherDockWidth - minCenter);
                const side = getSide();
                const rawWidth = side === 'left' ? e.clientX - panelRect.left : panelRect.right - e.clientX;
                const newWidth = clampValue(rawWidth, minDockWidth, maxDockWidth);
                panel.style.width = `${newWidth}px`;
                panel.style.flexBasis = `${newWidth}px`;
                // otherPanel は mousedown 時点で固定しているので、ドラッグ中は触らない（目次が動くように見えるのを防止）
            });

            document.addEventListener('mouseup', () => {
                if (!isResizing) return;
                isResizing = false;
                lockedOtherWidth = null;
                resizer.classList.remove('resizing');
                document.body.style.cursor = '';
                document.body.style.userSelect = '';
                const panelRect = panel.getBoundingClientRect();
                const widthValue = Math.round(panelRect.width);
                document.getElementById(widthInputId).value = widthValue;
                localStorage.setItem(storageKey, widthValue);
                applyPaneWidthSettings();
    try { updateDockSplitState(); } catch (e) {}
            });
        }

        setupDockResizer(
            'resizer-memo',
            'memo-panel',
            'st-pane-memo-width',
            PANE_WIDTH_KEYS.memo,
            () => (mainContainer.classList.contains('memo-right') ? 'right' : 'left')
        );
        setupDockResizer(
            'resizer-outline',
            'outline-panel',
            'st-pane-outline-width',
            PANE_WIDTH_KEYS.outline,
            () => (mainContainer.classList.contains('outline-left') ? 'left' : 'right')
        );
    })();

    (function setupMemoOutlineSplitResizer() {
        const resizer = document.getElementById('resizer-memo-outline');
        const memoPanel = document.getElementById('memo-panel');
        const outlinePanel = document.getElementById('outline-panel');
        if (!resizer || !memoPanel || !outlinePanel) return;
        let isResizing = false;

        const onMouseMove = e => {
            if (!isResizing) return;
            const memoRect = memoPanel.getBoundingClientRect();
            const outlineRect = outlinePanel.getBoundingClientRect();
            const totalWidth = memoRect.width + outlineRect.width;
            const minWidth = 160;
            const rawWidth = e.clientX - memoRect.left;
            const memoWidth = clampValue(Math.round(rawWidth), minWidth, totalWidth - minWidth);
            const outlineWidth = Math.max(minWidth, totalWidth - memoWidth);
            memoPanel.style.width = `${memoWidth}px`;
            memoPanel.style.flexBasis = `${memoWidth}px`;
            outlinePanel.style.width = `${outlineWidth}px`;
            outlinePanel.style.flexBasis = `${outlineWidth}px`;
            document.getElementById('st-pane-memo-width').value = memoWidth;
            document.getElementById('st-pane-outline-width').value = outlineWidth;
            localStorage.setItem(PANE_WIDTH_KEYS.memo, memoWidth);
            localStorage.setItem(PANE_WIDTH_KEYS.outline, outlineWidth);
        };

        const onMouseUp = () => {
            if (!isResizing) return;
            isResizing = false;
            resizer.classList.remove('resizing');
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };

        resizer.addEventListener('mousedown', e => {
            const mc = document.getElementById('main-container');
        if (!mc) return;
        if (!mc.classList.contains('dock-split-right') && !mc.classList.contains('dock-split-left')) {
            return;
        }
        // 右境界（メモ｜目次）のドラッグは誤操作が起きやすいので、Altキー押下時だけ有効にする
        if (!e.altKey) return;
            isResizing = true;
            resizer.classList.add('resizing');
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });
    })();

    

function applyDockedPaneWidths() {
  if (typeof applyDockedPanelWidths === 'function') return applyDockedPanelWidths();
}

function applyDefaultStartupPrefsOnce() {
  // 1回だけ（初回起動だけ）適用したい場合
  if (localStorage.getItem('cc_default_startup_prefs_applied') === '1') return;

  // 縦書きON（入力＋プレビュー）
  const inV = document.getElementById('st-in-v');
  const pvV = document.getElementById('st-pv-v');
  if (inV) inV.checked = true;
  if (pvV) pvV.checked = true;

  if (typeof applyInputSettings === 'function') applyInputSettings();
  if (typeof applyPreviewSettings === 'function') applyPreviewSettings();

  // レイアウト既定：横に並べる（入力=左、プレビュー=右）
  layoutAxis = 'row';
  layoutReversed = false;
  if (typeof applyLayoutState === 'function') applyLayoutState();
  if (typeof saveLayoutSettings === 'function') saveLayoutSettings();

  // 設定として保存（次回以降も縦書き維持）
  if (typeof saveSettingsToStorage === 'function') saveSettingsToStorage();

  localStorage.setItem('cc_default_startup_prefs_applied', '1');
}

function applyDefaultStartupLayoutAfterReset() {
  // ✅初期化後の既定レイアウト：横に並べる（入力=左 / プレビュー=右）
  try {
    layoutAxis = 'row';
    layoutReversed = false;
    applyLayoutState();
    saveLayoutSettings();
  } catch (e) {}

  // 💀初期化後は「初回扱い」に戻す
  localStorage.removeItem('cc_default_layout_applied');
  localStorage.removeItem('cc_default_startup_prefs_applied');
  sessionStorage.removeItem('cc_editor_session_started');

  // もう一度「初回起動時の既定」を適用
  if (typeof applyDefaultStartupPrefsOnce === 'function') applyDefaultStartupPrefsOnce();
  if (typeof applyDefaultDockLayoutOnce === 'function') applyDefaultDockLayoutOnce();

  // 初回はプレビュー必ず表示
  const cb = document.getElementById('check-show-preview');
  const pane = document.getElementById('pane-preview');
  if (cb) cb.checked = true;
  if (pane) pane.classList.remove('hidden');

  // レイアウト再計算
  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
  if (typeof updateDockTopOffset === 'function') updateDockTopOffset();

  // プレビュー同期（即時＋次tickでもう一回）
  if (typeof updatePreview === 'function') updatePreview();
  setTimeout(() => {
    if (typeof updatePreview === 'function') updatePreview();
  }, 0);
}


	
function applyDefaultDockLayoutOnce() {
  if (localStorage.getItem('cc_default_layout_applied') === '1') return;

  const c = document.getElementById('main-container');
  const memo = document.getElementById('memo-panel');
  const outline = document.getElementById('outline-panel');
  const memoDock = document.getElementById('check-memo-dock');
  const outlineDock = document.getElementById('check-outline-dock');

  if (!c || !memo || !outline || !memoDock || !outlineDock) return;

  // 左メモ（ドック＆開く）
  memoDock.checked = true;
  c.classList.add('memo-docked');
  c.classList.remove('memo-right');
  memo.classList.add('open');

  // 右目次（ドック＆開く）
  outlineDock.checked = true;
  c.classList.add('outline-docked');
  c.classList.remove('outline-left');
  outline.classList.add('open');

  // 余計な分割状態が残ってたらリセット
  c.classList.remove('dock-split-left', 'dock-split-right');

  if (typeof applyPaneWidthSettings === 'function') applyPaneWidthSettings();
  if (typeof updatePanelButtonStates === 'function') updatePanelButtonStates();
  if (typeof updateDockSplitState === 'function') updateDockSplitState();
  if (typeof updateDockTopOffset === 'function') updateDockTopOffset();
  localStorage.setItem('cc_default_layout_applied', '1');
}
	
// エラー回避：未実装でも落ちないようにする
function updateActiveTabTitle() {}

// 初期化
    loadAutoSave();
    loadTodayStart();
    loadWritingTime();
    loadBookmarks();
    loadMemoTabs();
    loadLayoutSettings();
        if (typeof updateWritingModeButtonLabels === 'function') updateWritingModeButtonLabels();
    loadSettingsFromStorage();
	applyDefaultStartupPrefsOnce();
    loadPaneWidthSettings();
    loadPaneHeightSettings();
    loadDividerSettings();
    loadNovelTitle();
    startWritingTimer();
    applyAllSettings();
	applyDefaultDockLayoutOnce();
    updateDockTopOffset();
    updateDockSplitState();
	if (typeof setupMemoInteractionGuard === 'function') setupMemoInteractionGuard();

    // Apply default preview hidden setting on first load
// 初回（スーパーリロード・初起動）はプレビューを必ず表示
if (!localStorage.getItem('cc_editor_session_started')) {
  const cb = document.getElementById('check-show-preview');
  const pane = document.getElementById('pane-preview');
  if (cb) cb.checked = true;
  if (pane) pane.classList.remove('hidden');
} else {
  // 2回目以降は既存設定に従う（必要なら残す）
  if (settingsCache.defaultPreviewHidden) {
    const cb = document.getElementById('check-show-preview');
    const pane = document.getElementById('pane-preview');
    if (cb) cb.checked = false;
    if (pane) pane.classList.add('hidden');
  }
}

    sessionStorage.setItem('cc_editor_session_started', 'true');
    updateInputStats();
    renderPreviewTabs();
    updatePreview();

	// 起動直後にもう一度だけプレビューを同期（初回/スーパーリロード時の取りこぼし対策）
setTimeout(() => {
  if (typeof updatePreview === 'function') updatePreview();
}, 0);

	
    updatePanelButtonStates();
    updateWritingTimeDisplay();
window.addEventListener('resize', () => {
        updateDockTopOffset();
    });
    </script>

<style>
    /* メモタブのデザイン */
    .memo-tab {
        padding: 4px 12px;
        font-size: 0.85rem;
        cursor: pointer;
        background: #e5e7eb;
        border-radius: 4px 4px 0 0;
        border: 1px solid transparent;
        color: #6b7280;
        user-select: none;
        display: flex; align-items: center; gap: 6px;
        white-space: nowrap;
    }
    .memo-tab.active {
        background: #ffffff;
        color: #1f2937;
        font-weight: bold;
        border-top: 2px solid #2563eb;
        border-bottom: 1px solid #ffffff; /* 下線を消して一体化 */
        margin-bottom: -1px; /* 微調整 */
    }
    .memo-tab-close {
        font-size: 0.7rem; border-radius: 50%; width: 16px; height: 16px;
        display: inline-flex; align-items: center; justify-content: center;
        color: #9ca3af;
    }
    .memo-tab-close:hover { background: #fee2e2; color: #ef4444; }
    .memo-tab-add {
        padding: 4px 8px; cursor: pointer; color: #6b7280; font-weight: bold;
        display: flex; align-items: center;
    }
    .memo-tab-add:hover { color: #2563eb; background: #dbeafe; border-radius: 4px; }
</style>

	<!--
<script>
// メモ操作中フラグ（浮動メモが勝手に閉じないようにする）
window.memoInteracting = false;

function setupMemoInteractionGuard() {
  const memo = document.getElementById('memo-panel');
  if (!memo) return;

  memo.addEventListener('pointerenter', () => window.memoInteracting = true);
  memo.addEventListener('pointerleave', () => window.memoInteracting = false);
  memo.addEventListener('focusin', () => window.memoInteracting = true);
  memo.addEventListener('focusout', () => window.memoInteracting = false);
}
	
    // メモのタブ管理データ
    let memoTabs = [];
    try {
        memoTabs = JSON.parse(localStorage.getItem('cc_memo_tabs')) || [];
    } catch(e) {}

    // データがない場合の初期化
    if (!Array.isArray(memoTabs) || memoTabs.length === 0) {
        memoTabs = [{ id: 'm1', title: 'メモ1', content: '' }];
    }
    
    let currentMemoId = localStorage.getItem('cc_memo_current_id') || memoTabs[0].id;

    // タブを描画する機能
    function renderMemoTabs() {
        const container = document.getElementById('memo-tabs-container');
        if (!container) return; // コンテナがない場合は何もしない
        
        let html = '';
        memoTabs.forEach(tab => {
            const isActive = tab.id === currentMemoId ? 'active' : '';
            html += `
                <div class="memo-tab ${isActive}" onclick="switchMemoTab('${tab.id}')">
                    <span>${tab.title}</span>
                    <span class="memo-tab-close" onclick="deleteMemoTab(event, '${tab.id}')">✕</span>
                </div>
            `;
        });
        // プラスボタン
        html += `<div class="memo-tab-add" onclick="addMemoTab()">＋</div>`;
        container.innerHTML = html;

        // 現在のメモの内容をエリアに表示
        const currentTab = memoTabs.find(t => t.id === currentMemoId);
        const memoArea = document.getElementById('memo-area');
        if (currentTab && memoArea) {
            // 値が違う場合のみ更新（カーソル位置飛び防止）
            if (memoArea.value !== currentTab.content) {
                memoArea.value = currentTab.content;
            }
            updateMemoCharCount();
        }
    }

    // タブを切り替える
    function switchMemoTab(id) {
        saveMemoTabs(); // 切り替え前に保存
        currentMemoId = id;
        localStorage.setItem('cc_memo_current_id', id);
        renderMemoTabs();
    }

    // 新しいタブを追加する
    function addMemoTab() {
        saveMemoTabs();
        const newId = 'm' + Date.now();
        const newNum = memoTabs.length + 1;
        memoTabs.push({ id: newId, title: `メモ${newNum}`, content: '' });
        switchMemoTab(newId);
    }

    // タブを削除する
    function deleteMemoTab(e, id) {
        e.stopPropagation(); 
        if (memoTabs.length <= 1) {
            alert("最後の1つは削除できません");
            return;
        }
        if(!confirm("このメモを削除しますか？")) return;

        memoTabs = memoTabs.filter(t => t.id !== id);
        if (currentMemoId === id) {
            currentMemoId = memoTabs[0].id;
        }
        saveMemoTabs();
        renderMemoTabs();
    }

    // 内容を保存する
    function saveMemoTabs() {
        const currentTab = memoTabs.find(t => t.id === currentMemoId);
        const memoArea = document.getElementById('memo-area');
        if (currentTab && memoArea) {
            currentTab.content = memoArea.value;
        }
        localStorage.setItem('cc_memo_tabs', JSON.stringify(memoTabs));
        localStorage.setItem('cc_memo_current_id', currentMemoId);
    }

/*
    // 文字数カウント
    function updateMemoCharCount() {
        const memoArea = document.getElementById('memo-area');
        const countEl = document.getElementById('memo-char-count');
        if (memoArea && countEl) {
            countEl.innerText = memoArea.value.length + '字';
        }
    }
*/
	
    // 起動時に実行
    setTimeout(renderMemoTabs, 500);
	function updateActiveTabTitle() {
  // TODO: 後で実装。とりあえずエラー回避用
}
</script>
	-->

<script>
// ===== v0.97 integrated patch (2026-01-17) =====
(function(){
  'use strict';

  // -----------------------------
  // 0) Small helpers
  // -----------------------------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const lsGet = (k, d=null) => { try{ const v=localStorage.getItem(k); return v==null?d:JSON.parse(v);}catch(e){ return d; } };
  const lsSet = (k, v) => { try{ localStorage.setItem(k, JSON.stringify(v)); }catch(e){} };
  const escapeHtml = window.escapeHtml || ((s)=>String(s).replace(/[&<>"']/g, m=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])));

  // -----------------------------
  // 1) Disable focus-mode overlay shortcuts (user request)
  // -----------------------------
  try {
    // If function exists globally, make it no-op to avoid shortcut-triggered overlay.
    if (typeof window.openFocusOverlay === 'function') {
      window.openFocusOverlay = function(){ /* disabled */ };
    }
  } catch(e){}

  // -----------------------------
  // 2) "Open" behavior: remove dependency on Settings > Open
  //    - Always ask in modal
  //    - Checkbox "set as default" stores a local default
  // -----------------------------
  const OPEN_DEFAULT_KEY = 'cc_open_default_mode_v2';
  let pendingOpenModeV2 = null;

  function getOpenDefaultMode(){
    const v = localStorage.getItem(OPEN_DEFAULT_KEY);
    return (v === 'new' || v === 'current') ? v : 'current';
  }
  function setOpenDefaultMode(v){
    if (v === 'new' || v === 'current') localStorage.setItem(OPEN_DEFAULT_KEY, v);
  }

  // override openFileWithChoice
  const _openFileWithChoice = window.openFileWithChoice;
  window.openFileWithChoice = function(){
    const modal = document.getElementById('open-choice-modal');
    if (!modal) {
      if (typeof _openFileWithChoice === 'function') return _openFileWithChoice();
      document.getElementById('file-input')?.click();
      return;
    }
    const defaultMode = getOpenDefaultMode();
    const btnCur = document.getElementById('btn-open-choice-current');
    const btnNew = document.getElementById('btn-open-choice-new');
    if (btnCur && btnNew) {
      btnCur.classList.toggle('active', defaultMode === 'current');
      btnNew.classList.toggle('active', defaultMode === 'new');
    }
    const chk = document.getElementById('check-open-set-default');
    if (chk) chk.checked = false;
    modal.classList.add('show');
    modal.setAttribute('aria-hidden', 'false');
  };

  window.closeOpenChoiceModal = function(){
    const modal = document.getElementById('open-choice-modal');
    if (!modal) return;
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden', 'true');
    // do NOT clear pending mode here; only cancel should clear
  };

  window.chooseOpenModeAndPickFile = function(mode){
    pendingOpenModeV2 = mode;
    const chk = document.getElementById('check-open-set-default');
    if (chk && chk.checked) setOpenDefaultMode(mode);
    // close without clearing pending
    const modal = document.getElementById('open-choice-modal');
    if (modal) { modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); }
    setTimeout(()=>document.getElementById('file-input')?.click(),0);
  };

  // Patch loadFile to use pendingOpenModeV2 and OPEN_DEFAULT_KEY only
  const _loadFile = window.loadFile;
  window.loadFile = function(input){
    if (!input || !input.files || !input.files[0]) return;
    // Monkey patch: temporarily set a global used by original loadFile if it relies on pendingOpenMode
    try { window.pendingOpenMode = pendingOpenModeV2; } catch(e){}
    // Call original, but ensure it doesn't fall back to settingsCache.openMode
    // We'll wrap FileReader ourselves to fully control.
    const f = input.files[0];
    const r = new FileReader();
    r.onload = (e)=>{
      const content = e.target.result;

      // Save current tab content
      try{
        if (Array.isArray(window.inputTabs) && window.inputArea && window.activeTabId!=null){
          const currentTab = window.inputTabs.find(t=>t.id===window.activeTabId);
          if (currentTab) currentTab.content = window.inputArea.value;
        }
      }catch(err){}

      const openMode = pendingOpenModeV2 || getOpenDefaultMode();
      pendingOpenModeV2 = null;

      // parse structured tabs (reuse if exists)
      const parseStructuredTabs = window.parseStructuredTabs || function(text, marker){
        const lines = String(text).split(/\r?\n/);
        const rx = new RegExp(`^\${marker}\s*(.*)$`);
        const tabs=[];
        let cur=null;
        for(const line of lines){
          const m=line.match(rx);
          if(m){
            if(cur) tabs.push(cur);
            cur={name:(m[1]||'').trim(), content:''};
          } else if(cur){
            cur.content += (cur.content?"\n":"") + line;
          }
        }
        if(cur) tabs.push(cur);
        return tabs;
      };
      const parsedTabs = parseStructuredTabs(content,'◆');

      if (!Array.isArray(window.inputTabs)) window.inputTabs = [];
      if (typeof window.nextTabId !== 'number') window.nextTabId = (window.inputTabs.reduce((m,t)=>Math.max(m, t.id||0),0) + 1) || 2;
      if (window.inputTabs.length===0){
        window.inputTabs.push({id: window.nextTabId++, name:'タブ1', content:''});
        window.activeTabId = window.inputTabs[0].id;
      }

      const currentTab = window.inputTabs.find(t=>t.id===window.activeTabId) || window.inputTabs[0];

      if (openMode==='current'){
        if (parsedTabs.length>0){
          const first=parsedTabs[0];
          currentTab.name = first.name || currentTab.name || `タブ${currentTab.id}`;
          currentTab.content = first.content;
          for(let i=1;i<parsedTabs.length;i++){
            const tab=parsedTabs[i];
            window.inputTabs.push({id: window.nextTabId++, name: tab.name || `タブ${window.inputTabs.length+1}`, content: tab.content});
          }
        } else {
          currentTab.content = String(content);
        }
        if (window.inputArea) window.inputArea.value = currentTab.content || '';
        if (typeof window.renderInputTabs==='function') window.renderInputTabs();
        if (typeof window.updateInputStats==='function') window.updateInputStats();
      } else {
        // new tab
        if (parsedTabs.length>0){
          for(const tab of parsedTabs){
            window.inputTabs.push({id: window.nextTabId++, name: tab.name || `タブ${window.inputTabs.length+1}`, content: tab.content});
          }
          const last = window.inputTabs[window.inputTabs.length-1];
          window.activeTabId = last.id;
          if (typeof window.switchTab==='function') window.switchTab(last.id);
          else if (window.inputArea) window.inputArea.value = last.content || '';
        } else {
          const name = f.name ? f.name.replace(/\.[^.]+$/,'') : `タブ${window.inputTabs.length+1}`;
          const newTab={id: window.nextTabId++, name, content: String(content)};
          window.inputTabs.push(newTab);
          window.activeTabId = newTab.id;
          if (typeof window.switchTab==='function') window.switchTab(newTab.id);
          else if (window.inputArea) window.inputArea.value = newTab.content;
        }
        if (typeof window.renderInputTabs==='function') window.renderInputTabs();
        if (typeof window.updateInputStats==='function') window.updateInputStats();
      }

      // clear file input so same file can be opened again
      try{ input.value=''; }catch(err){}

      // update outline/preview if available
      try{ if (typeof window.updateOutline==='function') window.updateOutline(); }catch(err){}
      try{ if (typeof window.updatePreview==='function') window.updatePreview(); }catch(err){}
    };
    r.readAsText(f);
  };

  // Hide "Settings > Open" section and neutralize applyOpenSettingsAndSave
  function hideOpenSettings(){
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;
    // Find setting-title that includes "開く" and remove its block
    const titles = $$('.setting-title', settingsBar);
    for (const t of titles){
      if (t.textContent && t.textContent.trim().startsWith('開く')){
        const block = t.closest('.setting-block') || t.parentElement;
        if (block) block.style.display='none';
      }
    }
  }
  window.applyOpenSettingsAndSave = function(){ /* removed */ };

  // -----------------------------
  // 3) Pane colors: per pane background + header, custom priority
  // -----------------------------
  const PANE_COLOR_KEY = 'cc_pane_colors_v3';
  const DEFAULT_PANE_COLORS = {
    input: { bg: null, head: null },
    preview: { bg: null, head: null },
    memo: { bg: null, head: null },
    outline: { bg: null, head: null },
  };

  function getDefaultComputedColors(){
    // Use computed styles from existing theme as defaults
    const cs = getComputedStyle(document.documentElement);
    const panelBg = cs.getPropertyValue('--panel-bg').trim() || '#ffffff';
    const headerBg = cs.getPropertyValue('--pane-header-bg').trim() || '#f9fafb';
    // preview uses --preview-bg-color for body
    const previewBg = cs.getPropertyValue('--preview-bg-color').trim() || panelBg;
    return {
      input: { bg: panelBg, head: headerBg },
      preview: { bg: previewBg, head: headerBg },
      memo: { bg: panelBg, head: headerBg },
      outline: { bg: panelBg, head: headerBg },
    };
  }

  function loadPaneColors(){
    const saved = lsGet(PANE_COLOR_KEY, null);
    if (!saved) return null;
    const out = JSON.parse(JSON.stringify(DEFAULT_PANE_COLORS));
    for (const k of ['input','preview','memo','outline']){
      if (saved[k]){
        out[k].bg = saved[k].bg || null;
        out[k].head = saved[k].head || null;
      }
    }
    return out;
  }

  function applyPaneColors(colors){
    const defaults = getDefaultComputedColors();
    const root = document.documentElement.style;
    const map = {
      input: ['--pane-input-bg','--pane-input-head'],
      preview: ['--pane-preview-bg','--pane-preview-head'],
      memo: ['--pane-memo-bg','--pane-memo-head'],
      outline: ['--pane-outline-bg','--pane-outline-head'],
    };
    for (const k of Object.keys(map)){
      const [bgVar, headVar] = map[k];
      const bg = (colors && colors[k] && colors[k].bg) ? colors[k].bg : defaults[k].bg;
      const head = (colors && colors[k] && colors[k].head) ? colors[k].head : defaults[k].head;
      root.setProperty(bgVar, bg);
      root.setProperty(headVar, head);
    }
  }

  function injectPaneColorCSS(){
    if (document.getElementById('cc-pane-color-style')) return;
    const st = document.createElement('style');
    st.id='cc-pane-color-style';
    st.textContent = `
      /* per-pane colors (custom priority) */
      #pane-input { background: var(--pane-input-bg, var(--panel-bg)); }
      #pane-input .pane-header, #pane-input .pane-subheader, #pane-input .tabs-scroll-wrap { background: var(--pane-input-head, var(--pane-header-bg)); }

      #pane-preview { background: var(--pane-preview-bg, var(--panel-bg)); }
      #pane-preview .pane-header, #pane-preview .pane-subheader, #pane-preview .tabs-scroll-wrap { background: var(--pane-preview-head, var(--pane-header-bg)); }

      #memo-panel { background: var(--pane-memo-bg, var(--panel-bg)); }
      #memo-panel .memo-header, #memo-panel .memo-toolbar { background: var(--pane-memo-head, var(--pane-header-bg)); }

      #outline-panel { background: var(--pane-outline-bg, var(--panel-bg)); }
      #outline-panel .outline-toolbar, #outline-panel .outline-header { background: var(--pane-outline-head, var(--pane-header-bg)); }

      /* Bookmark marker highlight in reader */
      .cc-reader-bm-mark { display:inline-block; margin-right:6px; font-size:0.9em; opacity:0.9; }
      .cc-reader-bm-hit { outline: 2px solid rgba(245, 158, 11, 0.65); outline-offset: 2px; border-radius: 6px; }

      /* Proofread modal */
      #proofread-modal .modal-content { max-width: 760px; }
      #proofread-results { max-height: 52vh; overflow:auto; border: 1px solid var(--border-color); border-radius: 10px; padding: 10px; background: var(--panel-bg); }
      .proof-item { padding: 8px 10px; border-bottom: 1px solid var(--border-color); cursor:pointer; }
      .proof-item:hover { background: rgba(59,130,246,.08); }
      .proof-kind { font-weight: 700; margin-right: 8px; }
      .proof-meta { color: var(--text-muted); font-size: 0.85em; }

      /* Replace preview */
      .replace-preview-row { padding: 8px 10px; border-bottom: 1px solid var(--border-color); display:flex; gap:10px; align-items:flex-start; }
      .replace-preview-row:hover { background: rgba(59,130,246,.06); }
      .rp-snippet { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; font-size: 0.85em; white-space: pre-wrap; word-break: break-word; }
      .rp-after { opacity: 0.9; }
    `;
    document.head.appendChild(st);
  }

  function buildPaneColorSettingsUI(){
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;
    if (document.getElementById('cc-pane-colors-block')) return;

    const block = document.createElement('div');
    block.className='setting-block';
    block.id='cc-pane-colors-block';
    block.innerHTML = `
      <div class="setting-title">ペイン色（背景/ヘッダー）
        <button class="btn btn-apply" id="cc-pane-colors-apply">適用</button>
        <button class="btn" id="cc-pane-colors-reset">リセット</button>
      </div>
      <div class="setting-row" style="flex-direction:column; gap:10px; align-items:stretch;">
        ${['input','preview','memo','outline'].map(k=>{
          const label = ({input:'入力',preview:'プレビュー',memo:'メモ',outline:'目次'})[k];
          return `
          <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
            <div style="min-width:64px; font-weight:700;">${label}</div>
            <label style="display:flex; align-items:center; gap:6px;">背景 <input type="color" id="cc-pane-${k}-bg" style="width:44px; height:28px;">
              <input type="text" id="cc-pane-${k}-bg-t" placeholder="#RRGGBB" style="width:96px;">
            </label>
            <label style="display:flex; align-items:center; gap:6px;">ヘッダー <input type="color" id="cc-pane-${k}-head" style="width:44px; height:28px;">
              <input type="text" id="cc-pane-${k}-head-t" placeholder="#RRGGBB" style="width:96px;">
            </label>
          </div>`;
        }).join('')}
        <div style="font-size:0.85rem; color:var(--text-muted); line-height:1.5;">
          ※「ヘッダー」は <b>ペイン上部 + 位置バー + タブバー</b> も含めてまとめて変更します。
          設定した色はテーマ変更より優先（カスタム優先）です。
        </div>
      </div>
    `;
    // Insert near top of settings (after basic theme?)
    const firstBlock = settingsBar.querySelector('.setting-block');
    if (firstBlock && firstBlock.parentElement) firstBlock.parentElement.insertBefore(block, firstBlock.nextSibling);
    else settingsBar.appendChild(block);

    const syncPair = (colorEl, textEl) => {
      if (!colorEl || !textEl) return;
      colorEl.addEventListener('input', ()=>{ textEl.value = colorEl.value; });
      textEl.addEventListener('change', ()=>{
        const v = textEl.value.trim();
        if (/^#?[0-9a-fA-F]{6}$/.test(v)) {
          const vv = v.startsWith('#')?v:'#'+v;
          colorEl.value = vv;
          textEl.value = vv;
        }
      });
    };

    for (const k of ['input','preview','memo','outline']){
      syncPair(document.getElementById(`cc-pane-${k}-bg`), document.getElementById(`cc-pane-${k}-bg-t`));
      syncPair(document.getElementById(`cc-pane-${k}-head`), document.getElementById(`cc-pane-${k}-head-t`));
    }

    function fillUIFrom(colors){
      const defaults = getDefaultComputedColors();
      for (const k of ['input','preview','memo','outline']){
        const bg = (colors && colors[k] && colors[k].bg) ? colors[k].bg : defaults[k].bg;
        const head = (colors && colors[k] && colors[k].head) ? colors[k].head : defaults[k].head;
        const bgEl = document.getElementById(`cc-pane-${k}-bg`);
        const bgT = document.getElementById(`cc-pane-${k}-bg-t`);
        const hdEl = document.getElementById(`cc-pane-${k}-head`);
        const hdT = document.getElementById(`cc-pane-${k}-head-t`);
        if (bgEl) bgEl.value = bg; if (bgT) bgT.value = bg;
        if (hdEl) hdEl.value = head; if (hdT) hdT.value = head;
      }
    }

    fillUIFrom(loadPaneColors());

    document.getElementById('cc-pane-colors-apply')?.addEventListener('click', ()=>{
      const out = {input:{},preview:{},memo:{},outline:{}};
      for (const k of ['input','preview','memo','outline']){
        const bg = document.getElementById(`cc-pane-${k}-bg-t`)?.value?.trim();
        const head = document.getElementById(`cc-pane-${k}-head-t`)?.value?.trim();
        out[k].bg = (/^#?[0-9a-fA-F]{6}$/.test(bg||'')) ? (bg.startsWith('#') ? bg : ('#'+bg)) : null;
      }
    });
  }

  // The above apply handler had a Pythonic error due to auto-generation risk. We'll implement correctly below:
  function bindPaneColorsApply(){
    const applyBtn = document.getElementById('cc-pane-colors-apply');
    const resetBtn = document.getElementById('cc-pane-colors-reset');
    if (!applyBtn || applyBtn.dataset.bound==='1') return;
    applyBtn.dataset.bound='1';
    applyBtn.addEventListener('click', ()=>{
      const out = {input:{bg:null,head:null},preview:{bg:null,head:null},memo:{bg:null,head:null},outline:{bg:null,head:null}};
      for (const k of ['input','preview','memo','outline']){
        const bg = (document.getElementById(`cc-pane-${k}-bg-t`)?.value||'').trim();
        const head = (document.getElementById(`cc-pane-${k}-head-t`)?.value||'').trim();
        const norm = (v)=>{
          if (!/^#?[0-9a-fA-F]{6}$/.test(v)) return null;
          return v.startsWith('#')?v:'#'+v;
        };
        out[k].bg = norm(bg);
        out[k].head = norm(head);
      }
      lsSet(PANE_COLOR_KEY, out);
      applyPaneColors(out);
    });

    resetBtn?.addEventListener('click', ()=>{
      localStorage.removeItem(PANE_COLOR_KEY);
      applyPaneColors(null);
      // refill UI
      const defaults = getDefaultComputedColors();
      for (const k of ['input','preview','memo','outline']){
        const bgEl = document.getElementById(`cc-pane-${k}-bg`);
        const bgT = document.getElementById(`cc-pane-${k}-bg-t`);
        const hdEl = document.getElementById(`cc-pane-${k}-head`);
        const hdT = document.getElementById(`cc-pane-${k}-head-t`);
        if (bgEl) bgEl.value = defaults[k].bg; if (bgT) bgT.value = defaults[k].bg;
        if (hdEl) hdEl.value = defaults[k].head; if (hdT) hdT.value = defaults[k].head;
      }
    });
  }

  // Re-apply on theme change (custom priority)
  function observeThemeChanges(){
    const obs = new MutationObserver(()=>{
      const colors = loadPaneColors();
      applyPaneColors(colors);
    });
    obs.observe(document.body, {attributes:true, attributeFilter:['class']});
  }

  // -----------------------------
  // 4) Active tab color: default #fff59d + reset button
  // -----------------------------
  const ACTIVE_TAB_COLOR_DEFAULT = '#fff59d';
  const ACTIVE_TAB_COLOR_KEY = 'cc_active_tab_color_v2';

  function applyActiveTabColor(color){
    const c = color || ACTIVE_TAB_COLOR_DEFAULT;
    document.documentElement.style.setProperty('--active-tab-bg', c);
  }
  function loadActiveTabColor(){
    const v = localStorage.getItem(ACTIVE_TAB_COLOR_KEY);
    if (v && /^#([0-9a-fA-F]{6})$/.test(v)) return v;
    return ACTIVE_TAB_COLOR_DEFAULT;
  }
  function saveActiveTabColor(v){
    if (v && /^#([0-9a-fA-F]{6})$/.test(v)) localStorage.setItem(ACTIVE_TAB_COLOR_KEY, v);
  }

  function patchActiveTabColorUI(){
    // Find existing UI: it might already exist. Add reset button next to apply.
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;

    // Locate the block containing "アクティブタブ色"
    const titleEls = $$('.setting-title', settingsBar);
    let targetTitle=null;
    for (const t of titleEls){
      if (t.textContent && t.textContent.includes('アクティブタブ')){ targetTitle=t; break; }
    }
    if (!targetTitle) return;

    // Ensure default stored & applied
    const current = loadActiveTabColor();
    applyActiveTabColor(current);

    // Add reset button if missing
    if (!targetTitle.querySelector('#btn-active-tab-color-reset')){
      const btn = document.createElement('button');
      btn.className='btn';
      btn.id='btn-active-tab-color-reset';
      btn.textContent='リセット';
      btn.style.marginLeft='6px';
      btn.addEventListener('click', ()=>{
        localStorage.setItem(ACTIVE_TAB_COLOR_KEY, ACTIVE_TAB_COLOR_DEFAULT);
        applyActiveTabColor(ACTIVE_TAB_COLOR_DEFAULT);
        // reflect into any inputs
        const inp = document.getElementById('active-tab-color-input');
        const txt = document.getElementById('active-tab-color-text');
        if (inp) inp.value = ACTIVE_TAB_COLOR_DEFAULT;
        if (txt) txt.value = ACTIVE_TAB_COLOR_DEFAULT;
        try{ if (typeof window.renderInputTabs==='function') window.renderInputTabs(); }catch(e){}
      });
      targetTitle.appendChild(btn);
    }

    // Hook apply button if exists
    const applyBtn = targetTitle.querySelector('.btn-apply') || targetTitle.querySelector('button');
    // But avoid messing if already bound; we just ensure storage key and CSS var
    const colorInput = document.getElementById('active-tab-color-input') || document.getElementById('st-active-tab-color');
    if (colorInput){
      // ensure default
      if (!colorInput.value) colorInput.value = current;
      colorInput.addEventListener('input', ()=>{
        const v=colorInput.value;
        applyActiveTabColor(v);
        saveActiveTabColor(v);
        try{ if (typeof window.renderInputTabs==='function') window.renderInputTabs(); }catch(e){}
      });
    }
  }

  // Apply active tab color by overriding existing CSS:
  function injectActiveTabCSS(){
    if (document.getElementById('cc-active-tab-style')) return;
    const st = document.createElement('style');
    st.id='cc-active-tab-style';
    st.textContent = `
      .input-tab.active, .memo-tab.active { background: var(--active-tab-bg, ${ACTIVE_TAB_COLOR_DEFAULT}) !important; }
    `;
    document.head.appendChild(st);
  }

  // -----------------------------
  // 5) Outline settings: move from Settings to Outline gear overlay
  // -----------------------------
  const OUTLINE_RULES_KEY = 'cc_outline_rules_v1';
  function loadOutlineRules(){
    return lsGet(OUTLINE_RULES_KEY, {
      useHash:true, useBox:true, useTri:true, useDia:true, useCir:true, useChapter:true, useCircNum:true, useRoman:true, extra:''
    });
  }
  function saveOutlineRules(r){ lsSet(OUTLINE_RULES_KEY, r); }

  function getOutlineRuleMatchers(r){
    const extra = (r.extra||'').trim();
    const symbols = [];
    if (r.useBox) symbols.push('■','□');
    if (r.useTri) symbols.push('▲');
    if (r.useDia) symbols.push('◆');
    if (r.useCir) symbols.push('○');
    if (extra) symbols.push(...extra.split(''));
    const symSet = symbols.length ? new RegExp(`^[${symbols.map(s=>s.replace(/[-/\^$*+?.()|[\]{}]/g,'\$&')).join('')}]+`) : null;
    const hash = r.useHash ? /^#+\s+/ : null;
    const chapter = r.useChapter ? /^第\s*[^\s]+\s*章/ : null;
    const circ = r.useCircNum ? /^[①②③④⑤⑥⑦⑧⑨⑩⑪⑫⑬⑭⑮⑯⑰⑱⑲⑳]/ : null;
    const roman = r.useRoman ? /^[ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩ]+/ : null;
    return {symSet, hash, chapter, circ, roman};
  }

  // Patch updateOutline builder by filtering lines
  function patchOutlineBuilder(){
    if (typeof window.updateOutline !== 'function') return;
    const original = window.updateOutline;
    if (original.__cc_patched) return;
    function shouldPick(line, matchers){
      const t=line.trim();
      if (!t) return false;
      // existing outline may already parse '#', '■' etc; we only allow if matches any rule
      if (matchers.hash && matchers.hash.test(t)) return true;
      if (matchers.symSet && matchers.symSet.test(t)) return true;
      if (matchers.chapter && matchers.chapter.test(t)) return true;
      if (matchers.circ && matchers.circ.test(t)) return true;
      if (matchers.roman && matchers.roman.test(t)) return true;
      return false;
    }
    window.updateOutline = function(){
      // Let original build the outline items, then filter/hide ones not matching?
      original();
      const rules = loadOutlineRules();
      const m = getOutlineRuleMatchers(rules);
      const list = document.getElementById('outline-list');
      if (!list) return;
      // Each item may have data-rawline? If not, we can't filter reliably. We'll rebuild from stored outlineItems if exists.
      if (Array.isArray(window.outlineItems) && window.outlineItems.length){
        // outlineItems are produced by original; filter by their text
        const kept = window.outlineItems.filter(it=> shouldPick(it.title||it.text||'', m) || it.level===0);
        if (kept.length !== window.outlineItems.length){
          window.outlineItems = kept;
          // Re-render using existing renderOutline if exists
          if (typeof window.renderOutline === 'function') {
            window.renderOutline();
          } else {
            // fallback: no op
          }
        }
      }
    };
    window.updateOutline.__cc_patched = true;
  }

  function addOutlineGearUI(){
    const outlinePanel = document.getElementById('outline-panel');
    if (!outlinePanel) return;
    if (document.getElementById('outline-gear-btn')) return;

    // Find toolbar area
    const toolbar = outlinePanel.querySelector('.outline-toolbar') || outlinePanel.querySelector('.panel-action-buttons')?.parentElement || outlinePanel;
    const btn = document.createElement('button');
    btn.id='outline-gear-btn';
    btn.className='btn';
    btn.textContent='⚙';
    btn.title='目次の抽出ルール';
    btn.style.marginLeft='6px';
    btn.addEventListener('click', ()=> openOutlineRuleModal());

    // Place near existing update button if exists
    const updateBtn = outlinePanel.querySelector('button[onclick*="updateOutline"],button[onclick*="updateAllOutlines"]');
    if (updateBtn && updateBtn.parentElement) updateBtn.parentElement.insertBefore(btn, updateBtn.nextSibling);
    else toolbar.appendChild(btn);

    // build modal
    if (!document.getElementById('outline-rule-modal')){
      const modal = document.createElement('div');
      modal.id='outline-rule-modal';
      modal.className='modal-overlay';
      modal.setAttribute('aria-hidden','true');
      modal.innerHTML = `
        <div class="modal-content" style="max-width:520px;">
          <div class="modal-header"><h3>⚙ 目次の抽出ルール</h3><button class="modal-close" id="btn-outline-rule-close">✕</button></div>
          <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px;">
            <label><input type="checkbox" id="cc-outline-use-hash"> #</label>
            <label><input type="checkbox" id="cc-outline-use-box"> ■□</label>
            <label><input type="checkbox" id="cc-outline-use-tri"> ▲</label>
            <label><input type="checkbox" id="cc-outline-use-dia"> ◆</label>
            <label><input type="checkbox" id="cc-outline-use-cir"> ○</label>
            <label><input type="checkbox" id="cc-outline-use-chapter"> 第○章</label>
            <label><input type="checkbox" id="cc-outline-use-circnum"> ①</label>
            <label><input type="checkbox" id="cc-outline-use-roman"> Ⅰ</label>
          </div>
          <div style="margin-bottom:10px;">
            <label>追加記号: <input type="text" id="cc-outline-extra" placeholder="例: ●★◇" style="width:240px;"></label>
          </div>
          <div style="display:flex; gap:8px; justify-content:flex-end;">
            <button class="btn btn-apply" id="btn-outline-rule-apply">適用</button>
            <button class="btn" id="btn-outline-rule-cancel">キャンセル</button>
          </div>
          <div style="font-size:0.85rem; color:var(--text-muted); margin-top:10px; line-height:1.5;">
            ※設定後、目次を更新すると反映されます（自動更新もします）。
          </div>
        </div>`;
      document.body.appendChild(modal);

      const close = ()=>{ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); };
      $('#btn-outline-rule-close', modal)?.addEventListener('click', close);
      $('#btn-outline-rule-cancel', modal)?.addEventListener('click', close);
      modal.addEventListener('mousedown', (e)=>{ if(e.target===modal) close(); });

      $('#btn-outline-rule-apply', modal)?.addEventListener('click', ()=>{
        const r = {
          useHash: !!$('#cc-outline-use-hash',modal)?.checked,
          useBox: !!$('#cc-outline-use-box',modal)?.checked,
          useTri: !!$('#cc-outline-use-tri',modal)?.checked,
          useDia: !!$('#cc-outline-use-dia',modal)?.checked,
          useCir: !!$('#cc-outline-use-cir',modal)?.checked,
          useChapter: !!$('#cc-outline-use-chapter',modal)?.checked,
          useCircNum: !!$('#cc-outline-use-circnum',modal)?.checked,
          useRoman: !!$('#cc-outline-use-roman',modal)?.checked,
          extra: ($('#cc-outline-extra',modal)?.value||'')
        };
        saveOutlineRules(r);
        close();
        try{ if (typeof window.updateOutline==='function') window.updateOutline(); }catch(e){}
      });
    }

    function openOutlineRuleModal(){
      const modal = document.getElementById('outline-rule-modal');
      if (!modal) return;
      const r = loadOutlineRules();
      $('#cc-outline-use-hash',modal).checked = !!r.useHash;
      $('#cc-outline-use-box',modal).checked = !!r.useBox;
      $('#cc-outline-use-tri',modal).checked = !!r.useTri;
      $('#cc-outline-use-dia',modal).checked = !!r.useDia;
      $('#cc-outline-use-cir',modal).checked = !!r.useCir;
      $('#cc-outline-use-chapter',modal).checked = !!r.useChapter;
      $('#cc-outline-use-circnum',modal).checked = !!r.useCircNum;
      $('#cc-outline-use-roman',modal).checked = !!r.useRoman;
      $('#cc-outline-extra',modal).value = r.extra || '';
      modal.classList.add('show');
      modal.setAttribute('aria-hidden','false');
      setTimeout(()=>$('#cc-outline-extra',modal)?.focus(), 0);
    }
    window.openOutlineRuleModal = openOutlineRuleModal;
  }

  function hideOutlineRulesFromSettings(){
    const settingsBar = document.getElementById('settings-bar');
    if (!settingsBar) return;
    // Find the row with st-outline-use-hash and hide its block
    const el = document.getElementById('st-outline-use-hash');
    if (el){
      const blk = el.closest('.setting-block');
      if (blk) blk.style.display='none';
    }
  }

  // -----------------------------
  // 6) Outline click: also sync preview & reader when available
  // -----------------------------
  function enhanceOutlineClicks(){
    const list = document.getElementById('outline-list');
    if (!list || list.dataset.ccEnhanced==='1') return;
    list.dataset.ccEnhanced='1';

    list.addEventListener('click', (e)=>{
      const item = e.target.closest('.outline-item');
      if (!item) return;
      // existing onclick might already run; we just schedule sync afterwards
      setTimeout(()=>{
        try{
          // Sync preview to cursor line if preview open
          if (typeof window.syncPreviewPosition==='function'){
            // If preview pane hidden, do nothing. We respect user default; but they asked outline click also sync.
            const pvPane = document.getElementById('pane-preview');
            if (pvPane && !pvPane.classList.contains('hidden')) window.syncPreviewPosition();
          }
        }catch(err){}
        try{
          // If reader open, jump to active tab section
          const reader = document.getElementById('reader-overlay');
          if (reader && reader.getAttribute('aria-hidden')==='false'){
            if (typeof window.readerJumpToTabSection==='function') window.readerJumpToTabSection(window.activeTabId);
          }
        }catch(err){}
      }, 0);
    }, true);
  }

  // helper for reader to jump to tab section (by data-tabid)
  window.readerJumpToTabSection = function(tabId){
    const rc = document.getElementById('reader-content');
    const sc = document.getElementById('reader-scroll');
    if (!rc || !sc) return;
    const sec = rc.querySelector(`[data-tabid="${tabId}"]`);
    if (!sec) return;
    sec.classList.add('cc-reader-bm-hit');
    setTimeout(()=>sec.classList.remove('cc-reader-bm-hit'), 900);
    const top = sec.offsetTop - 20;
    sc.scrollTop = Math.max(0, top);
  };

  // -----------------------------
  // 7) Reader bookmarks: show snippet labels & highlight on jump (no 0px)
  // -----------------------------
  function patchReaderBookmarks(){
    if (typeof window.readerAddBookmark !== 'function') return;

    // We'll override readerAddBookmark to use current tab + cursor line snippet
    const _add = window.readerAddBookmark;
    window.readerAddBookmark = function(){
      try{
        // Try to reuse normal bookmarks if exist
        if (typeof window.addBookmark==='function') window.addBookmark();
      }catch(e){}
      // still keep reader's own list for compatibility
      try{ _add(); }catch(e){}
      try{ if (typeof window.renderReaderBookmarks==='function') window.renderReaderBookmarks(); }catch(e){}
    };

    // Override renderReaderBookmarks to show better labels if possible
    const _render = window.renderReaderBookmarks;
    if (typeof _render === 'function' && !_render.__cc_patched){
      window.renderReaderBookmarks = function(){
        _render();
        const sel = document.getElementById('reader-bookmark-select');
        if (!sel) return;
        // If options contain "0px" style, rewrite labels
        for (const opt of Array.from(sel.options)){
          if (!opt.value) continue;
          if (/\d+px/.test(opt.textContent||'')){
            // try map via stored bookmarks in localStorage reader key if exists
            opt.textContent = opt.textContent.replace(/\d+px/g,'');
          }
        }
      };
      window.renderReaderBookmarks.__cc_patched=true;
    }

    // Override readerJumpBookmark: highlight section
    const _jump = window.readerJumpBookmark;
    window.readerJumpBookmark = function(){
      const sel = document.getElementById('reader-bookmark-select');
      const v = sel ? sel.value : '';
      if (!v){ if (typeof _jump==='function') return _jump(); return; }
      try{ if (typeof _jump==='function') _jump(); }catch(e){}
      // attempt to highlight based on bookmark data-tabid attribute if encoded
      try{
        // if value looks like JSON {tabId,pos}
        let data=null;
        try{ data = JSON.parse(v); }catch(e){}
        if (data && data.tabId){
          window.readerJumpToTabSection(data.tabId);
        }
      }catch(e){}
    };

  }

  // -----------------------------
  // 8) Memo context menu & Title context menu
  // -----------------------------
  function addMemoContextMenu(){
    if (!document.getElementById('memo-tabs')) return;
    const tabsBar = document.getElementById('memo-tabs');
    if (tabsBar.dataset.ccCtx==='1') return;
    tabsBar.dataset.ccCtx='1';

    tabsBar.addEventListener('contextmenu', (e)=>{
      const tabEl = e.target.closest('.memo-tab');
      if (!tabEl) return;
      e.preventDefault();
      const tabId = parseInt(tabEl.dataset.id || tabEl.getAttribute('data-id') || tabEl.dataset.tabId || '');
      // reuse existing tab context menu but in memo mode
      const menu = document.getElementById('tab-context-menu');
      if (!menu) return;
      menu.dataset.mode='memo';
      menu.dataset.targetId = String(tabId);
      // Configure menu items: we will set labels and handlers dynamically
      buildContextMenuFor('memo', tabId);
      showContextMenuAt(menu, e.clientX, e.clientY);
    });
  }

  function addTitleContextMenu(){
    const titleEl = document.getElementById('novel-title');
    if (!titleEl || titleEl.dataset.ccCtx==='1') return;
    titleEl.dataset.ccCtx='1';

    // Create menu
    let menu = document.getElementById('title-context-menu');
    if (!menu){
      menu = document.createElement('div');
      menu.id='title-context-menu';
      menu.style.position='fixed';
      menu.style.zIndex='10000';
      menu.style.display='none';
      menu.style.minWidth='180px';
      menu.style.background='var(--panel-bg)';
      menu.style.color='var(--text-color)';
      menu.style.border='1px solid var(--border-color)';
      menu.style.borderRadius='12px';
      menu.style.padding='6px';
      menu.style.boxShadow='0 20px 60px rgba(0,0,0,.25)';
      menu.innerHTML = `
        <button class="cc-title-menu-btn" data-act="rename">✏️ リネーム</button>
        <button class="cc-title-menu-btn" data-act="reset">🧹 初期化（入力）</button>
      `;
      const st = document.createElement('style');
      st.textContent = `
        #title-context-menu button{width:100%;text-align:left;padding:8px 10px;border:none;border-radius:10px;background:transparent;color:inherit;cursor:pointer;}
        #title-context-menu button:hover{background:rgba(59,130,246,.10);}
      `;
      document.head.appendChild(st);
      document.body.appendChild(menu);

      menu.addEventListener('click', (e)=>{
        const btn = e.target.closest('button');
        if (!btn) return;
        const act = btn.dataset.act;
        if (act==='rename'){
          try{ if (typeof window.startEditNovelTitle==='function') window.startEditNovelTitle(); }catch(err){}
        }
        if (act==='reset'){
          titleEl.textContent='入力';
          try{ if (typeof window.saveNovelTitle==='function') window.saveNovelTitle('入力'); }catch(err){}
          try{ localStorage.setItem('novelTitle','入力'); }catch(err){}
        }
        hideTitleMenu();
      });

      document.addEventListener('mousedown', (e)=>{
        if (menu.style.display==='none') return;
        if (!menu.contains(e.target)) hideTitleMenu();
      });
      window.addEventListener('scroll', hideTitleMenu, true);
      window.addEventListener('resize', hideTitleMenu);

      function hideTitleMenu(){ menu.style.display='none'; }
      window.hideTitleMenu = hideTitleMenu;
    }

    titleEl.addEventListener('contextmenu', (e)=>{
      e.preventDefault();
      menu.style.display='block';
      const x = Math.min(e.clientX, window.innerWidth - menu.offsetWidth - 8);
      const y = Math.min(e.clientY, window.innerHeight - menu.offsetHeight - 8);
      menu.style.left = Math.max(8,x)+'px';
      menu.style.top = Math.max(8,y)+'px';
    });
  }

  // Reuse existing context menu show/hide functions if present, else implement
  function showContextMenuAt(menu, x, y){
    if (!menu) return;
    menu.style.display='block';
    const w = menu.offsetWidth || 180;
    const h = menu.offsetHeight || 220;
    const xx = Math.min(x, window.innerWidth - w - 8);
    const yy = Math.min(y, window.innerHeight - h - 8);
    menu.style.left = Math.max(8,xx)+'px';
    menu.style.top = Math.max(8,yy)+'px';
    menu.setAttribute('aria-hidden','false');
  }

  function buildContextMenuFor(mode, id){
    const menu = document.getElementById('tab-context-menu');
    if (!menu) return;
    // Buttons may be pre-defined; we rewrite the inner HTML to avoid dependency
    menu.innerHTML = '';
    const addBtn = (label, fn)=>{
      const b=document.createElement('button');
      b.textContent=label;
      b.addEventListener('click', ()=>{ hideContextMenu(); fn(); });
      menu.appendChild(b);
    };
    const addHr = ()=>{ const hr=document.createElement('hr'); menu.appendChild(hr); };

    function hideContextMenu(){
      menu.style.display='none';
      menu.setAttribute('aria-hidden','true');
    }
    window.hideContextMenu = window.hideContextMenu || hideContextMenu;

    if (mode==='memo'){
      addBtn('＋ 新規メモタブ', ()=>{ try{ if (typeof window.addNewMemoTab==='function') window.addNewMemoTab(); }catch(e){} });
      addBtn('✏️ リネーム', ()=>{ try{ if (typeof window.renameMemoTab==='function') window.renameMemoTab(id); }catch(e){} });
      addBtn('📄 複製', ()=>{ try{ if (typeof window.duplicateMemoTab==='function') window.duplicateMemoTab(id); }catch(e){} });
      addHr();
      addBtn('✕ 閉じる', ()=>{ try{ if (typeof window.closeMemoTab==='function') window.closeMemoTab(id); }catch(e){} });
    } else {
      // default (input)
      addBtn('＋ 新規タブ', ()=>{ try{ if (typeof window.addNewTab==='function') window.addNewTab(); }catch(e){} });
      addBtn('✏️ リネーム', ()=>{ try{ if (typeof window.renameTab==='function') window.renameTab(id); }catch(e){} });
      addBtn('📄 複製', ()=>{ try{ if (typeof window.duplicateTab==='function') window.duplicateTab(id); }catch(e){} });
      addHr();
      addBtn('✕ 閉じる', ()=>{ try{ if (typeof window.closeTab==='function') window.closeTab(id); }catch(e){} });
    }

    // close on outside click
    setTimeout(()=>{
      const onDown = (ev)=>{ if (!menu.contains(ev.target)) { hideContextMenu(); document.removeEventListener('mousedown', onDown, true); } };
      document.addEventListener('mousedown', onDown, true);
    },0);
  }

  // -----------------------------
  // 9) Proofreading button + modal (E-1/E-2)
  // -----------------------------
  function injectProofreadUI(){
    // Add button next to analysis
    const headerLeft = document.querySelector('.header-left');
    if (!headerLeft) return;
    if (!document.getElementById('btn-proofread')){
      const btn = document.createElement('button');
      btn.className='btn btn-analysis';
      btn.id='btn-proofread';
      btn.textContent='🧹 校正';
      btn.addEventListener('click', openProofreadModal);
      // insert before analysis button if present
      const analysisBtn = headerLeft.querySelector('button.btn-analysis');
      if (analysisBtn && analysisBtn.parentElement) analysisBtn.parentElement.insertBefore(btn, analysisBtn);
      else headerLeft.appendChild(btn);
    }

    if (document.getElementById('proofread-modal')) return;
    const modal = document.createElement('div');
    modal.id='proofread-modal';
    modal.className='modal-overlay';
    modal.setAttribute('aria-hidden','true');
    modal.innerHTML = `
      <div class="modal-content">
        <div class="modal-header"><h3>🧹 校正</h3><button class="modal-close" id="btn-proofread-close">✕</button></div>
        <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px;">
          <label><input type="checkbox" id="pf-unclosed" checked> 会話の「」未閉じ / 括弧未閉じ</label>
          <label><input type="checkbox" id="pf-sentend" checked> 「。」等の不足候補</label>
          <span style="margin-left:auto;">
            <select id="pf-scope" style="height:30px; border-radius:10px; border:1px solid var(--border-color); padding:0 8px; background:var(--panel-bg); color:var(--text-color);">
              <option value="current">このタブ</option>
              <option value="all">全タブ</option>
            </select>
          </span>
        </div>
        <div style="display:flex; gap:8px; justify-content:flex-end; margin-bottom:10px;">
          <button class="btn btn-apply" id="btn-proofread-run">チェック開始</button>
        </div>
        <div id="proofread-results"><div class="outline-empty">まだ結果はありません</div></div>
        <div style="font-size:0.85rem; color:var(--text-muted); margin-top:10px; line-height:1.5;">
          ※結果をクリックすると該当箇所へジャンプします。
        </div>
      </div>`;
    document.body.appendChild(modal);

    const close = ()=>{ modal.classList.remove('show'); modal.setAttribute('aria-hidden','true'); };
    $('#btn-proofread-close', modal)?.addEventListener('click', close);
    modal.addEventListener('mousedown', (e)=>{ if (e.target===modal) close(); });
    document.addEventListener('keydown', (e)=>{ if (modal.classList.contains('show') && e.key==='Escape'){ e.preventDefault(); close(); } });
    $('#btn-proofread-run', modal)?.addEventListener('click', runProofread);
  }

  function openProofreadModal(){
    const modal = document.getElementById('proofread-modal');
    if (!modal) return;
    modal.classList.add('show');
    modal.setAttribute('aria-hidden','false');
  }

  function getTabsByScope(scope){
    const tabs = Array.isArray(window.inputTabs) ? window.inputTabs : [];
    if (scope==='current'){
      const t = tabs.find(t=>t.id===window.activeTabId);
      return t ? [t] : [];
    }
    return tabs.slice();
  }

  function calcLineInfo(text, pos){
    const before = text.slice(0,pos);
    const lineNum = (before.match(/\n/g)||[]).length + 1;
    const lineStart = before.lastIndexOf('\n')+1;
    const lineEnd = text.indexOf('\n', pos);
    const lineText = text.slice(lineStart, lineEnd===-1?text.length:lineEnd);
    return {lineNum, lineText: lineText.trim(), lineStart};
  }

  function checkUnclosed(text){
    const opens = {'「':'」','『':'』','（':'）','【':'】','《':'》','〔':'〕'};
    const closes = Object.fromEntries(Object.entries(opens).map(([o,c])=>[c,o]));
    const stack=[];
    const res=[];
    for (let i=0;i<text.length;i++){
      const ch=text[i];
      if (opens[ch]){
        stack.push({ch, pos:i});
      } else if (closes[ch]){
        if (stack.length && stack[stack.length-1].ch===closes[ch]){
          stack.pop();
        } else {
          res.push({pos:i, msg:`閉じ記号「${ch}」が対応していません`});
        }
      }
    }
    for (const it of stack){
      res.push({pos:it.pos, msg:`開き記号「${it.ch}」が閉じられていません`});
    }
    return res;
  }

  function checkSentenceEnd(text){
    // Heuristic: lines ending with Japanese letter/kanji/quote close without 。！？…」 etc
    const lines = text.split(/\r?\n/);
    const res=[];
    let offset=0;
    const okEnd = /[。！？…」』）】》〕]$/;
    for (const line of lines){
      const t=line.trim();
      if (t.length>=8 && !okEnd.test(t)){
        // skip headings like '■' or '#'
        if (/^(#|■|□|▲|◆|○)/.test(t)) { offset += line.length+1; continue; }
        // likely sentence
        res.push({pos: offset + Math.max(0,line.lastIndexOf(t)), msg:'文末記号（。！？など）が不足しているかもしれません'});
      }
      offset += line.length + 1;
    }
    return res;
  }

  function runProofread(){
    const modal = document.getElementById('proofread-modal');
    const scope = $('#pf-scope',modal)?.value || 'current';
    const doUnclosed = !!$('#pf-unclosed',modal)?.checked;
    const doEnd = !!$('#pf-sentend',modal)?.checked;
    const results=[];
    for (const tab of getTabsByScope(scope)){
      const text = tab.id===window.activeTabId ? (window.inputArea?.value ?? tab.content ?? '') : (tab.content ?? '');
      if (doUnclosed){
        for (const r of checkUnclosed(text)){
          const li = calcLineInfo(text, r.pos);
          results.push({kind:'未閉じ', tabId: tab.id, tabName: tab.name||'', pos:r.pos, lineNum: li.lineNum, preview: li.lineText.slice(0,50), msg:r.msg});
        }
      }
      if (doEnd){
        for (const r of checkSentenceEnd(text)){
          const li = calcLineInfo(text, r.pos);
          results.push({kind:'文末', tabId: tab.id, tabName: tab.name||'', pos:r.pos, lineNum: li.lineNum, preview: li.lineText.slice(0,50), msg:r.msg});
        }
      }
    }

    const box = document.getElementById('proofread-results');
    if (!box) return;
    box.innerHTML='';
    if (!results.length){
      box.innerHTML = '<div class="outline-empty">問題は見つかりませんでした</div>';
      return;
    }
    results.sort((a,b)=>a.tabId-b.tabId || a.pos-b.pos);
    for (const r of results.slice(0,500)){
      const div=document.createElement('div');
      div.className='proof-item';
      div.innerHTML = `<span class="proof-kind">${escapeHtml(r.kind)}</span> <span>${escapeHtml(r.msg)}</span><div class="proof-meta">【${escapeHtml(r.tabName||('タブ'+r.tabId))}】${r.lineNum}行: ${escapeHtml(r.preview||'')}</div>`;
      div.addEventListener('click', ()=>{
        try{
          if (typeof window.switchTab==='function' && r.tabId!=null && r.tabId!==window.activeTabId) window.switchTab(r.tabId);
          const ta = window.inputArea;
          if (ta){
            ta.focus();
            ta.setSelectionRange(r.pos, Math.min((r.pos+1), ta.value.length));
            if (typeof window.scrollToCursorPosition==='function') setTimeout(()=>window.scrollToCursorPosition(r.pos),50);
            if (typeof window.updateCursorLineDisplay==='function') window.updateCursorLineDisplay();
          }
        }catch(e){}
      });
      box.appendChild(div);
    }
    if (results.length>500){
      const note=document.createElement('div');
      note.className='outline-empty';
      note.textContent = `表示は500件まで（全${results.length}件）`;
      box.appendChild(note);
    }
  }

  // -----------------------------
  // 10) Search/Replace: scope current/all + hits list + replace preview
  // -----------------------------
  let ccSearchMatches = [];
  let ccSearchIndex = -1;
  let ccLastQuery = '';
  let ccLastScope = 'current';

  function collectMatches(query, scope){
    const esc = query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const rx = new RegExp(esc, 'g');
    const matches=[];
    const tabs = Array.isArray(window.inputTabs)?window.inputTabs:[];
    const tabList = (scope==='all') ? tabs : [tabs.find(t=>t.id===window.activeTabId)].filter(Boolean);
    for (const tab of tabList){
      const text = tab.id===window.activeTabId ? (window.inputArea?.value ?? tab.content ?? '') : (tab.content ?? '');
      let m;
      while((m=rx.exec(text))!==null){
        const pos=m.index;
        const li=calcLineInfo(text, pos);
        matches.push({tabId: tab.id, tabName: tab.name||'', start:pos, end:pos+m[0].length, lineNum:li.lineNum, preview:li.lineText.slice(0,80)});
        if (m[0].length===0) rx.lastIndex++;
      }
    }
    return matches;
  }

  function updateSearchUI(){
    const info = document.getElementById('search-match-info');
    if (info) info.textContent = `${ccSearchMatches.length? (ccSearchIndex+1):0} / ${ccSearchMatches.length}`;
  }

  function renderHitList(){
    const box = document.getElementById('search-hits');
    if (!box) return;
    box.innerHTML='';
    if (!ccLastQuery){
      box.innerHTML = '<div class="outline-empty">ヒット一覧はここに表示されます</div>';
      return;
    }
    if (!ccSearchMatches.length){
      box.innerHTML = '<div class="outline-empty">ヒットなし</div>';
      return;
    }

    const maxShow = 300;
    const matches = ccSearchMatches.slice(0, maxShow);
    const grouped = {};
    for (const m of matches){
      (grouped[m.tabId] ||= {name:m.tabName||('タブ'+m.tabId), items:[]}).items.push(m);
    }

    for (const [tabId, g] of Object.entries(grouped)){
      const head=document.createElement('div');
      head.style.fontWeight='700';
      head.style.margin='6px 0 2px';
      head.textContent = `【${g.name}】 (${g.items.length})`;
      box.appendChild(head);
      for (const m of g.items){
        const div=document.createElement('div');
        div.className='bookmark-item';
        div.style.cursor='pointer';
        div.innerHTML = `🔎 ${m.lineNum}行: ${escapeHtml(m.preview)}`;
        div.addEventListener('click', ()=> jumpToMatch(m));
        box.appendChild(div);
      }
    }

    if (ccSearchMatches.length>maxShow){
      const note=document.createElement('div');
      note.className='outline-empty';
      note.textContent = `表示は${maxShow}件まで（全${ccSearchMatches.length}件）`;
      box.appendChild(note);
    }

    // Add replace preview controls
    const pvBtn = document.createElement('button');
    pvBtn.className='btn';
    pvBtn.textContent='置換プレビュー';
    pvBtn.style.marginTop='8px';
    pvBtn.addEventListener('click', showReplacePreview);
    box.appendChild(pvBtn);
  }

  function jumpToMatch(m){
    try{
      if (m.tabId!==window.activeTabId && typeof window.switchTab==='function') window.switchTab(m.tabId);
      const ta=window.inputArea;
      if (!ta) return;
      ta.focus();
      ta.setSelectionRange(m.start, m.end);
      if (typeof window.scrollToCursorPosition==='function') setTimeout(()=>window.scrollToCursorPosition(m.start), 60);
      if (typeof window.updateCursorLineDisplay==='function') window.updateCursorLineDisplay();
      ccSearchIndex = ccSearchMatches.findIndex(x=>x.tabId===m.tabId && x.start===m.start && x.end===m.end);
      updateSearchUI();
    }catch(e){}
  }

  window.doSearch = function(){
    const q = (document.getElementById('search-input')?.value||'');
    const scope = document.getElementById('search-scope')?.value || 'current';
    ccLastQuery = q;
    ccLastScope = scope;
    if (!q){
      ccSearchMatches=[]; ccSearchIndex=-1;
      updateSearchUI();
      renderHitList();
      return;
    }
    ccSearchMatches = collectMatches(q, scope);
    ccSearchIndex = ccSearchMatches.length?0:-1;
    updateSearchUI();
    renderHitList();
    if (ccSearchIndex>=0) jumpToMatch(ccSearchMatches[0]);
  };

  window.findNext = function(){
    if (!ccSearchMatches.length) return;
    ccSearchIndex = (ccSearchIndex+1) % ccSearchMatches.length;
    jumpToMatch(ccSearchMatches[ccSearchIndex]);
  };
  window.findPrev = function(){
    if (!ccSearchMatches.length) return;
    ccSearchIndex = (ccSearchIndex-1 + ccSearchMatches.length) % ccSearchMatches.length;
    jumpToMatch(ccSearchMatches[ccSearchIndex]);
  };

  window.replaceOne = function(){
    const q = (document.getElementById('search-input')?.value||'');
    const rep = (document.getElementById('replace-input')?.value||'');
    if (!q) return;
    if (!ccSearchMatches.length || ccSearchIndex<0) window.doSearch();
    if (!ccSearchMatches.length) return;
    const m = ccSearchMatches[ccSearchIndex];
    const tabs = window.inputTabs||[];
    const tab = tabs.find(t=>t.id===m.tabId);
    if (!tab) return;
    const ta = window.inputArea;
    let text = (m.tabId===window.activeTabId && ta) ? ta.value : (tab.content||'');
    // verify substring
    if (text.slice(m.start, m.end)!==q){
      // re-search
      window.doSearch();
      return;
    }
    text = text.slice(0,m.start) + rep + text.slice(m.end);
    if (m.tabId===window.activeTabId && ta){ ta.value=text; }
    tab.content = text;
    try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
    // re-search to refresh
    window.doSearch();
  };

  window.replaceAll = function(){
    const q = (document.getElementById('search-input')?.value||'');
    const rep = (document.getElementById('replace-input')?.value||'');
    if (!q) return;
    if (!ccSearchMatches.length) window.doSearch();
    const count = ccSearchMatches.length;
    if (!count) return;
    if (!confirm(`${count}件を全置換しますか？（範囲: ${ccLastScope==='all'?'全タブ':'このタブ'}）`)) return;
    const tabs = window.inputTabs||[];
    const tabIds = new Set(ccSearchMatches.map(m=>m.tabId));
    for (const tabId of tabIds){
      const tab = tabs.find(t=>t.id===tabId);
      if (!tab) continue;
      const ta=window.inputArea;
      let text = (tabId===window.activeTabId && ta) ? ta.value : (tab.content||'');
      text = text.split(q).join(rep);
      if (tabId===window.activeTabId && ta) ta.value=text;
      tab.content=text;
    }
    try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
    window.doSearch();
  };

  function showReplacePreview(){
    const q = (document.getElementById('search-input')?.value||'');
    const rep = (document.getElementById('replace-input')?.value||'');
    if (!q) return;
    if (!ccSearchMatches.length) window.doSearch();
    if (!ccSearchMatches.length) return;
    const box = document.getElementById('search-hits');
    if (!box) return;

    // Clear and build preview list
    box.innerHTML='';
    const top = document.createElement('div');
    top.style.display='flex';
    top.style.gap='8px';
    top.style.flexWrap='wrap';
    top.style.alignItems='center';
    top.style.marginBottom='8px';
    top.innerHTML = `<div style="font-weight:700;">置換プレビュー（${ccSearchMatches.length}件）</div>`;
    const btnApply = document.createElement('button');
    btnApply.className='btn btn-apply';
    btnApply.textContent='チェック分を適用';
    const btnAll = document.createElement('button');
    btnAll.className='btn';
    btnAll.textContent='全部適用';
    const btnBack = document.createElement('button');
    btnBack.className='btn';
    btnBack.textContent='戻る';
    top.appendChild(btnApply);
    top.appendChild(btnAll);
    top.appendChild(btnBack);
    box.appendChild(top);

    const max=200;
    const rows=[];
    for (const m of ccSearchMatches.slice(0,max)){
      const row=document.createElement('div');
      row.className='replace-preview-row';
      row.dataset.tabId = String(m.tabId);
      row.dataset.start = String(m.start);
      row.dataset.end = String(m.end);
      const cb=document.createElement('input');
      cb.type='checkbox'; cb.checked=true;
      cb.style.marginTop='4px';
      const info=document.createElement('div');
      info.style.flex='1';
      const before = m.preview;
      const after = before.replace(q, rep);
      info.innerHTML = `<div class="proof-meta">【${escapeHtml(m.tabName||('タブ'+m.tabId))}】${m.lineNum}行</div>
        <div class="rp-snippet">${escapeHtml(before)}</div>
        <div class="rp-snippet rp-after">→ ${escapeHtml(after)}</div>`;
      row.appendChild(cb);
      row.appendChild(info);
      row.addEventListener('click', (ev)=>{ if(ev.target.tagName==='INPUT') return; jumpToMatch(m); });
      box.appendChild(row);
      rows.push({row, cb, m});
    }
    if (ccSearchMatches.length>max){
      const note=document.createElement('div');
      note.className='outline-empty';
      note.textContent = `プレビューは${max}件まで（全${ccSearchMatches.length}件）。`;
      box.appendChild(note);
    }

    const applySelection = (onlyChecked)=>{
      const targets = onlyChecked ? rows.filter(r=>r.cb.checked).map(r=>r.m) : ccSearchMatches.slice();
      const count = targets.length;
      if (!count) return;
      if (!confirm(`${count}件を置換しますか？`)) return;
      const tabs=window.inputTabs||[];
      // group by tab and apply from end to start to keep indices stable
      const byTab={};
      for(const m of targets){ (byTab[m.tabId] ||= []).push(m); }
      for (const [tabIdS, ms] of Object.entries(byTab)){
        const tabId=parseInt(tabIdS);
        const tab=tabs.find(t=>t.id===tabId);
        if(!tab) continue;
        const ta=window.inputArea;
        let text = (tabId===window.activeTabId && ta) ? ta.value : (tab.content||'');
        // sort descending
        ms.sort((a,b)=>b.start-a.start);
        for(const m of ms){
          if(text.slice(m.start,m.end)===q){
            text = text.slice(0,m.start)+rep+text.slice(m.end);
          }
        }
        if (tabId===window.activeTabId && ta) ta.value=text;
        tab.content=text;
      }
      try{ if(typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
      window.doSearch();
    };

    btnApply.addEventListener('click', ()=>applySelection(true));
    btnAll.addEventListener('click', ()=>applySelection(false));
    btnBack.addEventListener('click', ()=>renderHitList());
  }

  // Ensure Ctrl+F opens panel still uses doSearch

  // -----------------------------
  // 11) Writing speed (chars/min or chars/hour) using tracker
  // -----------------------------
  const SPEED_MODE_KEY='cc_speed_mode_v1';
  function getSpeedMode(){ return localStorage.getItem(SPEED_MODE_KEY)==='hour' ? 'hour' : 'min'; }
  function setSpeedMode(m){ localStorage.setItem(SPEED_MODE_KEY, m==='hour'?'hour':'min'); }

  function calcTodayChars(){
    try{
      // Use existing "today baseline" if present
      if (typeof window.getTodayKey==='function' && typeof window.getTabBaseline==='function'){
        // Not sure; fallback
      }
    }catch(e){}
    // Fallback: sum of current tabs lengths
    const tabs=window.inputTabs||[];
    let total=0;
    for (const t of tabs){
      const text = (t.id===window.activeTabId ? (window.inputArea?.value ?? t.content ?? '') : (t.content ?? ''));
      total += String(text).replace(/[\s　]+/g,'').length;
    }
    return total;
  }

  function injectSpeedUI(){
    // Add to header (right) maybe near writing time display if exists
    const el = document.getElementById('writing-time-display');
    if (!el) return;
    if (document.getElementById('writing-speed-display')) return;
    const sp=document.createElement('span');
    sp.id='writing-speed-display';
    sp.style.marginLeft='10px';
    sp.style.fontWeight='700';
    sp.style.color='var(--text-muted)';
    sp.style.cursor='pointer';
    sp.title='クリックで字/分 ⇄ 字/時';
    sp.addEventListener('click', ()=>{
      const next = getSpeedMode()==='min' ? 'hour' : 'min';
      setSpeedMode(next);
      updateSpeedDisplay();
    });
    el.parentElement?.appendChild(sp);
    updateSpeedDisplay();
  }

  function updateSpeedDisplay(){
    const sp=document.getElementById('writing-speed-display');
    if (!sp) return;
    const sec = window.writingSeconds || 0;
    if (!sec){ sp.textContent=''; return; }
    const chars = calcTodayChars();
    const mode = getSpeedMode();
    const minutes = sec/60;
    const hours = sec/3600;
    const val = mode==='hour' ? (hours? (chars/hours):0) : (minutes? (chars/minutes):0);
    const unit = mode==='hour' ? '字/時' : '字/分';
    sp.textContent = `｜速度: ${val.toFixed(1)}${unit}`;
  }

  // Hook into updateWritingTimeDisplay if exists
  function hookWritingTime(){
    if (typeof window.updateWritingTimeDisplay !== 'function') return;
    const orig = window.updateWritingTimeDisplay;
    if (orig.__cc_speed) return;
    window.updateWritingTimeDisplay = function(){
      orig();
      updateSpeedDisplay();
    };
    window.updateWritingTimeDisplay.__cc_speed = true;
  }

  // -----------------------------
  // 12) Fix reset showing memo/outline swap buttons: ensure updateDockPanelButton called
  // -----------------------------
  function patchResetHooks(){
    const orig = window.resetAll;
    if (typeof orig !== 'function' || orig.__cc_patched) return;
    window.resetAll = function(){
      orig();
      try{ if (typeof window.updateDockPanelButton==='function'){
        window.updateDockPanelButton('memo-panel','btn-toggle-memo','check-memo-dock');
        window.updateDockPanelButton('outline-panel','btn-toggle-outline','check-outline-dock');
      }}catch(e){}
    };
    window.resetAll.__cc_patched = true;
  }

  // -----------------------------
  // Init
  // -----------------------------
  function init(){
    injectPaneColorCSS();
    applyPaneColors(loadPaneColors());
    observeThemeChanges();

    hideOpenSettings();
    hideOutlineRulesFromSettings();
    addOutlineGearUI();
    patchOutlineBuilder();

    injectActiveTabCSS();
    applyActiveTabColor(loadActiveTabColor());
    patchActiveTabColorUI();

    injectProofreadUI();
    enhanceOutlineClicks();
    patchReaderBookmarks();
    addMemoContextMenu();
    addTitleContextMenu();

    // pane colors settings UI
    try{
      // create UI block and bind
      if (!document.getElementById('cc-pane-colors-block')){
        // We place after initial blocks by appending at end to be safe
        const settingsBar = document.getElementById('settings-bar');
        if (settingsBar){
          // create block
          const block = document.createElement('div');
          block.className='setting-block';
          block.id='cc-pane-colors-block';
          block.innerHTML = `
            <div class="setting-title">ペイン色（背景/ヘッダー）
              <button class="btn btn-apply" id="cc-pane-colors-apply">適用</button>
              <button class="btn" id="cc-pane-colors-reset">リセット</button>
            </div>
            <div class="setting-row" style="flex-direction:column; gap:10px; align-items:stretch;">
              ${['input','preview','memo','outline'].map(k=>{
                const label = ({input:'入力',preview:'プレビュー',memo:'メモ',outline:'目次'})[k];
                return `
                <div style="display:flex; flex-wrap:wrap; gap:10px; align-items:center;">
                  <div style="min-width:64px; font-weight:700;">${label}</div>
                  <label style="display:flex; align-items:center; gap:6px;">背景 <input type="color" id="cc-pane-${k}-bg" style="width:44px; height:28px;">
                    <input type="text" id="cc-pane-${k}-bg-t" placeholder="#RRGGBB" style="width:96px;">
                  </label>
                  <label style="display:flex; align-items:center; gap:6px;">ヘッダー <input type="color" id="cc-pane-${k}-head" style="width:44px; height:28px;">
                    <input type="text" id="cc-pane-${k}-head-t" placeholder="#RRGGBB" style="width:96px;">
                  </label>
                </div>`;
              }).join('')}
              <div style="font-size:0.85rem; color:var(--text-muted); line-height:1.5;">
                ※「ヘッダー」は <b>ペイン上部 + 位置バー + タブバー</b> を含みます。テーマ変更より優先（カスタム優先）。
              </div>
            </div>`;
          settingsBar.appendChild(block);
        }
      }
      // bind and populate
      const defaults = getDefaultComputedColors();
      const saved = loadPaneColors();
      const use = saved || null;
      const norm = (v)=>{ if(!v) return null; return v.startsWith('#')?v:'#'+v; };
      for (const k of ['input','preview','memo','outline']){
        const bg = (use && use[k] && use[k].bg) ? use[k].bg : defaults[k].bg;
        const head = (use && use[k] && use[k].head) ? use[k].head : defaults[k].head;
        const bgEl = document.getElementById(`cc-pane-${k}-bg`);
        const bgT = document.getElementById(`cc-pane-${k}-bg-t`);
        const hdEl = document.getElementById(`cc-pane-${k}-head`);
        const hdT = document.getElementById(`cc-pane-${k}-head-t`);
        if (bgEl) bgEl.value = bg; if (bgT) bgT.value = bg;
        if (hdEl) hdEl.value = head; if (hdT) hdT.value = head;
        // sync
        if (bgEl && bgT){
          bgEl.addEventListener('input', ()=>{ bgT.value = bgEl.value; });
          bgT.addEventListener('change', ()=>{ const v=bgT.value.trim(); if(/^#?[0-9a-fA-F]{6}$/.test(v)){ const vv=norm(v); bgEl.value=vv; bgT.value=vv; } });
        }
        if (hdEl && hdT){
          hdEl.addEventListener('input', ()=>{ hdT.value = hdEl.value; });
          hdT.addEventListener('change', ()=>{ const v=hdT.value.trim(); if(/^#?[0-9a-fA-F]{6}$/.test(v)){ const vv=norm(v); hdEl.value=vv; hdT.value=vv; } });
        }
      }
      bindPaneColorsApply();
    }catch(e){}

    hookWritingTime();
    injectSpeedUI();
    patchResetHooks();

    // Remove settings hint in open modal if still present
    try{
      const modal=document.getElementById('open-choice-modal');
      if(modal){
        const hint = modal.querySelector('div[style*="font-size:0.8rem"]');
        if(hint){ hint.innerHTML = hint.innerHTML.replace(/※既定は[^<]*<br\s*\/>?/,''); }
      }
    }catch(e){}
  }

  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();

</script>


<!-- ===== v0.97 fix2 patches (reader bookmarks/search, active tab color reliable apply, per-tab stats, disable focus shortcuts) ===== -->
<script>
(()=>{
  'use strict';
  const $ = (sel, root=document)=>root.querySelector(sel);

  // ---------- 1) Reader: make search/bookmarks reliable and human-readable ----------
  const READER_BM_KEY_V2 = 'cc_reader_bookmarks_v2';
  function loadBMs(){
    try{
      const raw = localStorage.getItem(READER_BM_KEY_V2) || localStorage.getItem('cc_reader_bookmarks_v1');
      const b = raw ? JSON.parse(raw) : [];
      return Array.isArray(b) ? b : [];
    }catch(e){ return []; }
  }
  function saveBMs(bms){
    try{ localStorage.setItem(READER_BM_KEY_V2, JSON.stringify(bms)); }catch(e){}
  }
  function getReaderEls(){
    return {
      overlay: document.getElementById('reader-overlay'),
      scroll: document.getElementById('reader-scroll'),
      content: document.getElementById('reader-content'),
      input: document.getElementById('reader-search-input'),
      info: document.getElementById('reader-search-info'),
      select: document.getElementById('reader-bookmark-select'),
    };
  }
  function readerSections(){
    const {content} = getReaderEls();
    return content ? Array.from(content.querySelectorAll('.reader-section')) : [];
  }
  function findSectionAt(scrollTop){
    const secs = readerSections();
    if (!secs.length) return {idx:0, offset:0};
    let idx=0;
    for (let i=0;i<secs.length;i++){
      if (secs[i].offsetTop <= scrollTop + 6) idx=i;
      else break;
    }
    const off = Math.max(0, scrollTop - secs[idx].offsetTop);
    return {idx, offset: off};
  }
  function getTabName(idx){
    try{
      const t = window.inputTabs?.[idx];
      return (t?.name || `タブ${idx+1}`);
    }catch(e){ return `タブ${idx+1}`; }
  }
  function excerptFromTab(idx, ratio){
    try{
      const t = window.inputTabs?.[idx];
      const s = String(t?.content||'');
      if (!s.trim()) return '';
      const lines = s.split(/\r?\n/).map(x=>x.trim()).filter(Boolean);
      if (!lines.length) return '';
      const pick = lines[Math.min(lines.length-1, Math.floor(ratio*lines.length))];
      return pick.length>24 ? pick.slice(0,24)+'…' : pick;
    }catch(e){ return ''; }
  }

  function renderReaderBookmarkSelect(){
    const {select} = getReaderEls();
    if (!select) return;
    const bms = loadBMs();
    select.innerHTML = '<option value="">しおりへ…</option>';
    bms.forEach((b,i)=>{
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = b.label || `しおり${i+1}`;
      select.appendChild(opt);
    });
  }

  function renderReaderBookmarkPins(){
    const {content} = getReaderEls();
    if (!content) return;
    content.querySelectorAll('.reader-bm-pin').forEach(n=>n.remove());
    const bms = loadBMs();
    const secs = readerSections();
    bms.forEach((b,i)=>{
      const si = Number(b.sectionIndex);
      if (!Number.isFinite(si) || !secs[si]) return;
      const sec = secs[si];
      sec.style.position = 'relative';
      const pin = document.createElement('div');
      pin.className = 'reader-bm-pin';
      pin.textContent = '🔖';
      pin.title = b.label || `しおり${i+1}`;
      pin.dataset.idx = String(i);
      const top = Math.max(8, Math.min(sec.scrollHeight-20, Number(b.offset||0)));
      pin.style.top = top + 'px';
      pin.addEventListener('click', ()=>{ window.readerJumpBookmark?.(i); });
      sec.appendChild(pin);
    });
  }

  // Ensure styles exist
  (function ensureReaderBmCss(){
    if (document.getElementById('cc-reader-bm-css')) return;
    const st = document.createElement('style');
    st.id = 'cc-reader-bm-css';
    st.textContent = `
      .reader-bm-pin{ position:absolute; left:8px; width:18px; height:18px; display:flex; align-items:center; justify-content:center;
        border-radius:999px; background: rgba(253,224,71,0.85); border:1px solid rgba(245,158,11,0.85); cursor:pointer;
        user-select:none; font-size:12px; line-height:1; z-index:10; box-shadow:0 1px 2px rgba(0,0,0,0.15);
      }
      body.theme-dark .reader-bm-pin{ background: rgba(14,116,144,0.55); border-color: rgba(56,189,248,0.7); }
    `;
    document.head.appendChild(st);
  })();

  // Patch/override reader bookmark functions to use section+offset and readable labels
  window.readerAddBookmark = function(){
    const {scroll} = getReaderEls();
    if (!scroll) return;
    const {idx, offset} = findSectionAt(scroll.scrollTop);
    const ratio = scroll.clientHeight ? ((scroll.scrollTop - readerSections()[idx].offsetTop) / Math.max(1, readerSections()[idx].scrollHeight)) : 0;
    const ex = excerptFromTab(idx, Math.max(0, Math.min(1, ratio)));
    const label = `${getTabName(idx)}：${ex||'（位置）'}`;
    const bms = loadBMs();
    bms.push({sectionIndex: idx, offset: offset, label: label, created: Date.now()});
    saveBMs(bms);
    renderReaderBookmarkSelect();
    renderReaderBookmarkPins();
    const {select} = getReaderEls();
    if (select) select.value = String(bms.length-1);
  };

  window.readerJumpBookmark = function(forcedIndex){
    const {scroll, select} = getReaderEls();
    if (!scroll) return;
    const bms = loadBMs();
    const idx = (typeof forcedIndex==='number') ? forcedIndex : (select && select.value!=='' ? Number(select.value) : -1);
    if (!Number.isFinite(idx) || idx<0 || idx>=bms.length) return;
    const b = bms[idx];
    const secs = readerSections();
    const si = Number(b.sectionIndex);
    if (!Number.isFinite(si) || !secs[si]) return;
    const y = secs[si].offsetTop + Number(b.offset||0);
    scroll.scrollTop = y;
    // flash pin
    const pin = secs[si].querySelector(`.reader-bm-pin[data-idx="${idx}"]`);
    if (pin){ pin.animate?.([{transform:'scale(1)'},{transform:'scale(1.25)'},{transform:'scale(1)'}], {duration:380}); }
  };

  // Reader search: make Enter work and ensure active hit scrolls
  if (typeof window.readerDoSearch === 'function'){
    // keep existing, but ensure it runs after render
  }

  function hookReaderOpen(){
    if (typeof window.openReaderView === 'function' && !window.openReaderView.__fix2){
      const baseOpen = window.openReaderView;
      window.openReaderView = function(){
        const r = baseOpen.apply(this, arguments);
        setTimeout(()=>{
          renderReaderBookmarkSelect();
          renderReaderBookmarkPins();
          try{ if ($('#reader-search-info')) $('#reader-search-info').textContent = '0/0'; }catch(_){ }
        }, 0);
        return r;
      };
      window.openReaderView.__fix2 = true;
    }
    if (typeof window.closeReaderView === 'function' && !window.closeReaderView.__fix2){
      const baseClose = window.closeReaderView;
      window.closeReaderView = function(){
        const r = baseClose.apply(this, arguments);
        return r;
      };
      window.closeReaderView.__fix2 = true;
    }
  }
  hookReaderOpen();

  // Ensure reader search binds to Enter
  (function bindReaderEnter(){
    const {input} = getReaderEls();
    if (!input || input.__fix2) return;
    input.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        e.preventDefault();
        window.readerDoSearch?.();
      }
    });
    input.__fix2 = true;
  })();

  // ---------- 2) Active tab color: reliable apply + reset button ----------
  const ACTIVE_TAB_DEFAULT = '#fff59d';
  const ACTIVE_TAB_KEY = 'cc_active_tab_color_v2';
  function shadeHex(hex, amt){
    let c = String(hex||'').trim();
    if (!c) return hex;
    if (c[0]==='#') c=c.slice(1);
    if (c.length===3) c=c.split('').map(ch=>ch+ch).join('');
    if (c.length!==6) return '#f59e0b';
    const num=parseInt(c,16);
    let r=(num>>16)&255,g=(num>>8)&255,b=num&255;
    const f=(x)=> Math.max(0, Math.min(255, Math.round(x + (amt>=0 ? (255-x)*amt : x*amt))));
    r=f(r); g=f(g); b=f(b);
    return '#' + ((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1);
  }
  function applyActiveTabColor(color){
    const c = color || ACTIVE_TAB_DEFAULT;
    const root = document.documentElement;
    root.style.setProperty('--active-tab-bg', c);
    root.style.setProperty('--active-tab-border', shadeHex(c, -0.35));
    root.style.setProperty('--active-tab-text', 'var(--text-color)');
  }
  function loadActiveTabColor(){
    try{ return localStorage.getItem(ACTIVE_TAB_KEY) || localStorage.getItem('cc_active_tab_color_v1') || ACTIVE_TAB_DEFAULT; }catch(e){ return ACTIVE_TAB_DEFAULT; }
  }
  function saveActiveTabColor(c){
    try{ localStorage.setItem(ACTIVE_TAB_KEY, c); }catch(e){}
  }
  function bindActiveTabControls(){
    const inp = document.getElementById('st-active-tab-color') || document.getElementById('active-tab-color-input');
    if (inp && !inp.__fix2){
      const c = loadActiveTabColor();
      inp.value = c;
      applyActiveTabColor(c);
      inp.addEventListener('input', ()=>{ applyActiveTabColor(inp.value); saveActiveTabColor(inp.value); });
      inp.__fix2 = true;
    }
    // add reset button near the setting label
    const label = inp?.closest('label') || inp?.parentElement;
    if (label && !document.getElementById('btn-active-tab-color-reset-fix2')){
      const btn = document.createElement('button');
      btn.type='button';
      btn.className='btn';
      btn.id='btn-active-tab-color-reset-fix2';
      btn.textContent='リセット';
      btn.style.marginLeft='6px';
      btn.addEventListener('click', ()=>{
        const d = ACTIVE_TAB_DEFAULT;
        if (inp) inp.value = d;
        applyActiveTabColor(d);
        saveActiveTabColor(d);
      });
      label.appendChild(btn);
    }
  }
  bindActiveTabControls();
  window.addEventListener('load', ()=>{ applyActiveTabColor(loadActiveTabColor()); bindActiveTabControls(); }, {once:true});

  // ---------- 3) Per-tab stats: show (chars and today's delta) on each tab ----------
  const DAY_START_KEY = 'cc_day_start_v1';
  const TAB_SNAP_KEY = 'cc_tab_daily_base_v1';
  function getDayStartMin(){
    // Try to read from UI if exists, else localStorage, else 0.
    const t = document.getElementById('st-day-start')?.value;
    let raw = t;
    if (!raw){
      try{ raw = localStorage.getItem(DAY_START_KEY) || '00:00'; }catch(e){ raw='00:00'; }
    }
    const m = /^\s*(\d{1,2}):(\d{2})\s*$/.exec(String(raw||''));
    if (!m) return 0;
    const hh = Math.max(0, Math.min(23, int(m[1])));
    const mm = Math.max(0, Math.min(59, int(m[2])));
    return hh*60+mm;
  }
  function int(s){ try{ return parseInt(s,10); }catch(e){ return 0; } }
  function todayKey(){
    const now = new Date();
    const off = getDayStartMin();
    const shifted = new Date(now.getTime() - off*60*1000);
    const y = shifted.getFullYear();
    const m = String(shifted.getMonth()+1).padStart(2,'0');
    const d = String(shifted.getDate()).padStart(2,'0');
    return `${y}-${m}-${d}`;
  }
  function loadTabSnap(){
    try{
      const raw = localStorage.getItem(TAB_SNAP_KEY);
      const v = raw ? JSON.parse(raw) : {};
      return (v && typeof v==='object') ? v : {};
    }catch(e){ return {}; }
  }
  function saveTabSnap(v){
    try{ localStorage.setItem(TAB_SNAP_KEY, JSON.stringify(v)); }catch(e){}
  }
  function countChars(s){
    return String(s||'').replace(/[\s　]/g,'').length;
  }
  function ensureDailyBase(tabId, current){
    const k = todayKey();
    const snap = loadTabSnap();
    snap[k] = snap[k] || {};
    if (snap[k][tabId] == null) snap[k][tabId] = current;
    saveTabSnap(snap);
    return snap[k][tabId];
  }
  function tabButtons(){
    const bar = document.getElementById('input-tabs');
    if (!bar) return [];
    return Array.from(bar.querySelectorAll('.input-tab'));
  }
  function renderTabStats(){
    if (!Array.isArray(window.inputTabs)) return;
    // sync current
    try{
      const active = window.inputTabs.find(t=>t.id===window.activeTabId);
      const ia = document.getElementById('input-area');
      if (active && ia) active.content = ia.value;
    }catch(_){ }

    const buttons = tabButtons();
    const map = new Map(window.inputTabs.map(t=>[t.id,t]));
    buttons.forEach(btn=>{
      const id = btn.dataset.tabId || btn.getAttribute('data-tab-id');
      const tab = map.get(id);
      if (!tab) return;
      const cnt = countChars(tab.content||'');
      const base = ensureDailyBase(tab.id, cnt);
      const delta = cnt - base;
      let badge = btn.querySelector('.tab-count-badge-fix2');
      if (!badge){
        badge = document.createElement('span');
        badge.className = 'tab-count-badge-fix2';
        badge.style.marginLeft = '6px';
        badge.style.fontSize = '11px';
        badge.style.opacity = '0.82';
        badge.style.whiteSpace = 'nowrap';
        btn.appendChild(badge);
      }
      const ds = delta>0 ? ` +${delta}` : (delta<0 ? ` ${delta}` : '');
      badge.textContent = `(${cnt}${ds})`;
    });
  }
  let tmr=null;
  function schedule(){
    clearTimeout(tmr);
    tmr=setTimeout(renderTabStats, 200);
  }
  const ia = document.getElementById('input-area');
  if (ia && !ia.__fix2TabStats){
    ia.addEventListener('input', schedule);
    ia.__fix2TabStats = true;
  }
  if (typeof window.setActiveTab === 'function' && !window.setActiveTab.__fix2Wrapped){
    const base = window.setActiveTab;
    window.setActiveTab = function(){
      const r = base.apply(this, arguments);
      setTimeout(renderTabStats, 0);
      return r;
    };
    window.setActiveTab.__fix2Wrapped = true;
  }
  window.addEventListener('load', ()=>setTimeout(renderTabStats, 60), {once:true});

  // ---------- 4) Concentration mode: disable Ctrl+Shift shortcuts to avoid misfires ----------
  const BLOCK = new Set(['KeyP','KeyM','KeyO']);
  window.addEventListener('keydown', (e)=>{
    if (!document.body.classList.contains('concentrate-mode')) return;
    if (e.ctrlKey && e.shiftKey && BLOCK.has(e.code)){
      e.stopImmediatePropagation();
      e.preventDefault();
    }
  }, true);

})();
</script>


<script>
// ===== v0.98: Outline panel becomes NAV (目次/しおり/検索/校正/メモ) + shortcuts Alt+O/M/F/B/K =====
(function(){
  function $1(sel, root){ return (root||document).querySelector(sel); }

  function genericSwitchOutlineTab(key){
    document.querySelectorAll('#outline-panel .outline-tab-content').forEach(d=>d.classList.remove('active'));
    const content = document.getElementById('outline-tab-'+key);
    if (content) content.classList.add('active');
    document.querySelectorAll('#outline-panel .memo-tab').forEach(t=>t.classList.remove('active'));
    const btn = Array.from(document.querySelectorAll('#outline-panel .memo-tab')).find(el=> (el.getAttribute('onclick')||'').includes("'"+key+"'"));
    if (btn) btn.classList.add('active');
  }

  // Patch switchOutlineTab to handle new keys reliably
  if (typeof window.switchOutlineTab === 'function'){
    const orig = window.switchOutlineTab;
    window.switchOutlineTab = function(key){
      try{ orig(key); }catch(e){}
      if (document.getElementById('outline-tab-'+key)) genericSwitchOutlineTab(key);
    };
  } else {
    window.switchOutlineTab = genericSwitchOutlineTab;
  }

  // Open NAV + focus
  window.openNavTab = function(which){
    const panel = document.getElementById('outline-panel');
    if (!panel) return;
    panel.classList.add('open');
    try{ if (typeof window.updatePanelButtonStates==='function') window.updatePanelButtonStates(); }catch(e){}
    try{ if (typeof window.applyPaneWidthSettings==='function') window.applyPaneWidthSettings(); }catch(e){}
    try{ if (typeof window.updateDockTopOffset==='function') window.updateDockTopOffset(); }catch(e){}

    window.switchOutlineTab(which);

    if (which==='memo'){
      const ta = document.getElementById('memo-area');
      if (ta) setTimeout(()=>ta.focus(), 0);
    }
    if (which==='search'){
      const si = document.getElementById('search-input');
      if (si) setTimeout(()=>si.focus(), 0);
    }
  };

  // Move search bar + memo panel into nav tabs
  function relocatePanelsIntoNav(){
    const searchBar = document.getElementById('search-bar');
    const searchHost = document.getElementById('nav-search-host');
    if (searchBar && searchHost && !searchHost.contains(searchBar)){
      searchHost.appendChild(searchBar);
      const pin = searchBar.querySelector('.panel-pin-btn');
      const close = searchBar.querySelector('.panel-close-btn');
      if (pin) pin.style.display = 'none';
      if (close) close.style.display = 'none';
    }

    const memoPanel = document.getElementById('memo-panel');
    const memoHost = document.getElementById('nav-memo-host');
    if (memoPanel && memoHost && !memoHost.contains(memoPanel)){
      memoHost.appendChild(memoPanel);
      memoPanel.classList.add('open');
    }

    // Old resizers are confusing now
    const rz1 = document.getElementById('resizer-memo');
    const rz2 = document.getElementById('resizer-memo-outline');
    if (rz1) rz1.style.display = 'none';
    if (rz2) rz2.style.display = 'none';

    // Header buttons -> nav
    const btnMemo = document.getElementById('btn-toggle-memo');
    if (btnMemo) btnMemo.onclick = ()=> openNavTab('memo');
    const btnOutline = document.getElementById('btn-toggle-outline');
    if (btnOutline) btnOutline.onclick = ()=> openNavTab('outline');
    const btnSearch = document.getElementById('btn-toggle-search');
    if (btnSearch) btnSearch.onclick = ()=> openNavTab('search');

    // Ctrl+F -> nav search
    document.addEventListener('keydown', (e)=>{
      if (e.ctrlKey && !e.shiftKey && !e.altKey && !e.metaKey && (e.key==='f' || e.key==='F')){
        e.preventDefault();
        openNavTab('search');
      }
    }, true);
  }

  // Alt shortcuts
  function hookAltShortcuts(){
    document.addEventListener('keydown', (e)=>{
      if (!e.altKey || e.ctrlKey || e.metaKey) return;
      const k = (e.key||'').toLowerCase();
      const map = { 'o':'outline', 'm':'memo', 'f':'search', 'b':'bookmark', 'k':'proof' };
      if (!map[k]) return;
      e.preventDefault();
      e.stopPropagation();
      openNavTab(map[k]);
    }, true);
  }

  // Extend search target to include memo (dropdown)
  function patchSearchTargetAndEngine(){
    const sel = document.getElementById('search-scope');
    if (!sel) return;

    // Save current value if one of old options
    const oldVal = sel.value || 'current';

    sel.innerHTML = '';
    const opts = [
      ['input_current','本文(このタブ)'],
      ['input_all','本文(全タブ)'],
      ['memo_current','メモ(このタブ)'],
      ['memo_all','メモ(全タブ)'],
      ['both_all','本文+メモ(全て)'],
    ];
    for (const [v,lab] of opts){
      const o=document.createElement('option');
      o.value=v; o.textContent=lab;
      sel.appendChild(o);
    }
    sel.value = (oldVal==='all') ? 'input_all' : 'input_current';

    // We override doSearch/findNext/findPrev/replaceOne/replaceAll with an engine that supports our targets.
    // This replaces the previous patch but keeps behavior (hits list, preview, etc.)

    let matches = [];
    let idx = -1;
    let lastQ = '';
    let lastScope = 'input_current';

    const escapeRe = (s)=> s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

    function calcLineInfo(text, pos){
      const before = text.slice(0,pos);
      const lineNum = (before.match(/\n/g)||[]).length + 1;
      const lineStart = before.lastIndexOf('\n')+1;
      const lineEnd = text.indexOf('\n', pos);
      const lineText = text.slice(lineStart, lineEnd===-1?text.length:lineEnd);
      return {lineNum, lineText: lineText.trim(), lineStart};
    }

    function getInputTextForTab(tab){
      if (!tab) return '';
      if (tab.id === window.activeTabId && window.inputArea) return window.inputArea.value;
      return tab.content || '';
    }
    function getMemoTextForTab(tab){
      if (!tab) return '';
      // memo active might be in textarea
      if (tab.id === window.activeMemoTabId && window.memoArea) return window.memoArea.value;
      return tab.content || '';
    }

    function collectAll(query, scope){
      const rx = new RegExp(escapeRe(query), 'g');
      const inputTabs = Array.isArray(window.inputTabs) ? window.inputTabs : [];
      const memoTabs = Array.isArray(window.memoTabs) ? window.memoTabs : [];
      const res=[];

      function scan(text, meta){
        if (!text) return;
        rx.lastIndex = 0;
        let m;
        while((m=rx.exec(text))!==null){
          const pos = m.index;
          const li = calcLineInfo(text, pos);
          res.push({
            kind: meta.kind, // 'input'|'memo'
            tabId: meta.tabId,
            tabName: meta.tabName,
            start: pos,
            end: pos + m[0].length,
            lineNum: li.lineNum,
            preview: li.lineText.slice(0,80),
            memoTabId: meta.memoTabId
          });
          if (m[0].length===0) rx.lastIndex++;
        }
      }

      if (scope==='input_current'){
        const t = inputTabs.find(t=>t.id===window.activeTabId);
        scan(getInputTextForTab(t), {kind:'input', tabId: t?.id, tabName: t?.name||''});
      } else if (scope==='input_all'){
        for (const t of inputTabs) scan(getInputTextForTab(t), {kind:'input', tabId: t.id, tabName: t.name||''});
      } else if (scope==='memo_current'){
        const t = memoTabs.find(t=>t.id===window.activeMemoTabId);
        scan(getMemoTextForTab(t), {kind:'memo', tabId: window.activeTabId, tabName: (inputTabs.find(x=>x.id===window.activeTabId)?.name)||'', memoTabId: t?.id});
      } else if (scope==='memo_all'){
        for (const mt of memoTabs){
          scan(getMemoTextForTab(mt), {kind:'memo', tabId: window.activeTabId, tabName: (inputTabs.find(x=>x.id===window.activeTabId)?.name)||'', memoTabId: mt.id});
        }
      } else if (scope==='both_all'){
        for (const t of inputTabs) scan(getInputTextForTab(t), {kind:'input', tabId: t.id, tabName: t.name||''});
        for (const mt of memoTabs) scan(getMemoTextForTab(mt), {kind:'memo', tabId: window.activeTabId, tabName: (inputTabs.find(x=>x.id===window.activeTabId)?.name)||'', memoTabId: mt.id});
      }

      return res.filter(m=>m.tabId!=null);
    }

    function updateInfo(){
      const info = document.getElementById('search-match-info');
      if (info) info.textContent = `${matches.length? (idx+1):0} / ${matches.length}`;
    }

    function jumpTo(m){
      if (!m) return;
      if (m.kind==='input'){
        if (m.tabId!==window.activeTabId && typeof window.switchTab==='function') window.switchTab(m.tabId);
        const ta = window.inputArea;
        if (!ta) return;
        ta.focus();
        ta.setSelectionRange(m.start, m.end);
        if (typeof window.scrollToCursorPosition==='function') setTimeout(()=>window.scrollToCursorPosition(m.start), 60);
        if (typeof window.updateCursorLineDisplay==='function') window.updateCursorLineDisplay();
      } else {
        // memo
        openNavTab('memo');
        if (typeof window.switchMemoTab==='function' && m.memoTabId) window.switchMemoTab(m.memoTabId);
        const ta = window.memoArea || document.getElementById('memo-area');
        if (!ta) return;
        ta.focus();
        try{ ta.setSelectionRange(m.start, m.end); }catch(e){}
      }
      idx = matches.findIndex(x=>x.kind===m.kind && x.tabId===m.tabId && x.start===m.start && x.end===m.end && x.memoTabId===m.memoTabId);
      updateInfo();
    }

    function renderHits(){
      const box = document.getElementById('search-hits');
      if (!box) return;
      box.innerHTML = '';
      if (!lastQ){
        box.innerHTML = '<div class="outline-empty">ヒット一覧はここに表示されます</div>';
        return;
      }
      if (!matches.length){
        box.innerHTML = '<div class="outline-empty">ヒットなし</div>';
        return;
      }

      const maxShow = 300;
      const slice = matches.slice(0, maxShow);
      const grouped = {};
      for (const m of slice){
        const key = m.kind==='memo' ? `memo-${m.memoTabId||0}` : `input-${m.tabId}`;
        const name = m.kind==='memo' ? `メモ${m.memoTabId||''}` : (m.tabName||('タブ'+m.tabId));
        (grouped[key] ||= {name, kind:m.kind, items:[]}).items.push(m);
      }

      for (const g of Object.values(grouped)){
        const head = document.createElement('div');
        head.style.fontWeight='700';
        head.style.margin='6px 0 2px';
        head.textContent = `【${g.name}】 (${g.items.length})`;
        box.appendChild(head);
        for (const m of g.items){
          const div = document.createElement('div');
          div.className = 'bookmark-item';
          div.style.cursor='pointer';
          const prefix = (m.kind==='memo') ? '📝' : '🔎';
          div.innerHTML = `${prefix} ${m.lineNum}行: ${escapeHtml(m.preview)}`;
          div.addEventListener('click', ()=> jumpTo(m));
          div.addEventListener('contextmenu', (ev)=>{
            ev.preventDefault();
            // right-click -> add bookmark (only for input) / add reader bookmark (for memo not supported)
            if (m.kind==='input' && typeof window.addBookmark==='function'){
              // jump first so bookmark captures correct pos
              jumpTo(m);
              setTimeout(()=>{ try{ window.addBookmark(); }catch(e){} }, 0);
            }
          });
          box.appendChild(div);
        }
      }

      if (matches.length > maxShow){
        const note = document.createElement('div');
        note.className='outline-empty';
        note.textContent = `表示は${maxShow}件まで（全${matches.length}件）`;
        box.appendChild(note);
      }
    }

    window.doSearch = function(){
      const q = (document.getElementById('search-input')?.value || '').trim();
      const scope = document.getElementById('search-scope')?.value || 'input_current';
      lastQ = q;
      lastScope = scope;
      if (!q){
        matches = []; idx = -1;
        updateInfo();
        renderHits();
        return;
      }
      matches = collectAll(q, scope);
      // sort stable
      matches.sort((a,b)=> (a.kind===b.kind?0:(a.kind==='input'?-1:1)) || (a.tabId-b.tabId) || ((a.memoTabId||0)-(b.memoTabId||0)) || (a.start-b.start));
      idx = matches.length ? 0 : -1;
      updateInfo();
      renderHits();
      if (idx>=0) jumpTo(matches[0]);
    };

    window.findNext = function(){
      if (!matches.length) return;
      idx = (idx+1) % matches.length;
      updateInfo();
      jumpTo(matches[idx]);
    };
    window.findPrev = function(){
      if (!matches.length) return;
      idx = (idx-1 + matches.length) % matches.length;
      updateInfo();
      jumpTo(matches[idx]);
    };

    window.replaceOne = function(){
      const q = (document.getElementById('search-input')?.value || '');
      const rep = (document.getElementById('replace-input')?.value || '');
      if (!q) return;
      if (!matches.length || idx<0) window.doSearch();
      if (!matches.length) return;
      const m = matches[idx];
      if (m.kind==='memo'){
        openNavTab('memo');
        if (typeof window.switchMemoTab==='function' && m.memoTabId) window.switchMemoTab(m.memoTabId);
        const ta = window.memoArea || document.getElementById('memo-area');
        if (!ta) return;
        const text = ta.value;
        if (text.slice(m.start, m.end) !== q){ window.doSearch(); return; }
        ta.setRangeText(rep, m.start, m.end, 'select');
        try{ if (typeof window.saveMemoTabs==='function') window.saveMemoTabs(); }catch(e){}
      } else {
        // input
        jumpTo(m);
        const ta = window.inputArea;
        if (!ta) return;
        const text = ta.value;
        if (text.slice(m.start, m.end) !== q){ window.doSearch(); return; }
        ta.setRangeText(rep, m.start, m.end, 'select');
        // update active tab content
        const t = (window.inputTabs||[]).find(t=>t.id===window.activeTabId);
        if (t) t.content = ta.value;
        try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
      }
      window.doSearch();
    };

    window.replaceAll = function(){
      const q = (document.getElementById('search-input')?.value || '');
      const rep = (document.getElementById('replace-input')?.value || '');
      if (!q) return;
      if (!matches.length) window.doSearch();
      const count = matches.length;
      if (!count) return;
      if (!confirm(`${count}件を全置換しますか？（範囲: ${document.getElementById('search-scope')?.selectedOptions?.[0]?.textContent||''}）`)) return;

      const scope = document.getElementById('search-scope')?.value || 'input_current';
      const inputTabs = Array.isArray(window.inputTabs) ? window.inputTabs : [];
      const memoTabs = Array.isArray(window.memoTabs) ? window.memoTabs : [];

      const replaceInText = (text)=> text.split(q).join(rep);

      if (scope==='input_current'){
        const ta=window.inputArea;
        if (ta) ta.value = replaceInText(ta.value);
        const t=inputTabs.find(t=>t.id===window.activeTabId);
        if (t) t.content = ta?ta.value:replaceInText(t.content||'');
      } else if (scope==='input_all' || scope==='both_all'){
        for (const t of inputTabs){
          if (t.id===window.activeTabId && window.inputArea){
            window.inputArea.value = replaceInText(window.inputArea.value);
            t.content = window.inputArea.value;
          } else {
            t.content = replaceInText(t.content||'');
          }
        }
      }

      if (scope==='memo_current'){
        openNavTab('memo');
        const ta = window.memoArea || document.getElementById('memo-area');
        if (ta) ta.value = replaceInText(ta.value);
        const t=memoTabs.find(t=>t.id===window.activeMemoTabId);
        if (t) t.content = ta?ta.value:replaceInText(t.content||'');
        try{ if (typeof window.saveMemoTabs==='function') window.saveMemoTabs(); }catch(e){}
      } else if (scope==='memo_all' || scope==='both_all'){
        for (const mt of memoTabs){
          if (mt.id===window.activeMemoTabId && (window.memoArea||document.getElementById('memo-area'))){
            const ta = window.memoArea || document.getElementById('memo-area');
            if (ta){ ta.value = replaceInText(ta.value); mt.content = ta.value; }
          } else {
            mt.content = replaceInText(mt.content||'');
          }
        }
        try{ if (typeof window.saveMemoTabs==='function') window.saveMemoTabs(); }catch(e){}
      }

      try{ if (typeof window.updateInputStats==='function') window.updateInputStats(); }catch(e){}
      window.doSearch();
    };

    // rerun search when scope changes
    sel.addEventListener('change', ()=>{ if (document.getElementById('search-input')?.value) window.doSearch(); });
  }

  function init(){
    relocatePanelsIntoNav();
    hookAltShortcuts();
    patchSearchTargetAndEngine();
  }

  if (document.readyState==='loading') document.addEventListener('DOMContentLoaded', init);
  else init();
})();
</script>
</body>
</html>
